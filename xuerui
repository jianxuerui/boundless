#!/bin/bash
# 确保脚本在发生错误时立即退出
set -e

# ==============================================================================
# Nexus 多节点管理脚本 (ARM64专用Docker版)
# 作者: 哈哈哈哈 (推特 @ferdie_jhovie)
# 描述: 此脚本使用 Docker 来管理多个 Nexus 节点，特别为 ARM64 架构优化。
#
# 【V3.4 社区修复版】:
#   - 【关键修复】根据用户提供的调试日志，修复了 list_nodes 函数中的循环逻辑。
#   - 将不稳定的 `for var in $multiline_string` 循环替换为标准的 `while read`
#     循环，确保在所有环境中都能正确处理容器列表，避免脚本意外退出。
# ==============================================================================

# --- 配置项 ---
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest-arm64"
LOG_DIR="/root/nexus_logs"
BUILDER_NAME="nexus_builder" # 为我们的项目创建一个专用的 builder

# --- 核心功能函数 ---

# 检查 Docker 是否安装
function check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "检测到未安装 Docker，正在为您安装..."
        apt-get update
        apt-get install -y apt-transport-https ca-certificates curl software-properties-common
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
        add-apt-repository "deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
        apt-get update
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        systemctl enable docker
        systemctl start docker
        echo "Docker 安装完成！"
    fi
    if ! docker buildx version >/dev/null 2>&1; then
        echo "错误：未找到 Docker buildx 插件。请确保您的 Docker 版本包含 buildx。"
        echo "尝试安装命令: apt-get install docker-buildx-plugin"
        exit 1
    fi
}

# 设置 Buildx 以支持跨平台构建
function setup_buildx() {
    if docker buildx ls | grep -q "^${BUILDER_NAME}.*running"; then
        echo "Buildx 环境 '$BUILDER_NAME' 已准备就绪。"; docker buildx use $BUILDER_NAME; return;
    fi
    echo "检测到需要设置跨平台构建环境 (QEMU)..."
    if docker buildx ls | grep -q "$BUILDER_NAME"; then
        echo "正在启动已存在的 builder '$BUILDER_NAME'..."; docker buildx inspect $BUILDER_NAME --bootstrap;
    else
        echo "正在创建新的 buildx builder '$BUILDER_NAME'..."; docker buildx create --name $BUILDER_NAME --driver docker-container --use;
    fi
    if ! docker run --rm --privileged tonistiigi/binfmt | grep -q "setting up"; then
        echo "正在注册 QEMU 模拟器..."; docker run --rm --privileged tonistiigi/binfmt --install all; echo "QEMU 模拟器注册完成。";
    fi
    echo "Buildx 环境设置完成。"
}

# 构建 Docker 镜像
function build_image() {
    if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then echo "镜像 $IMAGE_NAME 已存在，跳过构建。"; return; fi
    setup_buildx; echo "正在准备构建环境..."; WORKDIR=$(mktemp -d); cd "$WORKDIR"
    cat > Dockerfile <<EOF
ARG TARGETPLATFORM=linux/arm64
FROM --platform=\$TARGETPLATFORM ubuntu:24.04
ENV DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y curl screen bash && rm -rf /var/lib/apt/lists/*
RUN echo "正在下载 Nexus ARM64 二进制文件..." && \\
    curl -L -o /usr/local/bin/nexus-network https://github.com/nexus-xyz/nexus-cli/releases/download/v0.10.1/nexus-network-linux-arm64 && \\
    chmod +x /usr/local/bin/nexus-network
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
EOF
    cat > entrypoint.sh <<'EOF'
#!/bin/bash
set -e
PROVER_ID_FILE="/root/.nexus/node-id"
if [ -z "$NODE_ID" ]; then echo "错误：未通过 -e NODE_ID=... 设置环境变量！"; exit 1; fi
mkdir -p /root/.nexus; echo "$NODE_ID" > "$PROVER_ID_FILE"; echo "已将 Node ID 写入文件: $PROVER_ID_FILE"; echo "使用的 Node ID: $NODE_ID"
if ! command -v nexus-network >/dev/null 2>&1; then echo "错误：nexus-network 命令未在 /usr/local/bin 中找到或不可执行。"; exit 1; fi
screen -S nexus -X quit >/dev/null 2>&1 || true
echo "正在启动 nexus-network 节点..."; screen -dmS nexus bash -c "nexus-network start --node-id $NODE_ID | tee /root/nexus.log"
sleep 3
if screen -list | grep -q "nexus"; then
    echo "节点已在后台 screen 会话中成功启动。"; echo "容器内日志文件路径: /root/nexus.log"; echo "您可以使用 'docker logs -f \$HOSTNAME' 实时查看日志"
else
    echo "错误：节点启动失败！请检查配置和网络。"; if [ -f /root/nexus.log ]; then echo "--- 错误日志开始 ---"; cat /root/nexus.log; echo "--- 错误日志结束 ---"; fi; exit 1
fi
tail -f /root/nexus.log
EOF
    echo "正在使用 builder '$BUILDER_NAME' 构建 Docker 镜像 $IMAGE_NAME..."; docker buildx build --builder "$BUILDER_NAME" --platform linux/arm64 -t "$IMAGE_NAME" . --load
    echo "清理构建目录..."; cd - >/dev/null; rm -rf "$WORKDIR"; echo "镜像构建完成！"
}

# 启动一个节点容器
function run_container() {
    local node_id="$1"; if [ -z "$node_id" ]; then echo "错误：调用 run_container 时未提供 Node ID。"; return 1; fi
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"; local log_file="${LOG_DIR}/nexus-${node_id}.log"
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then echo "检测到旧容器 $container_name，正在删除..."; docker rm -f "$container_name"; fi
    mkdir -p "$LOG_DIR"; touch "$log_file"; chmod 644 "$log_file"
    echo "正在启动容器 $container_name..."; docker run -d --name "$container_name" -v "$log_file:/root/nexus.log" -e NODE_ID="$node_id" --restart unless-stopped "$IMAGE_NAME"
    echo "容器 $container_name 已启动！"; echo "宿主机日志文件位于: $log_file"; echo "查看实时日志命令: tail -f $log_file  或者  docker logs -f $container_name"
}

# --- 辅助管理函数 ---

function uninstall_node() {
    local node_id="$1"; if [ -z "$node_id" ]; then echo "错误：调用 uninstall_node 时未提供 Node ID。"; return 1; fi
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"; local log_file="${LOG_DIR}/nexus-${node_id}.log"
    echo "正在停止并删除容器 $container_name..."; if docker rm -f "$container_name" >/dev/null 2>&1; then echo "容器 $container_name 已删除。"; else echo "容器 $container_name 不存在或已删除。"; fi
    if [ -f "$log_file" ]; then echo "正在删除日志文件 $log_file..."; rm -f "$log_file"; fi; echo "节点 $node_id 的相关资源已卸载。"
}

# 【已修复】列出所有节点状态的函数
function list_nodes() {
    echo "--------------------------------- 当前 Nexus 节点状态 ---------------------------------"
    printf "%-30s %-12s %-15s %-20s\n" "节点 ID (容器名)" "状态" "CPU %" "内存使用"
    echo "-------------------------------------------------------------------------------------"
    
    # 步骤1：获取所有正在运行的目标容器的 stats，这步操作很高效
    local running_containers; running_containers=$(docker ps --filter "name=${BASE_CONTAINER_NAME}-" --filter "status=running" --format "{{.Names}}")
    local stats_output=""
    if [ -n "$running_containers" ]; then
        stats_output=$(docker stats --no-stream $running_containers --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}")
    fi
    
    # 步骤2：检查是否存在任何节点容器
    local all_containers_cmd="docker ps -a --filter name=${BASE_CONTAINER_NAME}- --format={{.Names}}"
    if ! $all_containers_cmd | read -r; then
        echo "未找到任何 Nexus 节点容器。"
    else
        # 步骤3：【关键修复】使用标准的 'while read' 循环来逐行处理容器列表，确保稳定性
        $all_containers_cmd | while IFS= read -r name; do
            # 忽略可能的空行
            [ -z "$name" ] && continue
            
            local node_id; node_id=$(echo "$name" | sed "s/${BASE_CONTAINER_NAME}-//")
            local stats_line; stats_line=$(echo "$stats_output" | grep -w "$name")

            if [ -n "$stats_line" ]; then
                # 如果在 stats 输出中找到，说明容器正在运行
                local cpu_perc mem_usage;
                cpu_perc=$(echo "$stats_line" | awk '{print $2}')
                mem_usage=$(echo "$stats_line" | awk -F '\t' '{print $3}')
                printf "%-30s %-12s %-15s %-20s\n" "$node_id ($name)" "Running" "$cpu_perc" "$mem_usage"
            else
                # 否则，容器已停止，单独获取其状态
                local status; status=$(docker ps -a --filter "name=$name" --format "{{.Status}}")
                printf "%-30s %-12s %-15s %-20s\n" "$node_id ($name)" "$status" "N/A" "N/A"
            fi
        done
    fi
    echo "-------------------------------------------------------------------------------------"
}

function get_all_node_ids() { docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort -u; }
function view_node_logs() { local node_id="$1"; if [ -z "$node_id" ]; then echo "错误"; return 1; fi; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then echo "错误"; return 1; fi; echo "正在显示节点 '$node_id' 的日志... 按 Ctrl+C 退出。"; sleep 1; docker logs -f "$container_name"; }
function batch_start_nodes() { build_image; echo "请输入多个 Node ID，每行一个。输入空行或按 Ctrl+D 结束："; local node_ids=(); while IFS= read -r line; do line=$(echo "$line" | xargs); [ -z "$line" ] && break; node_ids+=("$line"); done; if [ ${#node_ids[@]} -eq 0 ]; then echo "未输入任何 Node ID，操作取消。"; return; fi; echo "准备启动 ${#node_ids[@]} 个节点..."; for node_id in "${node_ids[@]}"; do run_container "$node_id"; sleep 1; done; echo "所有节点启动任务已提交！"; }
function select_node_for_action() { local action_callback="$1"; local prompt_message="$2"; local all_nodes=($(get_all_node_ids)); if [ ${#all_nodes[@]} -eq 0 ]; then echo "当前没有任何节点可供操作。"; read -p "按任意键返回..."; return; fi; echo "请选择一个要'${prompt_message}'的节点："; echo "0. 返回主菜单"; for i in "${!all_nodes[@]}"; do local node_id="${all_nodes[$i]}"; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; local status; status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}"); printf "%2d. 节点 %-25s [%s]\n" "$((i+1))" "$node_id" "$status"; done; read -rp "请输入选项(0-${#all_nodes[@]}): " choice; if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt ${#all_nodes[@]} ]; then echo "无效输入"; sleep 2; return; fi; [ "$choice" -eq 0 ] && return; local selected_node_id="${all_nodes[$((choice-1))]}"; "$action_callback" "$selected_node_id"; }
function batch_uninstall_nodes() { echo "将卸载所有当前管理的节点，但会保留Docker镜像。"; read -rp "您确定要继续吗? (y/N): " confirm; if [[ ! "$confirm" =~ ^[yY]([eE][sS])?$ ]]; then echo "操作已取消。"; return; fi; local all_nodes=($(get_all_node_ids)); if [ ${#all_nodes[@]} -eq 0 ]; then echo "没有找到任何节点，无需卸载。"; return; fi; echo "正在卸载 ${#all_nodes[@]} 个节点..."; for node_id in "${all_nodes[@]}"; do uninstall_node "$node_id"; done; echo "所有节点已卸载完成。"; }
function uninstall_all_nodes_and_image() { echo "!!! 警告：此操作将永久删除所有节点容器、日志和Nexus Docker镜像 !!!"; read -rp "此操作不可逆，请再次确认 (输入 'yes' 继续): " confirm; if [ "$confirm" != "yes" ]; then echo "操作已取消。"; return; fi; echo "--- 第一步：卸载所有节点 ---"; batch_uninstall_nodes; echo "--- 第二步：删除 Docker 镜像 ---"; if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then echo "正在删除镜像 $IMAGE_NAME..."; docker rmi -f "$IMAGE_NAME"; echo "镜像已删除。"; else echo "镜像 $IMAGE_NAME 不存在，跳过删除。"; fi; echo "--- 第三步：(可选) 删除日志目录 ---"; if [ -d "$LOG_DIR" ]; then read -rp "是否要删除宿主机上的总日志目录 '$LOG_DIR'? (y/N): " del_log_dir; if [[ "$del_log_dir" =~ ^[yY] ]]; then rm -rf "$LOG_DIR"; echo "日志目录 '$LOG_DIR' 已删除。"; fi; fi; echo "完全卸载操作完成。"; }

# --- 主菜单循环 ---
function main_menu() {
    # 检查用户权限
    if [ "$(id -u)" -ne 0 ]; then
       echo "错误：此脚本需要 root 权限运行。" >&2
       echo "请尝试使用 'sudo bash a.sh' 或切换到 root 用户。" >&2
       exit 1
    fi
    # 检查 Docker
    check_docker

    while true; do
        clear
        echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
        echo "================ Nexus 多节点管理 (ARM64 Docker版) v3.4 ==============="
        echo "1. 安装/启动单个节点"
        echo "2. 批量安装/启动多个节点"
        echo "3. 查看指定节点日志"
        echo "4. 卸载指定节点"
        echo "5. 批量卸载所有节点 (保留镜像)"
        echo "6. 完全卸载 (删除所有节点和镜像)"
        echo "7. 退出脚本"
        echo "==================================================================="
        list_nodes
        read -rp "请输入选项(1-7): " choice
        case $choice in
            1) read -rp "请输入您的 Node ID: " NODE_ID; if [ -z "$NODE_ID" ]; then echo "Node ID 不能为空！"; else build_image; run_container "$NODE_ID"; fi; read -p "操作完成，按任意键返回菜单..."; ;;
            2) batch_start_nodes; read -p "操作完成，按任意键返回菜单..."; ;;
            3) select_node_for_action "view_node_logs" "查看日志"; ;;
            4) select_node_for_action "uninstall_node" "卸载"; read -p "操作完成，按任意键返回..."; ;;
            5) batch_uninstall_nodes; read -p "操作完成，按任意键返回..."; ;;
            6) uninstall_all_nodes_and_image; read -p "操作完成，按任意键返回..."; ;;
            7) echo "退出脚本。"; exit 0; ;;
            *) echo "无效选项，请重新输入。"; sleep 1; ;;
        esac
    done
}

# --- 脚本执行入口 ---
main_menu
