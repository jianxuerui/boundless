#!/bin/bash
# ==========================================================================================
# Script Modificato: Gestore Multi-Nodo Nexus
# Versione: 1.4
# Correzione Definitiva: Aggiunto e corretto il repository EPEL per installare pacchetti
#                        come 'screen', garantendo la stabilità della build su CentOS 8 EOL.
# Adattato per: CentOS 8
# Versione Nexus: v0.10.8 (Hardcoded)
# Ottimizzazioni per Prestazioni: Rete Host, Politica di Riavvio, Rotazione dei Log
# ==========================================================================================
set -e

BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node-centos:v0.10.8-final"
LOG_DIR="/root/nexus_logs"

# 检查 Docker 是否安装 (适配 CentOS)
function check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "检测到未安装 Docker，正在为 CentOS 安装..."
        dnf install -y dnf-utils
        dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo
        dnf install -y docker-ce docker-ce-cli containerd.io
        systemctl enable docker
        systemctl start docker
        echo "Docker 安装并启动成功。"
    fi
}

# 检查 Node.js/npm/pm2 是否安装 (适配 CentOS)
function check_pm2() {
    if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
        echo "检测到未安装 Node.js/npm，正在为 CentOS 安装..."
        dnf module install -y nodejs:18
        echo "Node.js 安装成功。"
    fi
    if ! command -v pm2 >/dev/null 2>&1; then
        echo "检测到未安装 pm2，正在安装..."
        npm install -g pm2
        echo "pm2 安装成功。"
    fi
}

# 构建docker镜像函数 (修复 CentOS 8 基础源 和 EPEL 源)
function build_image() {
    if docker image inspect "$IMAGE_NAME" &>/dev/null; then
        echo "镜像 ${IMAGE_NAME} 已存在，跳过构建。"
        return
    fi

    echo "正在构建镜像 ${IMAGE_NAME}..."
    WORKDIR=$(mktemp -d)
    cd "$WORKDIR"

    cat > Dockerfile <<EOF
FROM centos:8

# [FIX 1/2] Point base CentOS 8 repos to vault.centos.org for EOL systems
RUN cd /etc/yum.repos.d/ && \
    sed -i 's/mirrorlist/#mirrorlist/g' CentOS-* && \
    sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' CentOS-*

# [FIX 2/2] Install EPEL repo (for 'screen' package) and also point it to an archive URL
RUN dnf install -y epel-release && \
    sed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/epel*.repo && \
    sed -i 's|#baseurl=https://download.fedoraproject.org/pub/epel/|baseurl=https://archives.fedoraproject.org/pub/epel/|g' /etc/yum.repos.d/epel*.repo

# Now, install necessary tools from both base and EPEL repos
RUN dnf install -y curl screen bash && dnf clean all

# Directly download and install specified version of nexus-network v0.10.8
RUN curl -L -o /usr/local/bin/nexus-network https://github.com/nexus-xyz/nexus-cli/releases/download/v0.10.8/nexus-network-linux-x86_64 && \
    chmod +x /usr/local/bin/nexus-network

# Copy and authorize entrypoint script
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
EOF

    cat > entrypoint.sh <<EOF
#!/bin/bash
set -e
PROVER_ID_FILE="/root/.nexus/node-id"
if [ -z "\$NODE_ID" ]; then
    echo "错误：未设置 NODE_ID 环境变量"
    exit 1
fi
mkdir -p /root/.nexus
echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo "使用的 node-id: \$NODE_ID"
if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 未安装或不可用"
    exit 1
fi
screen -S nexus -X quit >/dev/null 2>&1 || true
echo "启动 nexus-network 节点..."
screen -dmS nexus bash -c "nexus-network start --node-id \$NODE_ID"
sleep 5
if screen -list | grep -q "nexus"; then
    echo "节点已在后台启动。"
    echo "请使用 'docker logs -f \$HOSTNAME' 命令查看实时日志"
    tail -f /dev/null
else
    echo "节点启动失败，请检查配置或使用 'docker logs \$HOSTNAME' 查看启动错误。"
    exit 1
fi
EOF

    docker build -t "$IMAGE_NAME" .

    cd -
    rm -rf "$WORKDIR"
    echo "镜像构建完成。"
}

# 启动容器（优化性能和稳定性）
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    mkdir -p "$LOG_DIR"

    if docker ps -a --format '{{.Names}}' | grep -qw "^${container_name}$"; then
        echo "检测到旧容器 $container_name，正在删除..."
        docker rm -f "$container_name"
    fi

    echo "正在以高性能模式启动容器 $container_name ..."
    docker run -d \
        --name "$container_name" \
        --network host \
        --restart unless-stopped \
        --log-opt max-size=100m \
        --log-opt max-file=3 \
        -e NODE_ID="$node_id" \
        "$IMAGE_NAME"
        
    echo "容器 $container_name 已启动！"
    echo "使用命令 'docker logs -f $container_name' 查看日志。"
}


# 停止并卸载容器
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    echo "正在停止并删除容器 $container_name..."
    if docker ps -a --format '{{.Names}}' | grep -qw "^${container_name}$"; then
        docker rm -f "$container_name"
        echo "容器 $container_name 已删除。"
    else
        echo "容器 $container_name 不存在。"
    fi
    echo "节点 $node_id 已卸载完成。"
}

# 批量节点轮换启动
function batch_rotate_nodes() {
    check_pm2
    echo "请输入多个 node-id，每行一个，输入空行结束："
    echo "（输入完成后按回车键，然后按 Ctrl+D 结束输入）"
    
    local node_ids=()
    while read -r line; do
        if [ -n "$line" ]; then
            node_ids+=("$line")
        fi
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 node-id，返回主菜单"
        read -p "按任意键继续"
        return
    fi

    read -rp "请输入每两小时要启动的节点数量（默认：${#node_ids[@]}的一半，向上取整）: " nodes_per_round
    if [ -z "$nodes_per_round" ]; then
        nodes_per_round=$(( (${#node_ids[@]} + 1) / 2 ))
    fi

    if ! [[ "$nodes_per_round" =~ ^[0-9]+$ ]] || [ "$nodes_per_round" -lt 1 ] || [ "$nodes_per_round" -gt ${#node_ids[@]} ]; then
        echo "无效的节点数量，请输入1到${#node_ids[@]}之间的数字"
        read -p "按任意键返回菜单"
        return
    fi

    local total_nodes=${#node_ids[@]}
    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    
    echo "停止旧的轮换进程..."
    pm2 delete nexus-rotate 2>/dev/null || true

    echo "开始构建镜像..."
    build_image

    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir"

    # 为每组创建启动脚本
    for ((group=1; group<=num_groups; group++)); do
        cat > "$script_dir/start_group${group}.sh" <<EOF
#!/bin/bash
set -e
docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f
EOF
    done

    # 添加节点到对应的启动脚本
    for i in "${!node_ids[@]}"; do
        local node_id=${node_ids[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local group_num=$(( i / nodes_per_round + 1 ))
        
        echo "echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 启动节点 $node_id ...\"" >> "$script_dir/start_group${group_num}.sh"
        echo "docker run -d --name \"$container_name\" --network host --restart unless-stopped --log-opt max-size=100m --log-opt max-file=3 -e NODE_ID=\"$node_id\" \"$IMAGE_NAME\"" >> "$script_dir/start_group${group_num}.sh"
        echo "sleep 30" >> "$script_dir/start_group${group_num}.sh"
    done

    # 创建轮换脚本
    cat > "$script_dir/rotate.sh" <<EOF
#!/bin/bash
set -e
while true; do
EOF
    for ((group=1; group<=num_groups; group++)); do
        cat >> "$script_dir/rotate.sh" <<EOF
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 启动第${group}组节点..."
    bash "$script_dir/start_group${group}.sh"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 等待2小时..."
    sleep 7200
EOF
    done
    echo "done" >> "$script_dir/rotate.sh"

    chmod +x "$script_dir"/*.sh
    pm2 start "$script_dir/rotate.sh" --name "nexus-rotate"
    pm2 save

    echo "节点轮换已启动！总共 $total_nodes 个节点，分为 $num_groups 组，每2小时轮换一次。"
    echo "使用 'pm2 logs nexus-rotate' 查看轮换日志。"
    read -p "按任意键返回菜单"
}

# (详细列表)显示所有运行中的节点
function list_nodes_detailed() {
    clear
    echo "==================================== 详细节点状态 ======================================"
    echo "------------------------------------------------------------------------------------------------------------"
    printf "%-6s %-30s %-12s %-20s %-25s %-20s\n" "序号" "节点ID (容器名)" "CPU %" "内存使用/限制" "状态" "创建时间"
    echo "------------------------------------------------------------------------------------------------------------"
    
    local all_nodes_names=($(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sort))
    if [ ${#all_nodes_names[@]} -eq 0 ]; then
        echo "未找到任何 Nexus 节点容器。"
    else
        local i=1
        for name in "${all_nodes_names[@]}"; do
            local container_info=$(docker ps -a --filter "name=^/${name}$" --format "{{.Status}}\t{{.CreatedAt}}")
            local status=$(echo -e "$container_info" | cut -f1)
            local created_at=$(echo -e "$container_info" | cut -f2)
            local stats
            if [[ $status == Up* ]]; then
                 stats=$(docker stats --no-stream --format "{{.CPUPerc}}\t{{.MemUsage}}" "$name")
                 printf "%-6s %-30s %-12s %-20s %-25s %-20s\n" "$i" "$name" "$(echo -e "$stats" | awk '{print $1}')" "$(echo -e "$stats" | awk '{print $2 " " $3 " " $4}')" "$status" "$created_at"
            else
                 printf "%-6s %-30s %-12s %-20s %-25s %-20s\n" "$i" "$name" "N/A" "N/A" "$status" "$created_at"
            fi
            ((i++))
        done
    fi
    echo "------------------------------------------------------------------------------------------------------------"
    read -p "按任意键返回菜单"
}

# 获取所有节点ID
function get_all_nodes() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort
}

# 查看节点日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    if docker ps -a --format '{{.Names}}' | grep -qw "^${container_name}$"; then
        echo "显示容器 $container_name 的日志，按 Ctrl+C 退出。"
        docker logs -f "$container_name"
    else
        echo "错误：找不到容器 $container_name。"
        read -p "按任意键返回菜单"
    fi
}

# 选择要查看的节点
function select_node_to_view() {
    local all_nodes=($(get_all_nodes))
    if [ ${#all_nodes[@]} -eq 0 ]; then echo "当前没有节点"; read -p "按任意键返回菜单"; return; fi

    echo "请选择要查看日志的节点："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        printf "%d. 节点 %s\n" "$((i+1))" "${all_nodes[$i]}"
    done

    read -rp "请输入选项(0-${#all_nodes[@]}): " choice
    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
        view_node_logs "${all_nodes[$((choice-1))]}"
    elif [ "$choice" != "0" ]; then
        echo "无效的选项"; read -p "按任意键继续"
    fi
}

# 批量停止并卸载节点
function batch_uninstall_nodes() {
    local all_nodes=($(get_all_nodes))
    if [ ${#all_nodes[@]} -eq 0 ]; then echo "当前没有节点"; read -p "按任意键返回菜单"; return; fi

    echo "请选择要删除的节点（可多选，用空格分隔，例如 '1 3 4'）："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        printf "%d. 节点 %s\n" "$((i+1))" "${all_nodes[$i]}"
    done

    read -rp "请输入选项: " choices
    if [ "$choices" = "0" ]; then return; fi

    for choice in $choices; do
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
            uninstall_node "${all_nodes[$((choice-1))]}"
        else
            echo "跳过无效选项: $choice"
        fi
    done
    echo "批量卸载完成！"; read -p "按任意键返回菜单"
}

# 删除全部节点
function uninstall_all_nodes() {
    local all_nodes=($(get_all_nodes))
    if [ ${#all_nodes[@]} -eq 0 ]; then echo "当前没有节点"; read -p "按任意键返回菜单"; return; fi

    read -rp "警告：此操作将删除所有 ${#all_nodes[@]} 个节点，确定吗？(y/N): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        for node_id in "${all_nodes[@]}"; do
            uninstall_node "$node_id"
        done
        if [ -d "/root/nexus_scripts" ]; then
            echo "删除 /root/nexus_scripts 目录..."
            rm -rf "/root/nexus_scripts"
        fi
        echo "所有节点已删除！"
    else
        echo "已取消操作。"
    fi
    read -p "按任意键返回菜单"
}

# 主菜单显示函数
function display_main_menu() {
    clear
    echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
    echo "经魔改适配CentOS 8，并优化单节点性能 (v1.4 - Final Fix)"
    echo
    echo "======================= 当前节点概览 ======================="
    
    local nodes_info=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}\t{{.Status}}" | sort)

    if [ -z "$nodes_info" ]; then
        echo "                      当前没有配置任何节点"
    else
        printf "  %-35s | %s\n" "容器名" "状态"
        echo "  ----------------------------------------------------------"
        while IFS=$'\t' read -r name status; do
            printf "  %-35s | %s\n" "$name" "$status"
        done <<< "$nodes_info"
    fi
    echo "============================================================"
    echo
    echo "=========================== 主菜单 ==========================="
    echo " 1. 安装并启动新节点"
    echo " 2. 显示所有节点详细状态 (含CPU/内存)"
    echo " 3. 批量停止并卸载指定节点"
    echo " 4. 查看指定节点日志"
    echo " 5. 批量节点轮换启动"
    echo " 6. 删除全部节点"
    echo " 7. 退出"
    echo "============================================================"
}

# 主循环
while true; do
    display_main_menu
    read -rp "请输入选项(1-7): " choice
    case $choice in
        1)
            check_docker
            read -rp "请输入您的 node-id: " NODE_ID
            if [ -z "$NODE_ID" ]; then
                echo "node-id 不能为空，请重新选择。"; read -p "按任意键继续"; continue
            fi
            build_image
            run_container "$NODE_ID"
            read -p "按任意键返回菜单"
            ;;
        2) list_nodes_detailed ;;
        3) batch_uninstall_nodes ;;
        4) select_node_to_view ;;
        5) check_docker; batch_rotate_nodes ;;
        6) uninstall_all_nodes ;;
        7) echo "退出脚本。"; exit 0 ;;
        *) echo "无效选项，请重新输入。"; read -p "按任意键继续" ;;
    esac
done
