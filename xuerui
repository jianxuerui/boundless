#!/bin/bash
set -e

BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs"

# 检查 Docker 是否安装
function check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "检测到未安装 Docker，正在安装..."
        apt update
        apt install -y apt-transport-https ca-certificates curl software-properties-common
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
        add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
        apt update
        apt install -y docker-ce
        systemctl enable docker
        systemctl start docker
    fi
}

# 检查 Node.js/npm/pm2 是否安装
function check_pm2() {
    if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
        echo "检测到未安装 Node.js/npm，正在安装..."
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
        apt-get install -y nodejs
    fi
    if ! command -v pm2 >/dev/null 2>&1; then
        echo "检测到未安装 pm2，正在安装..."
        npm install -g pm2
    fi
}

# 构建docker镜像函数
function build_image() {
    WORKDIR=$(mktemp -d)
    cd "$WORKDIR"

    cat > Dockerfile <<EOF
# 指定 ARM64 架构以匹配下载的 nexus-network-linux-arm64 二进制文件
FROM arm64v8/ubuntu:24.04

ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id

RUN apt-get update && apt-get install -y \
    curl \
    screen \
    bash \
    && rm -rf /var/lib/apt/lists/*

# 下载指定的 v0.9.6 版本 nexus-network (ARM64) 并赋予执行权限
RUN curl -L -o /usr/local/bin/nexus-network https://github.com/nexus-xyz/nexus-cli/releases/download/v0.9.6/nexus-network-linux-arm64 \
    && chmod +x /usr/local/bin/nexus-network

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
EOF

    cat > entrypoint.sh <<EOF
#!/bin/bash
set -e

PROVER_ID_FILE="/root/.nexus/node-id"

if [ -z "\$NODE_ID" ]; then
    echo "错误：未设置 NODE_ID 环境变量"
    exit 1
fi

# 确保目录存在
mkdir -p /root/.nexus

echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo "使用的 node-id: \$NODE_ID"

if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 未安装或不可用"
    exit 1
fi

screen -S nexus -X quit >/dev/null 2>&1 || true

echo "启动 nexus-network 节点..."
# 将日志同时输出到文件和标准输出，方便 docker logs 查看
screen -dmS nexus bash -c "nexus-network start --node-id \$NODE_ID | tee /root/nexus.log"

sleep 3

if screen -list | grep -q "nexus"; then
    echo "节点已在后台启动。"
    echo "容器内日志文件：/root/nexus.log"
    echo "可以使用 'docker logs -f \$HOSTNAME' 查看实时日志"
else
    echo "节点启动失败，请检查日志。"
    cat /root/nexus.log
    exit 1
fi

# 保持容器运行并持续输出日志
tail -f /root/nexus.log
EOF

    echo "正在构建 Docker 镜像 $IMAGE_NAME..."
    docker build -t "$IMAGE_NAME" .

    cd -
    rm -rf "$WORKDIR"
}

# 启动容器（挂载宿主机日志文件）
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "检测到旧容器 $container_name，先删除..."
        docker rm -f "$container_name"
    fi

    # 确保日志目录存在
    mkdir -p "$LOG_DIR"
    
    # 确保宿主机日志文件存在并有写权限
    touch "$log_file"
    chmod 644 "$log_file"

    echo "正在启动容器 $container_name..."
    docker run -d --name "$container_name" -v "$log_file":/root/nexus.log -e NODE_ID="$node_id" "$IMAGE_NAME"
    echo "容器 $container_name 已启动！"
    echo "宿主机日志文件位于: $log_file"
    echo "可以使用命令查看实时日志: tail -f $log_file"
    echo "或使用: docker logs -f $container_name"
}

# 停止并卸载容器和镜像、删除日志
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "停止并删除容器 $container_name..."
    docker rm -f "$container_name" 2>/dev/null || echo "容器 $container_name 不存在或已停止"

    if [ -f "$log_file" ]; then
        echo "删除日志文件 $log_file ..."
        rm -f "$log_file"
    else
        echo "日志文件不存在：$log_file"
    fi

    echo "节点 $node_id 已卸载完成。"
}

# 显示所有运行中的节点
function list_nodes() {
    echo "当前节点状态："
    echo "-------------------------------------------------------------------------------------------------"
    printf "%-4s %-25s %-12s %-20s %-20s %-15s\n" "ID" "容器名" "CPU %" "内存使用" "状态" "启动时间"
    echo "-------------------------------------------------------------------------------------------------"
    
    local all_nodes=($(get_all_node_ids))
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "未找到任何 Nexus 节点容器。"
    else
        docker stats --no-stream --format "table {{.ID}}\t{{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.PIDs}}" | tail -n +2 | while read -r line; do
            local name=$(echo "$line" | awk '{print $2}')
            if [[ "$name" == ${BASE_CONTAINER_NAME}-* ]]; then
                local cpu_perc=$(echo "$line" | awk '{print $3}')
                local mem_usage=$(echo "$line" | awk '{print $4 " " $5 " " $6}')
                local status_info=$(docker ps -a --filter "name=$name" --format "{{.Status}}")
                printf "%-4s %-25s %-12s %-20s %-20s\n" \
                    "$(echo "$name" | sed "s/${BASE_CONTAINER_NAME}-//")" \
                    "$name" \
                    "$cpu_perc" \
                    "$mem_usage" \
                    "$status_info"
            fi
        done

        # 检查已停止的容器
        docker ps -a --filter "status=exited" --filter "name=${BASE_CONTAINER_NAME}-*" --format "table {{.Names}}" | tail -n +2 | while read -r name; do
            if ! docker ps --filter "name=$name" --format '{{.Names}}' | grep -qw "$name"; then
                 local status_info=$(docker ps -a --filter "name=$name" --format "{{.Status}}")
                 printf "%-4s %-25s %-12s %-20s %-20s\n" \
                    "$(echo "$name" | sed "s/${BASE_CONTAINER_NAME}-//")" \
                    "$name" \
                    "N/A" \
                    "N/A" \
                    "$status_info"
            fi
        done
    fi
    echo "-------------------------------------------------------------------------------------------------"
    read -p "按任意键返回菜单..."
}


# 获取所有节点ID（包括已停止的）
function get_all_node_ids() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-*" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 查看节点日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"
    
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
         echo "错误：未找到节点 $node_id 的容器。"
         read -p "按任意键返回..."
         return
    fi
    
    echo "请选择日志来源："
    echo "1. Docker 容器日志 (docker logs，实时)"
    echo "2. 宿主机日志文件 (tail -f，需要文件挂载)"
    read -rp "请选择(1-2，默认为1): " log_source

    echo "正在打开日志... 按 Ctrl+C 退出。"
    sleep 1

    if [ "$log_source" = "2" ] && [ -f "$log_file" ]; then
        tail -f "$log_file"
    else
        docker logs -f "$container_name"
    fi
}

# 批量启动多个节点
function batch_start_nodes() {
    echo "请输入多个 node-id，每行一个。输入空行或按 Ctrl+D 结束："
    
    local node_ids=()
    while read -r line; do
        # 移除前后空格
        line=$(echo "$line" | xargs)
        if [ -n "$line" ]; then
            node_ids+=("$line")
        else
            break
        fi
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 node-id，返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    echo "将要启动 ${#node_ids[@]} 个节点..."
    echo "开始构建镜像 (如果需要)..."
    build_image

    echo "开始批量启动节点..."
    for node_id in "${node_ids[@]}"; do
        run_container "$node_id"
        sleep 2  # 添加短暂延迟，避免Docker API过载
    done

    echo "所有节点启动任务已提交！"
    read -p "按任意键返回菜单..."
}

# 选择要操作的节点（通用）
function select_node_for_action() {
    local action_callback=$1
    local prompt_message=$2
    
    local all_nodes=($(get_all_node_ids))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有可操作的节点。"
        read -p "按任意键返回菜单..."
        return
    fi

    echo "请选择要操作的节点："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}")
        printf "%2d. 节点 %-20s [%s]\n" $((i+1)) "$node_id" "$status"
    done

    read -rp "请输入选项 (0-${#all_nodes[@]}): " choice

    if [[ ! "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt ${#all_nodes[@]} ]; then
        echo "无效的选项。"
        read -p "按任意键继续..."
        return
    fi

    if [ "$choice" -eq 0 ]; then
        return
    fi
    
    local selected_node_id=${all_nodes[$((choice-1))]}
    # 调用传入的回调函数，并传递所选的节点ID
    "$action_callback" "$selected_node_id"
}


# 批量停止并卸载节点
function batch_uninstall_nodes() {
    local all_nodes=($(get_all_node_ids))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有节点可供卸载。"
        read -p "按任意键返回菜单..."
        return
    fi

    echo "当前节点列表："
    echo "----------------------------------------"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}")
        printf "%2d. %-20s [%s]\n" $((i+1)) "$node_id" "$status"
    done
    echo "----------------------------------------"

    echo "请输入要删除的节点序号（可多选，用空格分隔，输入 'all' 删除全部）："
    read -rp "请输入选项: " choices_str

    if [ -z "$choices_str" ]; then
        echo "未做任何选择，操作取消。"
        read -p "按任意键继续..."
        return
    fi

    local nodes_to_uninstall=()
    if [[ "$choices_str" =~ ^[aA][lL]{2}$ ]]; then
        read -rp "警告：确定要删除全部 ${#all_nodes[@]} 个节点吗？(y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            nodes_to_uninstall=("${all_nodes[@]}")
        fi
    else
        read -ra selected_indices <<< "$choices_str"
        for index in "${selected_indices[@]}"; do
            if [[ "$index" =~ ^[0-9]+$ ]] && [ "$index" -ge 1 ] && [ "$index" -le ${#all_nodes[@]} ]; then
                nodes_to_uninstall+=("${all_nodes[$((index-1))]}")
            else
                echo "警告：无效的序号 '$index'，已忽略。"
            fi
        done
    fi

    if [ ${#nodes_to_uninstall[@]} -gt 0 ]; then
        echo "将要卸载以下 ${#nodes_to_uninstall[@]} 个节点:"
        printf " - %s\n" "${nodes_to_uninstall[@]}"
        read -rp "确认执行卸载吗？(y/N): " confirm_uninstall
        if [[ "$confirm_uninstall" =~ ^[Yy]$ ]]; then
            for node_id in "${nodes_to_uninstall[@]}"; do
                uninstall_node "$node_id"
            done
            echo "批量卸载完成！"
        else
            echo "操作已取消。"
        fi
    else
        echo "没有选中任何有效的节点进行卸载。"
    fi

    read -p "按任意键返回菜单..."
}


# 删除全部节点和镜像
function uninstall_all_nodes_and_image() {
    local all_nodes=($(get_all_node_ids))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有节点，无需删除。"
    else
        read -rp "警告：此操作将删除所有 ${#all_nodes[@]} 个节点容器和它们的日志！确定吗？(y/N): " confirm
        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            echo "开始删除所有节点..."
            for node_id in "${all_nodes[@]}"; do
                uninstall_node "$node_id"
            done
            echo "所有节点容器已删除。"
        else
            echo "已取消删除节点操作。"
            read -p "按任意键返回菜单..."
            return
        fi
    fi

    # 检查并删除镜像
    if docker image inspect "$IMAGE_NAME" &> /dev/null; then
        read -rp "是否也删除 Docker 镜像 '$IMAGE_NAME'？(y/N): " confirm_image
        if [[ "$confirm_image" =~ ^[Yy]$ ]]; then
            echo "正在删除镜像 $IMAGE_NAME..."
            docker rmi -f "$IMAGE_NAME"
            echo "镜像已删除。"
        fi
    fi

    echo "清理完成！"
    read -p "按任意键返回菜单..."
}


# 批量节点轮换启动
function batch_rotate_nodes() {
    check_docker
    check_pm2

    echo "请输入所有参与轮换的 node-id，每行一个。输入空行或按 Ctrl+D 结束："
    local node_ids=()
    while read -r line; do
        line=$(echo "$line" | xargs)
        if [ -n "$line" ]; then
            node_ids+=("$line")
        else
            break
        fi
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 node-id，返回主菜单"
        read -p "按任意键继续..."
        return
    fi
    local total_nodes=${#node_ids[@]}

    read -rp "请输入每次轮换启动的节点数量 (默认: 1): " nodes_per_batch
    nodes_per_batch=${nodes_per_batch:-1}

    read -rp "请输入轮换间隔时间（分钟，默认: 120，即2小时）: " interval_minutes
    interval_minutes=${interval_minutes:-120}

    # 创建或清空轮换脚本
    local rotate_script="/root/nexus_rotate_starter.sh"
    echo "#!/bin/bash" > "$rotate_script"
    echo "set -e" >> "$rotate_script"
    echo "NODE_IDS=(${node_ids[*]})" >> "$rotate_script"
    echo "TOTAL_NODES=\${#NODE_IDS[@]}" >> "$rotate_script"
    echo "NODES_PER_BATCH=$nodes_per_batch" >> "$rotate_script"
    echo "CURRENT_INDEX_FILE=\"/root/nexus_rotate_index.txt\"" >> "$rotate_script"
    cat >> "$rotate_script" <<'EOF'
# 读取上一次的索引，如果文件不存在则从0开始
if [ -f "$CURRENT_INDEX_FILE" ]; then
    current_index=$(cat "$CURRENT_INDEX_FILE")
else
    current_index=0
fi

echo "日志时间: $(date)"
echo "当前轮换索引: $current_index"

# 停止并删除所有现有的 nexus 容器
echo "正在清理旧容器..."
docker ps -a --filter "name=nexus-node-*" --format "{{.Names}}" | xargs -r docker rm -f

# 计算本次要启动的节点范围
start_index=$current_index
end_index=$(( (start_index + NODES_PER_BATCH) % TOTAL_NODES ))

# 选取节点并启动
echo "正在启动批次节点..."
for i in $(seq $start_index $((start_index + NODES_PER_BATCH - 1)) ); do
    node_index=$(( i % TOTAL_NODES ))
    node_id=${NODE_IDS[$node_index]}
    
    if [ -n "$node_id" ]; then
        container_name="nexus-node-${node_id}"
        log_file="/root/nexus_logs/nexus-${node_id}.log"
        echo "启动节点: $node_id"
        mkdir -p /root/nexus_logs
        touch "$log_file"
        docker run -d --name "$container_name" -v "$log_file":/root/nexus.log -e NODE_ID="$node_id" nexus-node:latest
        sleep 5
    fi
done

# 计算并保存下一次的起始索引
next_index=$(( (current_index + NODES_PER_BATCH) % TOTAL_NODES ))
echo "$next_index" > "$CURRENT_INDEX_FILE"
echo "下一次轮换索引: $next_index"
echo "轮换任务完成。"
EOF
    chmod +x "$rotate_script"

    echo "正在构建 Docker 镜像..."
    build_image

    echo "正在设置定时任务 (Cron Job) 来执行轮换..."
    local cron_job="*/$interval_minutes * * * * $rotate_script >> /root/nexus_rotate.log 2>&1"
    (crontab -l 2>/dev/null | grep -v -F "$rotate_script"; echo "$cron_job") | crontab -
    
    echo "轮换任务已通过 Cron 设置成功！"
    echo " - 节点总数: $total_nodes"
    echo " - 每次启动: $nodes_per_batch 个"
    echo " - 间隔时间: $interval_minutes 分钟"
    echo " - 轮换脚本: $rotate_script"
    echo " - 轮换日志: /root/nexus_rotate.log"
    echo "您可以使用 'crontab -l' 查看定时任务，'crontab -e' 进行编辑。"
    
    read -p "是否立即执行一次轮换？(y/N): " run_now
    if [[ "$run_now" =~ ^[Yy]$ ]]; then
        echo "正在手动触发第一次轮换..."
        bash "$rotate_script"
        echo "第一次轮换已执行完毕。"
    fi

    read -p "按任意键返回菜单..."
}

# 设置定时清理日志任务（每2天清理一次，只保留最近2天的日志）
function setup_log_cleanup_cron() {
    local cron_job="0 3 */2 * * find $LOG_DIR -type f -name 'nexus-*.log' -mtime +2 -delete"
    if ! (crontab -l 2>/dev/null | grep -qF "$cron_job"); then
        (crontab -l 2>/dev/null; echo "$cron_job") | crontab -
        echo "已设置日志清理定时任务：每2天清理一次旧日志。"
    fi
}

# 主菜单
setup_log_cleanup_cron
while true; do
    clear
    echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
    echo "================ Nexus 多节点管理 (ARM64) ================"
    echo "1. 安装/启动单个节点"
    echo "2. 批量安装/启动多个节点"
    echo "3. 显示所有节点状态"
    echo "4. 批量停止并卸载节点"
    echo "5. 查看指定节点日志"
    echo "6. 设置批量节点定时轮换启动 (Cron)"
    echo "7. 删除全部节点和镜像"
    echo "8. 退出"
    echo "=========================================================="

    read -rp "请输入选项(1-8): " choice

    case $choice in
        1)
            check_docker
            read -rp "请输入您的 node-id: " NODE_ID
            if [ -z "$NODE_ID" ]; then
                echo "node-id 不能为空，请重新选择。"
                read -p "按任意键继续"
                continue
            fi
            echo "开始构建镜像并启动容器..."
            build_image
            run_container "$NODE_ID"
            read -p "按任意键返回菜单"
            ;;
        2)
            check_docker
            batch_start_nodes
            ;;
        3)
            list_nodes
            ;;
        4)
            batch_uninstall_nodes
            ;;
        5)
            select_node_for_action "view_node_logs" "查看日志"
            ;;
        6)
            batch_rotate_nodes
            ;;
        7)
            uninstall_all_nodes_and_image
            ;;
        8)
            echo "退出脚本。"
            exit 0
            ;;
        *)
            echo "无效选项，请重新输入。"
            read -p "按任意键继续"
            ;;
    esac
done
