#!/bin/bash
# Nexus 多节点管理脚本
# 作者：哈哈哈哈 (Twitter: @ferdie_jhovie)
# 这是一个免费开源的脚本，请勿相信任何收费宣传。

# 启用严格模式，遇到错误立即退出，对未设置的变量报错，管道中任何命令失败都算作失败
set -euo pipefail

# === 全局变量定义 ===
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs"
SCRIPT_TMP_DIR="/tmp/nexus_script_build" # 用于 Dockerfile 和 entrypoint 文件的临时目录

# === Dockerfile 内容定义 ===
DOCKERFILE_CONTENT=$(cat <<'EOF'
FROM ubuntu:24.04

ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id

# 安装必要工具，确保screen, curl, bash, procps 可用
RUN apt-get update -qq && apt-get install -y --no-install-recommends \
    curl \
    screen \
    bash \
    procps \
    locales \
    && rm -rf /var/lib/apt/lists/* \
    # 生成和设置UTF-8语言环境以避免某些容器运行时警告
    && locale-gen en_US.UTF-8 \
    && update-locale LANG=en_US.UTF-8 \
    && echo "LANG=\"en_US.UTF-8\"" > /etc/default/locale

ENV LANG en_US.UTF-8
ENV LANGUAGE en_US:en
ENV LC_ALL en_US.UTF-8

# 自动下载安装最新版 nexus-network
RUN curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh \
    && ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
EOF
)

# === entrypoint.sh 内容定义 ===
ENTRYPOINT_CONTENT=$(cat <<'EOF'
#!/bin/bash
set -eo pipefail

PROVER_ID_FILE="/root/.nexus/node-id"

if [ -z "${NODE_ID}" ]; then
    echo "错误：未设置 NODE_ID 环境变量"
    exit 1
fi

echo "${NODE_ID}" > "${PROVER_ID_FILE}"
echo "使用的 node-id: ${NODE_ID}"

if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 未安装或不可用"
    exit 1
fi

# 检查并清理旧的 screen 会话 (如果在容器内部意外存在)
screen -S nexus -X quit >/dev/null 2>&1 || true

echo "启动 nexus-network 节点..."
# 以前在 screen 中运行 nexus-network，并重定向到 /root/nexus.log。
# 现在直接在后台启动，然后用 tail -f 保持容器主进程存活并收集日志，这更符合Docker的日志机制。
# 如果 nexus-network 停止，tail 会停止，容器会退出。
nexus-network start --node-id "${NODE_ID}" &>> /root/nexus.log &
NEXUS_PID=$!
echo "Nexus Network 进程已在后台启动，PID: $NEXUS_PID"

# 简短的延迟，让 nexus 进程有机会启动并写入一些日志
sleep 5

# 检查 nexus 进程是否存活。使用 wait $NEXUS_PID 非阻塞等待一下，确保它不是秒退
if wait $NEXUS_PID || true; then # '|| true' prevents wait from exiting if PID not found immediately
    if ! ps -p "$NEXUS_PID" > /dev/null; then
        echo "节点启动失败，进程未保持运行。请检查 /root/nexus.log"
        tail -n 50 /root/nexus.log || true # Print last 50 lines if it exists
        exit 1
    fi
fi

echo "节点已在后台启动。日志文件：/root/nexus.log"
echo "可以使用 docker logs \$CONTAINER_NAME 或 tail -f /root/nexus.log 查看日志"

# 保持容器运行，并通过tail -f显示日志
echo "==== 实时日志 (Press Ctrl+C to exit) ===="
# Use 'exec tail -f' to replace current shell with tail, ensuring correct PID 1 behavior
exec tail -f /root/nexus.log
EOF
)


# === 辅助函数 ===

# 显示一条彩色消息
function echo_color() {
    local color="$1"
    local message="$2"
    case "$color" in
        "red")    echo -e "\033[31m${message}\033[0m" ;;
        "green")  echo -e "\033[32m${message}\033[0m" ;;
        "yellow") echo -e "\033[33m${message}\033[0m" ;;
        "blue")   echo -e "\033[34m${message}\033[0m" ;;
        *)        echo "${message}" ;; # default
    esac
}

# 提示用户按任意键继续
function press_any_key() {
    echo "" # Add a newline for better readability
    read -rp "$(echo_color blue "按任意键返回菜单...")"
}

# 从用户那里获取多个 node-id
function get_node_ids_from_user() {
    local __result_arr_name=$1
    local ids_array=()
    echo ""
    echo_color blue "---------------------------------------------------------"
    echo_color blue "请输入多个 node-id，每行一个，输入空行后按 Ctrl+D 结束输入："
    echo_color blue "(Node ID 是唯一的，类似于您的账户标识。请妥善保管和使用。)"
    echo_color blue "---------------------------------------------------------"
    
    local line_count=0
    while IFS= read -r line; do
        if [ -z "$line" ]; then
            continue # Allow empty lines during input, but don't store them
        fi
        # Strip leading/trailing whitespace
        line=$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        if [ -n "$line" ]; then # Ensure line is not empty after stripping whitespace
            ids_array+=("$line")
            line_count=$((line_count+1))
            echo "已输入: $line (共 $line_count 个)"
        fi
    done

    if [ ${#ids_array[@]} -eq 0 ]; then
        echo_color yellow "未输入任何有效的 node-id。"
        # Do not return immediately here; let the caller handle the empty array
    fi
    # 使用 nameref 或 global assignment 传回数组
    # For Bash 3.x compatibility, use indirect expansion if `declare -n` (nameref) is not available.
    # Given typical server environments, `declare -n` is generally available.
    # eval "${__result_arr_name}=($(printf "'%s' " "${ids_array[@]}"))" # This makes it hard to manage if values contain spaces.
    
    # Best way for compatibility and robustness for an array of simple strings:
    # Set it in the parent scope. This often requires the caller to `read -ra` the output
    # OR for the array to be global.
    # For simplicity, for unique_node_ids_arr and all_input_node_ids, we'll assign directly.
    # The mapfile will handle it correctly when assigned from printf output.

    # Simpler: assign directly as string for easy parsing by mapfile, which filters.
    # Or for actual array assignment back, directly modifying the name reference for safety
    declare -ga "$__result_arr_name" # Make sure array is declared globally and assigned.
    eval "$__result_arr_name=(\"${ids_array[@]}\")" # Assign the array values
}

# --- OS Detection ---
OS_FAMILY="unknown"
function detect_os_family() {
    if grep -qE "ID=(debian|ubuntu)" /etc/os-release 2>/dev/null; then
        echo "debian"
    elif grep -qE "ID=(centos|rhel|fedora)" /etc/os-release 2>/dev/null; then
        echo "redhat"
    else
        echo "unknown"
    fi
}
OS_FAMILY=$(detect_os_family)

# === Docker Installation Functions by OS ===

function install_docker_debian() {
    echo_color yellow "正在安装 Docker (Debian/Ubuntu)..."
    apt update -qq
    apt install -y ca-certificates curl gnupg lsb-release
    
    # Add Docker GPG key (new way)
    rm -f /etc/apt/keyrings/docker.gpg
    mkdir -m 0755 -p /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    chmod a+r /etc/apt/keyrings/docker.gpg # Ensure readable
    
    # Add Docker repository (new way)
    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    apt update -qq
    apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

    systemctl enable docker || true
    systemctl start docker || true
}

function install_docker_redhat() {
    echo_color yellow "正在安装 Docker (CentOS/RHEL/Fedora)..."
    yum_or_dnf="yum"
    if command -v dnf >/dev/null 2>&1; then
        yum_or_dnf="dnf"
    fi

    # Remove old Docker versions
    $yum_or_dnf remove -y docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine >/dev/null 2>&1 || true

    # Install yum-utils and add Docker repo
    $yum_or_dnf install -y yum-utils device-mapper-persistent-data lvm2
    $yum_or_dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

    # Install Docker Engine
    $yum_or_dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

    systemctl enable docker || true
    systemctl start docker || true
}

# === Node.js/PM2 Installation Functions by OS ===

function install_nodejs_npm_debian() {
    echo_color yellow "正在安装 Node.js 18.x (Debian/Ubuntu)..."
    curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
    apt-get install -y nodejs
}

function install_nodejs_npm_redhat() {
    echo_color yellow "正在安装 Node.js 18.x (CentOS/RHEL/Fedora)..."
    yum_or_dnf="yum"
    if command -v dnf >/dev/null 2>&1; then
        yum_or_dnf="dnf"
    fi

    # Install NodeSource Node.js 18.x RPM
    curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -
    $yum_or_dnf install -y nodejs
}

# === Main Checks ===

# 检查 Docker 是否安装
function check_docker() {
    echo_color blue "=== 检查 Docker 安装状态 ==="
    if ! command -v docker >/dev/null 2>&1; then
        case "$OS_FAMILY" in
            "debian") install_docker_debian ;;
            "redhat") install_docker_redhat ;;
            *) 
                echo_color red "无法自动安装 Docker。当前操作系统 ('$OS_FAMILY') 不支持自动安装。请手动安装 Docker。"
                exit 1
                ;;
        esac

        if ! command -v docker >/dev/null 2>&1; then
            echo_color red "Docker 安装失败，请检查日志并手动安装。"
            exit 1
        else
            echo_color green "Docker 安装成功并已启动。"
        fi
    else
        echo_color green "Docker 已安装。"
    fi
    docker info >/dev/null 2>&1 || { echo_color red "Docker 服务未运行或当前用户无权限。请尝试 'sudo systemctl start docker' 或将用户加入 'docker' 组并重新登录。"; exit 1; }
    echo ""
}

# 检查 Node.js/npm/pm2 是否安装
function check_pm2() {
    echo_color blue "=== 检查 Node.js/npm/pm2 安装状态 ==="
    if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
        case "$OS_FAMILY" in
            "debian") install_nodejs_npm_debian ;;
            "redhat") install_nodejs_npm_redhat ;;
            *) 
                echo_color red "无法自动安装 Node.js/npm。当前操作系统 ('$OS_FAMILY') 不支持自动安装。请手动安装 Node.js。"
                exit 1
                ;;
        esac

        if ! command -v node >/dev/null 2>&1; then
            echo_color red "Node.js 安装失败，请检查日志。"
            exit 1
        else
            echo_color green "Node.js/npm 安装成功。"
        fi
    else
        echo_color green "Node.js/npm 已安装。"
    fi

    if ! command -v pm2 >/dev/null 2>&1; then
        echo_color yellow "检测到未安装 pm2，正在安装..."
        npm install -g pm2
        if ! command -v pm2 >/dev/null 2>&1; then
            echo_color red "pm2 安装失败，请检查日志。"
            exit 1
        fi
        echo_color green "pm2 安装成功。"
        pm2 save >/dev/null 2>&1 || true # Save process list for future restarts
    else
        echo_color green "pm2 已安装。"
    fi
    echo ""
}

# 构建docker镜像函数
function build_image() {
    echo_color blue "=== 构建 Docker 镜像 ==-"
    # 使用一个确定性的临时目录，并设置trap确保清理
    mkdir -p "$SCRIPT_TMP_DIR"
    # 在脚本退出时自动清理临时目录
    trap "rm -rf '$SCRIPT_TMP_DIR'" EXIT

    echo "${DOCKERFILE_CONTENT}" > "${SCRIPT_TMP_DIR}/Dockerfile"
    echo "${ENTRYPOINT_CONTENT}" > "${SCRIPT_TMP_DIR}/entrypoint.sh"

    # 添加 --progress=plain 选项，显示详细构建日志
    if docker build -t "$IMAGE_NAME" --progress=plain "$SCRIPT_TMP_DIR"; then
        echo_color green "Docker 镜像 '$IMAGE_NAME' 构建成功。"
    else
        echo_color red "Docker 镜像构建失败，请检查上述错误信息。"
        exit 1
    fi
    echo ""
}

# 启动容器（挂载宿主机日志文件）
function run_container() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo_color blue "--- 正在准备启动容器 '$container_name' ---"
    
    # 停止并删除可能存在的旧容器
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo_color yellow "检测到旧容器 '$container_name'，先停止并删除..."
        docker rm -f "$container_name" >/dev/null
    fi

    # 确保日志目录存在
    mkdir -p "$LOG_DIR"
    
    # 确保宿主机日志文件存在并有写权限
    # 检查 $log_file 是否是目录，如果是，先删除
    if [ -d "$log_file" ]; then
        echo_color yellow "警告：日志文件路径 '$log_file' 冲突，检测到同名目录。正在删除该目录..."
        rm -rf "$log_file"
    fi
    if [ ! -f "$log_file" ]; then
        touch "$log_file"
        chmod 644 "$log_file"
    fi

    echo "正在启动容器 '$container_name'..."
    if docker run -d --name "$container_name" -v "$log_file":/root/nexus.log -e NODE_ID="$node_id" "$IMAGE_NAME"; then
        echo_color green "容器 '$container_name' 已启动！"
        echo_color green "查看日志请执行：'docker logs -f $container_name'"
    else
        echo_color red "容器 '$container_name' 启动失败。请检查 Docker 日志或运行 'docker logs $container_name' 查看详情。"
    fi
}

# 停止并卸载容器和镜像、删除日志
function uninstall_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "停止并删除容器 '$container_name'..."
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        docker rm -f "$container_name" >/dev/null || echo_color yellow "警告：无法删除容器 '$container_name'。"
        echo_color green "容器 '$container_name' 已删除。"
    else
        echo_color yellow "容器 '$container_name' 不存在，跳过删除。"
    fi

    if [ -f "$log_file" ]; then
        echo "删除日志文件 '$log_file'..."
        rm -f "$log_file"
    else
        echo_color yellow "日志文件不存在：'$log_file'，跳过删除。"
    fi

    echo_color green "节点 '$node_id' 已卸载完成。"
}

# 显示所有运行中的节点
function list_nodes() {
    echo_color blue "=== 当前 Nexus 节点状态 ==="
    
    local all_nodes_array=($(get_all_nodes)) # Use subshell to convert output to array
    local all_nodes_count=${#all_nodes_array[@]}

    if [ "$all_nodes_count" -eq 0 ]; then
        echo_color yellow "当前未发现任何 Nexus 节点容器。"
        press_any_key
        return
    fi

    echo_color blue "------------------------------------------------------------------------------------------------------------------------"
    printf "%-6s %-20s %-15s %-12s %-12s %-10s %-25s\n" "序号" "节点ID" "状态" "CPU使用率" "内存使用" "内存限制" "创建时间"
    echo_color blue "------------------------------------------------------------------------------------------------------------------------"
    
    local found_any_node=false

    for i in "${!all_nodes_array[@]}"; do
        local node_id=${all_nodes_array[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        
        local container_status=""
        local container_created=""
        local stats_output=""
        local cpu_usage="N/A"
        local mem_usage="N/A"
        local mem_limit="N/A"

        # Check if container exists first
        if docker ps -a --filter "name=$container_name" --format '{{.ID}}' | grep -q .; then
            found_any_node=true
            container_status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}" 2>/dev/null | head -n 1)
            container_created=$(docker ps -a --filter "name=$container_name" --format "{{.CreatedAt}}" 2>/dev/null | head -n 1)

            # Try to get docker stats only if the container is running
            if [[ "$container_status" == Up* ]]; then
                stats_output=$(docker stats --no-stream --format "{{.CPUPerc}}::{{.MemUsage}}" "$container_name" 2>/dev/null)
                if [ -n "$stats_output" ]; then
                    IFS='::' read -r cpu_percent mem_full <<< "$stats_output"
                    cpu_usage="$cpu_percent"
                    
                    # Split memory usage string (e.g., "1.23MiB / 2GiB")
                    # Assuming format "XXXUnit / YYYUnit"
                    local parts=($mem_full)
                    mem_usage="${parts[0]} ${parts[1]}" # e.g. "1.23 MiB"
                    mem_limit="${parts[3]} ${parts[4]}" # e.g. "2 GiB" (if parts[2] is '/')
                fi
            fi

            # Color the status output
            local display_status_colored=""
            local display_status=$(echo "$container_status" | cut -d' ' -f1) # Get first word like "Up" or "Exited"
            if [[ "$display_status" == "Up" ]]; then
                display_status_colored=$(echo_color green "${container_status}")
            elif [[ "$display_status" == "Exited" ]]; then
                display_status_colored=$(echo_color red "${container_status}")
            else
                display_status_colored=$(echo_color yellow "${container_status}")
            fi
            
            # Print row. `sed` removes ANSI codes for string length calculation for alignment.
            printf "%-6d %-20s %-25s %-12s %-12s %-10s %-25s\n" \
                $((i+1)) \
                "$node_id" \
                "$(echo "$display_status_colored" | sed 's/\x1b\[[0-9;]*m//g' )" "$cpu_usage" "$mem_usage" "$mem_limit" "$container_created"
        fi
    done
    
    if [ "$found_any_node" == "false" ]; then
        echo_color yellow "没有找到任何符合命名规则的 Nexus 节点容器。"
    fi
    echo_color blue "------------------------------------------------------------------------------------------------------------------------"
    echo "提示："
    echo "- CPU使用率：显示容器CPU使用百分比"
    echo "- 内存使用：显示容器当前使用的内存"
    echo "- 内存限制：显示容器内存使用限制 (仅在Docker分配了特定限制时显示)"
    echo "- 状态：显示容器的运行状态 ('Up' 表示运行中, 'Exited' 表示已停止/退出)"
    echo "- 创建时间：显示容器的创建时间"
    press_any_key
}

# 获取所有节点ID（包括已停止的）
function get_all_nodes() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort -u
}

# 查看节点日志
function view_node_logs() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    echo_color blue "=== 查看节点 ${node_id} 日志 ==="
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo_color red "容器 '$container_name' 不存在。请确认节点ID正确或容器已启动。"
        press_any_key
        return
    fi

    # Check if container is actually running for -f option
    local is_running=false
    if docker ps --filter "name=$container_name" --filter "status=running" --format '{{.ID}}' | grep -q .; then
        is_running=true
    fi

    if [ "$is_running" == true ]; then
        echo "请选择日志查看模式："
        echo "1. 原始日志（可能包含颜色代码）"
        echo "2. 清理后的日志（移除颜色代码）"
        read -rp "$(echo_color blue "请选择(1-2): ")" log_mode

        echo_color yellow "正在加载日志，按 Ctrl+C 退出实时日志查看。"
        echo "---------------------------------------------------"
        if [ "$log_mode" = "2" ]; then
            # Clean up common ANSI escape codes, including cursor positioning
            docker logs -f "$container_name" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g" | sed 's/\x1b\[?25l//g; s/\x1b\[?25h//g'
        else
            docker logs -f "$container_name"
        fi
        echo "---------------------------------------------------"
    else
        echo_color yellow "容器 '$container_name' 未运行或已停止，将尝试显示历史日志。"
        echo "---------------------------------------------------"
        local log_file_on_host="${LOG_DIR}/nexus-${node_id}.log"
        if [ -f "$log_file_on_host" ]; then
            echo_color blue "显示宿主机日志文件: $log_file_on_host"
            tail -n 50 "$log_file_on_host" || echo_color red "无法读取日志文件或文件为空: $log_file_on_host"
        else
            echo_color red "宿主机上找不到日志文件: $log_file_on_host"
            echo "尝试从容器内部获取历史日志（如果容器日志驱动器保留了）。"
            docker logs "$container_name" || echo_color red "无法从停止的容器中获取日志。"
        fi
        echo "---------------------------------------------------"
    fi
    press_any_key
}

# 选择要查看的节点
function select_node_to_view() {
    local all_nodes_array=($(get_all_nodes))
    
    if [ ${#all_nodes_array[@]} -eq 0 ]; then
        echo_color yellow "当前没有可供操作的节点。"
        press_any_key
        return
    fi

    echo_color blue "=== 选择要查看日志的节点 ==="
    echo "0. 返回主菜单"
    for i in "${!all_nodes_array[@]}"; do
        local node_id=${all_nodes_array[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status_str="[未知状态]"
        if docker ps --filter "name=$container_name" --filter "status=running" --format '{{.ID}}' | grep -q .; then
            status_str=$(echo_color green "[运行中]")
        elif docker ps -a --filter "name=$container_name" --format '{{.Status}}' | grep -q 'Exited'; then
            status_str=$(echo_color red "[已停止]")
        else
            status_str=$(echo_color yellow "[不存在/其他]")
        fi
        printf "%-6d. %-20s %s\n" $((i+1)) "$node_id" "$(echo "$status_str" | sed 's/\x1b\[[0-9;]*m//g')"
    done

    local choice
    read -rp "$(echo_color blue "请输入选项(0-${#all_nodes_array[@]}): ")" choice

    if [ "$choice" = "0" ]; then
        return
    fi

    # Basic numeric validation
    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes_array[@]} ]; then
        local selected_node=${all_nodes_array[$((choice-1))]}
        view_node_logs "$selected_node"
    else
        echo_color red "无效的选项：'$choice'。请输入列表中对应的数字。"
        press_any_key
    fi
}

# 批量启动多个节点
function batch_start_nodes() {
    echo_color blue "=== 批量启动多个 Nexus 节点 ==="
    local node_ids_array=()
    get_node_ids_from_user node_ids_array # 收集 node-id 到 node_ids_array 变量

    if [ ${#node_ids_array[@]} -eq 0 ]; then
        echo_color yellow "未输入任何 node-id，已取消批量启动操作。"
        press_any_key
        return
    fi

    echo_color blue "开始构建镜像 (如果需要或尚未构建)..."
    build_image

    echo_color blue "开始启动节点..."
    local start_count=0
    for node_id in "${node_ids_array[@]}"; do
        run_container "$node_id"
        start_count=$((start_count+1))
        # 进度提示
        echo_color blue "已启动 ${start_count}/${#node_ids_array[@]} 个节点..."
        sleep 1 # 添加短暂延迟，避免同时启动太多容器对系统造成冲击
    done

    echo_color green "所有指定节点启动完成！"
    echo_color blue "使用 '2. 显示所有节点状态' 查看节点信息。"
    press_any_key
}

# 批量停止并卸载节点
function batch_uninstall_nodes() {
    local all_nodes_array=($(get_all_nodes))
    
    if [ ${#all_nodes_array[@]} -eq 0 ]; then
        echo_color yellow "当前没有可供卸载的节点。"
        press_any_key
        return
    fi

    echo_color blue "=== 批量卸载指定 Nexus 节点 ==="
    echo "当前节点列表："
    echo_color blue "----------------------------------------"
    printf "%-6s %-20s %-15s\n" "序号" "节点ID" "状态"
    echo_color blue "----------------------------------------"
    for i in "${!all_nodes_array[@]}"; do
        local node_id=${all_nodes_array[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status_str="[未知状态]"
        if docker ps --filter "name=$container_name" --filter "status=running" --format '{{.ID}}' | grep -q .; then
            status_str=$(echo_color green "[运行中]")
        elif docker ps -a --filter "name=$container_name" --format '{{.Status}}' | grep -q 'Exited'; then
            status_str=$(echo_color red "[已停止]")
        else
            status_str=$(echo_color yellow "[不存在/其他]")
        fi
        printf "%-6d %-20s %s\n" $((i+1)) "$node_id" "$(echo "$status_str" | sed 's/\x1b\[[0-9;]*m//g')"
    done
    echo_color blue "----------------------------------------"

    echo "请选择要卸载的节点（可多选，输入数字，用空格分隔）："
    echo_color red "警告：此操作将永久删除节点数据（日志文件）和Docker容器，无法恢复！"
    echo "0. 返回主菜单"
    
    local choices_input
    read -rp "$(echo_color blue "请输入选项(0 或 数字，用空格分隔): ")" choices_input

    if [ "$choices_input" = "0" ]; then
        echo_color yellow "已取消批量卸载操作。"
        press_any_key
        return
    fi

    # 将输入的选项转换为数组
    local selected_indices=()
    read -ra selected_indices <<< "$choices_input" # Reads into an array, splitting by whitespace

    # 过滤掉重复和无效的选项
    local unique_selected_indices=()
    for index in "${selected_indices[@]}"; do
        if [[ "$index" =~ ^[0-9]+$ ]] && [ "$index" -ge 1 ] && [ "$index" -le ${#all_nodes_array[@]} ]; then
            # Add to unique list only if not already present
            local found=false
            for u_index in "${unique_selected_indices[@]}"; do
                if [ "$u_index" == "$index" ]; then
                    found=true
                    break
                fi
            done
            if [ "$found" == false ]; then
                unique_selected_indices+=("$index")
            fi
        else
            echo_color yellow "跳过无效或重复的选项: '$index'"
        fi
    done

    if [ ${#unique_selected_indices[@]} -eq 0 ]; then
        echo_color yellow "未选择任何有效节点，已取消批量卸载操作。"
        press_any_key
        return
    fi

    echo ""
    echo_color yellow "您确定要卸载以下 ${#unique_selected_indices[@]} 个节点吗？"
    for choice_idx in "${unique_selected_indices[@]}"; do
        local selected_node=${all_nodes_array[$((choice_idx-1))]}
        echo_color yellow "- ${selected_node}"
    done
    read -rp "$(echo_color red "输入 'yes' 确认卸载，否则将取消: ")" confirm
    if [[ ! "$confirm" == "yes" ]]; then
        echo_color yellow "已取消批量卸载操作。"
        press_any_key
        return
    fi

    echo_color blue "开始卸载选定节点..."
    for choice_idx in "${unique_selected_indices[@]}"; do
        local selected_node=${all_nodes_array[$((choice_idx-1))]}
        uninstall_node "$selected_node"
        sleep 0.5 # Give a small breather between deletions
    done

    echo_color green "批量卸载完成！"
    press_any_key
}

# 删除全部节点
function uninstall_all_nodes() {
    local all_nodes_array=($(get_all_nodes))
    
    if [ ${#all_nodes_array[@]} -eq 0 ]; then
        echo_color yellow "当前没有可供删除的节点。"
        press_any_key
        return
    fi

    echo_color red "!!! 严重警告：此操作将删除所有 Nexus 节点相关数据和 Docker 容器 !!!"
    echo_color red "!!! 确定删除后将无法恢复，请谨慎操作！！！"
    echo "当前共有 ${#all_nodes_array[@]} 个节点将被删除："
    for node_id in "${all_nodes_array[@]}"; do
        echo_color yellow "- $node_id"
    done
    
    read -rp "$(echo_color red "确定要删除所有节点吗？(输入 'yes' 确认): ")" confirm
    if [[ ! "$confirm" == "yes" ]]; then
        echo_color yellow "已取消操作。"
        press_any_key
        return
    fi

    echo_color blue "开始删除所有节点..."
    # Stop and remove all managed Docker containers
    local containers_to_delete=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format '{{.Names}}')
    if [ -n "$containers_to_delete" ]; then
        echo "$containers_to_delete" | while read -r container_name; do
            echo "正在停止并删除容器 '$container_name'..."
            docker rm -f "$container_name" || echo_color yellow "警告：无法删除容器 '$container_name'。"
        done
    else
        echo_color yellow "没有找到任何 Nexus 容器可供删除。"
    fi
    
    # Remove all managed log files
    if [ -d "$LOG_DIR" ]; then
        echo "删除日志目录 '$LOG_DIR' 下的所有Nexus日志文件..."
        find "$LOG_DIR" -type f -name "nexus-*.log" -delete || echo_color yellow "警告：无法删除部分日志文件。"
    fi

    # Optionally remove the Docker image itself
    if docker images -q "$IMAGE_NAME" | grep -q .; then
        read -rp "$(echo_color yellow "是否同时删除 Nexus Docker 镜像 '$IMAGE_NAME'？(y/N): ")" delete_image_confirm
        if [[ "$delete_image_confirm" =~ ^[Yy]$ ]]; then
            echo "正在删除 Docker 镜像 '$IMAGE_NAME'..."
            docker rmi "$IMAGE_NAME" || echo_color yellow "警告：无法删除 Docker 镜像 '$IMAGE_NAME' (可能被其他容器使用)。"
        fi
    fi

    # Optionally clean up the scripts directory if rotation was used
    local script_dir="/root/nexus_scripts"
    if [ -d "$script_dir" ]; then
        read -rp "$(echo_color yellow "是否删除节点轮换脚本目录 '$script_dir' 和 pm2 进程？(y/N): ")" clean_script_confirm
        if [[ "$clean_script_confirm" =~ ^[Yy]$ ]]; then
            echo "停止并删除 pm2 进程 'nexus-rotate'..."
            pm2 delete nexus-rotate >/dev/null 2>&1 || true
            pm2 save >/dev/null 2>&1 || true
            echo "删除脚本目录 '$script_dir'..."
            rm -rf "$script_dir"
        fi
    fi

    echo_color green "所有 Nexus 节点已删除完成！"
    press_any_key
}

# 批量节点轮换启动的核心脚本
function batch_rotate_nodes() {
    echo_color blue "=== 批量节点轮换启动 ==="
    check_pm2 # pm2 是运行轮换任务所必需的

    local all_input_node_ids=()
    get_node_ids_from_user all_input_node_ids # 收集 node-id 到 all_input_node_ids 变量

    if [ ${#all_input_node_ids[@]} -eq 0 ]; then
        echo_color yellow "未输入任何 node-id，已取消批量轮换操作。"
        press_any_key
        return
    fi

    # 过滤掉重复的 node-id，确保每个ID只使用一次
    local unique_node_ids_arr=()
    # Use printf for reliable newline separation and then sort -u
    mapfile -t unique_node_ids_arr < <(printf "%s\n" "${all_input_node_ids[@]}" | sort -u)

    local total_nodes=${#unique_node_ids_arr[@]}

    echo ""
    echo_color yellow "检测到 $total_nodes 个唯一 Node ID，它们将被用于轮换。"
    read -rp "$(echo_color blue "请输入每轮要运行的节点数量（默认：${total_nodes}的一半，向上取整；最少1个）: ")" nodes_per_round_input
    
    local nodes_per_round
    if [ -z "$nodes_per_round_input" ]; then
        nodes_per_round=$(( (total_nodes + 1) / 2 )) # Default to half, rounded up
    elif [[ "$nodes_per_round_input" =~ ^[0-9]+$ ]] && [ "$nodes_per_round_input" -ge 1 ] && [ "$nodes_per_round_input" -le "$total_nodes" ]; then
        nodes_per_round="$nodes_per_round_input"
    else
        echo_color red "无效的节点数量。请输入1到$total_nodes之间的整数。"
        press_any_key
        return
    fi

    read -rp "$(echo_color blue "请输入每轮轮换间隔时间（小时，默认：2小时；最少1小时）: ")" rotate_interval_hours_input
    local rotate_interval_hours
    if [ -z "$rotate_interval_hours_input" ]; then
        rotate_interval_hours=2 # Default to 2 hours
    elif [[ "$rotate_interval_hours_input" =~ ^[0-9]+$ ]] && [ "$rotate_interval_hours_input" -ge 1 ]; then
        rotate_interval_hours="$rotate_interval_hours_input"
    else
        echo_color red "无效的轮换间隔时间。请输入大于等于1的整数小时数。"
        press_any_key
        return
    fi
    local rotate_interval_seconds=$(( rotate_interval_hours * 3600 ))

    echo ""
    echo_color yellow "--- 轮换设置摘要 ---"
    echo "总共节点数：$total_nodes"
    echo "每轮运行节点数：$nodes_per_round"
    echo "每轮轮换间隔：${rotate_interval_hours} 小时"
    echo_color yellow "--------------------"

    read -rp "$(echo_color red "确定要开始节点轮换吗？此操作将停止所有现有Nexus容器。(输入 'yes' 确认): ")" confirm
    if [[ ! "$confirm" == "yes" ]]; then
        echo_color yellow "已取消轮换操作。"
        press_any_key
        return
    fi

    echo_color blue "开始构建镜像 (如果需要或尚未构建)..."
    build_image

    # 清理旧的 pm2 进程
    echo_color yellow "停止并删除旧的轮换进程 'nexus-rotate' (如果存在)..."
    pm2 delete nexus-rotate 2>/dev/null || true

    # 创建启动脚本目录
    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir"
    chmod 700 "$script_dir" # Secure permissions

    # 生成轮换主脚本 `rotate.sh`
    # 此脚本将由 pm2 运行
    cat > "$script_dir/rotate.sh" <<EOF
#!/bin/bash
set -euo pipefail

BASE_CONTAINER_NAME="${BASE_CONTAINER_NAME}"
IMAGE_NAME="${IMAGE_NAME}"
LOG_DIR="${LOG_DIR}"
# Pass the unique_node_ids_arr as a string, then re-create array in subshell
# This is more robust against special characters in IDs or older Bash versions for mapfile
NODE_IDS_LIST="$(printf "%s " "${unique_node_ids_arr[@]}")"
NODES_PER_ROUND=${nodes_per_round}
ROTATE_INTERVAL_SECONDS=${rotate_interval_seconds}

# Read NODE_IDS_LIST back into a proper bash array for use within this script
read -ra TOTAL_NODE_IDS <<< "\$NODE_IDS_LIST"
TOTAL_NODES_COUNT=\${#TOTAL_NODE_IDS[@]}

CURRENT_NODE_INDEX=0 # Global index to track starting node for current round

function log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] \$1"
}

function run_single_container() {
    local node_id="\$1"
    local container_name="\${BASE_CONTAINER_NAME}-\${node_id}"
    local log_file="\${LOG_DIR}/nexus-\${node_id}.log"

    mkdir -p "\${LOG_DIR}"
    if [ -d "\$log_file" ]; then rm -rf "\$log_file"; fi
    if [ ! -f "\$log_file" ]; then touch "\$log_file"; chmod 644 "\$log_file"; fi

    # Stop and remove if container already exists (even from previous failures)
    docker rm -f "\$container_name" >/dev/null 2>&1 || true

    log_message "    启动节点: \$node_id (容器: \$container_name)"
    docker run -d --name "\$container_name" -v "\$log_file":/root/nexus.log -e NODE_ID="\$node_id" "\$IMAGE_NAME" &> /dev/null
    
    # Small delay for container to start its process
    sleep 3
    
    if docker ps -a --format '{{.Names}}' | grep -qw "\$container_name"; then
        if docker inspect --format='{{.State.Running}}' "\$container_name" 2>/dev/null | grep -q "true"; then
            log_message "      节点 \$node_id 启动成功。"
        else
            log_message "      节点 \$node_id 启动，但未运行起来。检查 docker logs \$container_name。"
        fi
    else
        log_message "      节点 \$node_id 容器未成功创建！"
    fi
}

function stop_all_managed_containers() {
    log_message "停止并清理所有 Nexus 节点容器..."
    local containers_to_stop
    # Filter by name prefix to avoid deleting other containers
    containers_to_stop=\$(docker ps -a --filter "name=\${BASE_CONTAINER_NAME}-" --format '{{.Names}}')
    if [ -n "\$containers_to_stop" ]; then
        # xargs -r for empty input protection on some systems
        echo "\$containers_to_stop" | xargs -r docker rm -f || true
        log_message "  所有旧容器已清理。"
    else
        log_message "  没有找到运行中的Nexus节点容器。"
    fi
}

while true; do
    log_message "=========================================================="
    log_message "新的轮换周期开始..."
    log_message "=========================================================="

    # 1. 停止并清理所有现有 managed 容器
    stop_all_managed_containers

    # 2. 确定本轮要激活的节点
    local current_round_nodes=()
    local i
    for (( i=0; i<NODES_PER_ROUND; i++ )); do
        # Use modular arithmetic to loop through node IDs
        local node_idx=\$((\$((\${CURRENT_NODE_INDEX} + i)) % \${TOTAL_NODES_COUNT}))
        current_round_nodes+=("\${TOTAL_NODE_IDS[\${node_idx}]}")
    done
    
    log_message "本轮将启动以下 \${#current_round_nodes[@]} 个节点: \${current_round_nodes[*]}"

    # 3. 启动本轮节点
    for node_id in "\${current_round_nodes[@]}"; do
        run_single_container "\$node_id"
    done

    log_message "本轮节点启动完毕。"
    log_message "更新下次启动索引: 从节点 ${current_round_nodes[0]} 开始 (实际索引 \$CURRENT_NODE_INDEX)"
    CURRENT_NODE_INDEX=\$(( (\${CURRENT_NODE_INDEX} + \${NODES_PER_ROUND}) % \${TOTAL_NODES_COUNT} ))
    
    log_message "----------------------------------------------------------"
    log_message "等待 \$((ROTATE_INTERVAL_SECONDS / 3600)) 小时进入下一轮轮换..."
    log_message "----------------------------------------------------------"
    sleep "\$ROTATE_INTERVAL_SECONDS"
done
EOF
)
    # 设置轮换脚本权限
    chmod +x "$script_dir/rotate.sh"

    # 使用 pm2 启动轮换脚本
    # 增加 --output 和 --error 选项以捕获 pm2 自身输出和错误日志
    pm2 start "$script_dir/rotate.sh" --name "nexus-rotate" --output "$script_dir/rotate_output.log" --error "$script_dir/rotate_error.log"
    pm2 save

    echo_color green "节点轮换已启动并由 PM2 管理！"
    echo_color blue "总共 $total_nodes 个唯一节点，每轮启动 $nodes_per_round 个节点。"
    echo_color blue "每 ${rotate_interval_hours} 小时轮换一次，确保节点持续在线且循环运行。"
    echo_color blue "使用 'pm2 status' 查看 PM2 进程状态。"
    echo_color blue "使用 'pm2 logs nexus-rotate' 查看轮换进程的实时日志。"
    echo_color blue "使用 'pm2 stop nexus-rotate' 停止轮换， 'pm2 delete nexus-rotate' 删除轮换进程。"
    echo_color blue "注意：如果您想暂停，请使用 'pm2 stop nexus-rotate'；想要彻底移除，使用 'pm2 delete nexus-rotate' 后，请手动执行 6.删除全部节点 或 3.批量停止并卸载指定节点 再次清理已启动的容器。"

    press_any_key
}


# 设置定时清理日志任务（每2天清理一次，只保留最近2天的日志）
function setup_log_cleanup_cron() {
    echo_color blue "=== 设置日志清理定时任务 ==="
    # 清理日志，只保留最近2天的日志文件。确保 LOG_DIR 存在且是非空的，避免 `find` 错误
    # Using realpath to resolve symbolic links and ensure absolute path, important for cron
    local real_log_dir=$(realpath "$LOG_DIR" 2>/dev/null || echo "$LOG_DIR")
    
    local cron_job_comment="# Nexus node log cleanup: Keep logs for 2 days. Created by nexus-node-manager.sh"
    local cron_job_cmd="0 3 * * * find \"$real_log_dir\" -maxdepth 1 -type f -name 'nexus-*.log' -mtime +2 -delete"

    # Combine comment and command
    local full_cron_entry="${cron_job_comment}\n${cron_job_cmd}"

    # Check if a similar task already exists using grep -q for a unique part of the command
    if crontab -l 2>/dev/null | grep -qF "find \"$real_log_dir\" -maxdepth 1 -type f -name 'nexus-*.log' -mtime +2 -delete"; then
        echo_color green "日志清理定时任务已存在，无需重复设置。"
    else
        # Append or create定时任务
        # Remove existing older cleanup lines if they only contain comment/command and no other variations
        (crontab -l 2>/dev/null | grep -vF "nexus-node-manager.sh" | grep -vF "find \"/root/nexus_logs\" -maxdepth 1 -type f -name 'nexus-*.log' -mtime +2 -delete" ; echo -e "$full_cron_entry") | crontab -
        echo_color green "已设置每2天自动清理过期 Nexus 日志的任务（保留最近2天）。"
    fi
    echo ""
}

# 主菜单
function main_menu() {
    # Execute trap cleanup if any issue before main loop.
    trap "rm -rf '$SCRIPT_TMP_DIR'; echo_color red '脚本非正常退出，临时文件已清理。'" EXIT
    
    setup_log_cleanup_cron # 每次启动脚本都确保定时任务已设置

    while true; do
        clear
        echo_color green "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
        echo_color green "如有问题，可联系推特，仅此只有一个号"
        echo ""
        echo_color blue "========== Nexus 多节点管理 =========="
        echo_color blue "当前检测到操作系统家族: $(echo_color yellow "$OS_FAMILY")"
        echo_color blue "------------------------------------"
        echo_color blue "1. 安装并启动新节点 (单个)"
        echo_color blue "2. 显示所有节点状态"
        echo_color blue "3. 批量停止并卸载指定节点"
        echo_color blue "4. 查看指定节点日志"
        echo_color blue "5. 批量节点轮换启动 (通过PM2实现循环启动新节点，旧节点被替换)"
        echo_color blue "6. 删除全部节点 (危险操作，慎用！)"
        echo_color blue "7. 退出"
        echo_color blue "==================================="

        read -rp "$(echo_color blue "请输入选项(1-7): ")" choice

        case "$choice" in # Quote choice to prevent globbing
            1)
                check_docker
                read -rp "$(echo_color blue "请输入您的 node-id: ")" NODE_ID
                if [ -z "$NODE_ID" ]; then
                    echo_color red "node-id 不能为空，请重新输入。"
                    press_any_key
                    continue
                fi
                build_image
                run_container "$NODE_ID"
                echo_color green "单个节点 '$NODE_ID' 启动成功！请等待其数据同步。"
                press_any_key
                ;;
            2)
                list_nodes
                ;;
            3)
                batch_uninstall_nodes
                ;;
            4)
                select_node_to_view
                ;;
            5)
                check_docker
                batch_rotate_nodes
                ;;
            6)
                uninstall_all_nodes
                ;;
            7)
                echo_color blue "感谢使用，退出脚本。"
                exit 0
                ;;
            *)
                echo_color red "无效选项 '$choice'，请重新输入。"
                press_any_key
                ;;
        esac
    done
}

# === 脚本主入口 ===
main_menu
