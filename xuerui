#!/bin/bash
# 开启调试模式：-e (出错时退出), -x (打印执行的命令)
set -ex

# ==============================================================================
# Nexus 多节点管理脚本 (ARM64专用Docker版) - 终极安全与调试版 v3.5
#
# 【V3.5 更新】:
#   - 开启了 set -ex 调试模式，以便在出错时能看到是哪条命令失败了。
#   - 增加了对 Docker 服务本身是否正常运行的强制检查。
#   - 【关键重写】彻底重构了 list_nodes 函数，使用最安全的方式获取和处理
#     容器列表，以防止因环境差异导致的意外退出。
# ==============================================================================

# --- 配置项 ---
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest-arm64"
LOG_DIR="/root/nexus_logs"
BUILDER_NAME="nexus_builder"

# --- 核心功能函数 ---

function check_docker_daemon() {
    echo "--- 检查 Docker 服务状态 ---"
    if ! docker info >/dev/null 2>&1; then
        echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        echo "!! 致命错误: Docker 服务未运行或当前用户无权访问。"
        echo "!! 请尝试执行以下命令来启动 Docker:"
        echo "!!   sudo systemctl start docker"
        echo "!!   sudo systemctl enable docker"
        echo "!! 如果问题依旧，请检查 Docker 安装是否正确。"
        echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        exit 1
    fi
    echo "--- Docker 服务状态正常 ---"
}

# (其他函数保持不变，为简洁起见此处折叠，但在下面的完整脚本中会提供)
function check_docker() { if ! command -v docker >/dev/null 2>&1; then echo "检测到未安装 Docker，正在为您安装..."; apt-get update; apt-get install -y apt-transport-https ca-certificates curl software-properties-common; curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -; add-apt-repository "deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"; apt-get update; apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin; systemctl enable docker; systemctl start docker; echo "Docker 安装完成！"; fi; if ! docker buildx version >/dev/null 2>&1; then echo "错误：未找到 Docker buildx 插件。"; exit 1; fi; }
function setup_buildx() { if docker buildx ls | grep -q "^${BUILDER_NAME}.*running"; then echo "Buildx 环境 '$BUILDER_NAME' 已准备就绪."; docker buildx use $BUILDER_NAME; return; fi; echo "检测到需要设置跨平台构建环境..."; if docker buildx ls | grep -q "$BUILDER_NAME"; then echo "正在启动已存在的 builder..."; docker buildx inspect $BUILDER_NAME --bootstrap; else echo "正在创建新的 buildx builder..."; docker buildx create --name $BUILDER_NAME --driver docker-container --use; fi; if ! docker run --rm --privileged tonistiigi/binfmt | grep -q "setting up"; then echo "正在注册 QEMU 模拟器..."; docker run --rm --privileged tonistiigi/binfmt --install all; fi; echo "Buildx 环境设置完成。"; }
function build_image() { if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then echo "镜像 $IMAGE_NAME 已存在，跳过构建."; return; fi; setup_buildx; WORKDIR=$(mktemp -d); cd "$WORKDIR"; cat > Dockerfile <<EOF; ARG TARGETPLATFORM=linux/arm64\nFROM --platform=\$TARGETPLATFORM ubuntu:24.04\nENV DEBIAN_FRONTEND=noninteractive\nRUN apt-get update && apt-get install -y curl screen bash && rm -rf /var/lib/apt/lists/*\nRUN echo "正在下载..." && curl -L -o /usr/local/bin/nexus-network https://github.com/nexus-xyz/nexus-cli/releases/download/v0.10.1/nexus-network-linux-arm64 && chmod +x /usr/local/bin/nexus-network\nCOPY entrypoint.sh /entrypoint.sh\nRUN chmod +x /entrypoint.sh\nENTRYPOINT ["/entrypoint.sh"]\nEOF; cat > entrypoint.sh <<'EOF'; #!/bin/bash\nset -e\nif [ -z "$NODE_ID" ]; then exit 1; fi\nmkdir -p /root/.nexus; echo "$NODE_ID" > /root/.nexus/node-id\nif ! command -v nexus-network >/dev/null 2>&1; then exit 1; fi\nscreen -S nexus -X quit >/dev/null 2>&1 || true\nscreen -dmS nexus bash -c "nexus-network start --node-id $NODE_ID | tee /root/nexus.log"\nsleep 3; if ! screen -list | grep -q "nexus"; then cat /root/nexus.log; exit 1; fi\ntail -f /root/nexus.log\nEOF; docker buildx build --builder "$BUILDER_NAME" --platform linux/arm64 -t "$IMAGE_NAME" . --load; cd - >/dev/null; rm -rf "$WORKDIR"; echo "镜像构建完成！"; }
function run_container() { local node_id="$1"; if [ -z "$node_id" ]; then echo "错误"; return 1; fi; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; local log_file="${LOG_DIR}/nexus-${node_id}.log"; if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then docker rm -f "$container_name"; fi; mkdir -p "$LOG_DIR"; touch "$log_file"; chmod 644 "$log_file"; docker run -d --name "$container_name" -v "$log_file:/root/nexus.log" -e NODE_ID="$node_id" --restart unless-stopped "$IMAGE_NAME"; echo "容器 $container_name 已启动！"; }
function uninstall_node() { local node_id="$1"; if [ -z "$node_id" ]; then return 1; fi; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; local log_file="${LOG_DIR}/nexus-${node_id}.log"; docker rm -f "$container_name" >/dev/null 2>&1; if [ -f "$log_file" ]; then rm -f "$log_file"; fi; echo "节点 $node_id 已卸载。"; }
function get_all_node_ids() { docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort -u; }
function view_node_logs() { local node_id="$1"; if [ -z "$node_id" ]; then return 1; fi; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then return 1; fi; docker logs -f "$container_name"; }
function batch_start_nodes() { build_image; echo "请输入多个 Node ID，每行一个。"; local node_ids=(); while IFS= read -r line; do line=$(echo "$line" | xargs); [ -z "$line" ] && break; node_ids+=("$line"); done; if [ ${#node_ids[@]} -eq 0 ]; then return; fi; for node_id in "${node_ids[@]}"; do run_container "$node_id"; sleep 1; done; }
function select_node_for_action() { local action_callback="$1"; local prompt_message="$2"; local all_nodes=($(get_all_node_ids)); if [ ${#all_nodes[@]} -eq 0 ]; then echo "无节点."; read -p "按任意键返回..."; return; fi; echo "请选择一个要'${prompt_message}'的节点："; echo "0. 返回"; for i in "${!all_nodes[@]}"; do local node_id="${all_nodes[$i]}"; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; local status; status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}"); printf "%2d. 节点 %-25s [%s]\n" "$((i+1))" "$node_id" "$status"; done; read -rp "请输入选项(0-${#all_nodes[@]}): " choice; if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt ${#all_nodes[@]} ]; then return; fi; [ "$choice" -eq 0 ] && return; local selected_node_id="${all_nodes[$((choice-1))]}"; "$action_callback" "$selected_node_id"; }
function batch_uninstall_nodes() { read -rp "确定要卸载所有节点? (y/N): " confirm; if [[ ! "$confirm" =~ ^[yY] ]]; then return; fi; local all_nodes=($(get_all_node_ids)); if [ ${#all_nodes[@]} -eq 0 ]; then return; fi; for node_id in "${all_nodes[@]}"; do uninstall_node "$node_id"; done; }
function uninstall_all_nodes_and_image() { read -rp "警告: 将删除所有节点和镜像！输入 'yes' 确认: " confirm; if [ "$confirm" != "yes" ]; then return; fi; batch_uninstall_nodes; if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then docker rmi -f "$IMAGE_NAME"; fi; read -rp "是否删除日志目录 '$LOG_DIR'? (y/N): " del_log; if [[ "$del_log" =~ ^[yY] ]]; then rm -rf "$LOG_DIR"; fi; }

# --- 【关键重写】最安全版本的 list_nodes 函数 ---
function list_nodes() {
    echo "--------------------------------- 当前 Nexus 节点状态 ---------------------------------"
    printf "%-30s %-12s %-15s %-20s\n" "节点 ID (容器名)" "状态" "CPU %" "内存使用"
    echo "-------------------------------------------------------------------------------------"
    
    # 步骤1：安全地获取所有相关容器的列表。如果此命令失败，`set -e` 会让脚本退出
    # 这样我们就能在调试输出中看到 docker ps 命令本身是否出错。
    all_containers_list=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}")

    # 步骤2：检查列表是否为空。
    if [ -z "$all_containers_list" ]; then
        echo "未找到任何 Nexus 节点容器。"
        echo "-------------------------------------------------------------------------------------"
        return
    fi
    
    # 步骤3：安全地获取正在运行的容器的统计信息。
    running_containers_list=$(docker ps --filter "name=${BASE_CONTAINER_NAME}-" --filter "status=running" --format "{{.Names}}")
    stats_output=""
    if [ -n "$running_containers_list" ]; then
        # 将列表传递给 docker stats。如果此命令失败，`set -e`会处理。
        # 使用 tr 将换行符转换为空格，使其成为标准的命令行参数。
        stats_output=$(docker stats --no-stream $(echo "$running_containers_list" | tr '\n' ' ') --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}")
    fi

    # 步骤4：使用最安全的 `while read` 循环处理每个容器名。
    echo "$all_containers_list" | while IFS= read -r name || [ -n "$name" ]; do
        # 忽略可能的空行
        [ -z "$name" ] && continue
        
        local node_id
        node_id=$(echo "$name" | sed "s/${BASE_CONTAINER_NAME}-//")
        
        # 尝试在统计信息中查找
        local stats_line
        stats_line=$(echo "$stats_output" | grep -w "$name")

        if [ -n "$stats_line" ]; then
            local cpu_perc mem_usage
            cpu_perc=$(echo "$stats_line" | awk '{print $2}')
            mem_usage=$(echo "$stats_line" | awk -F '\t' '{print $3}')
            printf "%-30s %-12s %-15s %-20s\n" "$node_id ($name)" "Running" "$cpu_perc" "$mem_usage"
        else
            # 如果没找到，说明已停止，单独获取状态
            local status
            status=$(docker ps -a --filter "name=$name" --format "{{.Status}}")
            printf "%-30s %-12s %-15s %-20s\n" "$node_id ($name)" "$status" "N/A" "N/A"
        fi
    done
    echo "-------------------------------------------------------------------------------------"
}


# --- 主菜单循环 ---
function main_menu() {
    # 移到循环外，只检查一次
    check_docker
    check_docker_daemon

    while true; do
        clear
        echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
        echo "================ Nexus 管理 (ARM64 Docker版) v3.5 DEBUG ================"
        echo "1. 安装/启动单个节点        5. 批量卸载所有节点"
        echo "2. 批量安装/启动多个节点    6. 完全卸载 (删除所有节点和镜像)"
        echo "3. 查看指定节点日志         7. 退出脚本"
        echo "4. 卸载指定节点"
        # 每次循环时都调用重写过的安全版 list_nodes
        list_nodes
        
        read -rp "请输入选项(1-7): " choice
        case $choice in
            1) read -rp "请输入您的 Node ID: " NODE_ID; if [ -z "$NODE_ID" ]; then echo "Node ID 不能为空！"; else build_image; run_container "$NODE_ID"; fi; read -p "按任意键返回...";;
            2) batch_start_nodes; read -p "按任意键返回...";;
            3) select_node_for_action "view_node_logs" "查看日志";;
            4) select_node_for_action "uninstall_node" "卸载"; read -p "按任意键返回...";;
            5) batch_uninstall_nodes; read -p "按任意键返回...";;
            6) uninstall_all_nodes_and_image; read -p "按任意键返回...";;
            7.
            7) echo "退出脚本。"; exit 0;;
            *) echo "无效选项。"; sleep 1;;
        esac
    done
}

# --- 脚本执行入口 ---
if [ "$(id -u)" -ne 0 ]; then
   echo "错误：此脚本需要 root 权限运行。请使用 'sudo' 执行。" >&2
   exit 1
fi
main_menu
