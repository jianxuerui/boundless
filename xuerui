#!/bin/bash
set -e

# ================================================================================================
# Nexus 多节点管理脚本 (ARM64 Docker) - v5.6 权威网络配置版
#
# 改版者: AI & 社区智慧
#
# 【V5.6 - 权威网络配置版 更新】:
#   - 【权威网络修复】: 彻底放弃对 '/etc/resolv.conf' 文件的临时修改。新脚本使用 'nmcli' 工具
#     直接、永久地修改 NetworkManager 的配置，从根本上解决了DNS被系统服务覆盖的问题。
#   - 【备份与恢复】: 在修改网络配置前，会自动备份用户原始DNS设置。新增“恢复网络配置”菜单项，
#     允许用户随时一键恢复到修改前的状态，确保操作安全可逆。
#   - 【健壮性提升】: 这是解决在由NetworkManager管理的现代Linux发行版上进行自动化部署时
#     遇到的DNS顽固问题的最终、最可靠的方案。
#
# ================================================================================================

# --- 配置项 ---
SCRIPT_VERSION="v5.6 权威网络配置版"
NEXUS_CLI_VERSION="v0.10.7"
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest-arm64"
LOG_DIR="/root/nexus_logs"
BUILDER_NAME="nexus_builder"
DNS_BACKUP_FILE="/root/.nexus_dns_backup"

# --- 颜色定义 ---
COLOR_RESET='\033[0m'; COLOR_RED='\033[0;31m'; COLOR_GREEN='\033[0;32m'; COLOR_YELLOW='\033[0;33m';
COLOR_BLUE='\033[0;34m'; COLOR_CYAN='\033[0;36m'; COLOR_BOLD='\033[1m'

# --- 全局变量和退出陷阱 ---
TMP_WORKDIR=""; 
cleanup() {
    EXITCODE=$?
    printf "\n"; print_info "正在执行清理程序..."
    [ -n "$TMP_WORKDIR" ] && [ -d "$TMP_WORKDIR" ] && rm -rf "$TMP_WORKDIR"
    exit $EXITCODE
}
trap cleanup EXIT HUP INT QUIT TERM

# --- 辅助函数 ---
print_color() { echo -e "${2}${1}${COLOR_RESET}"; }; print_success() { print_color "$1" "$COLOR_GREEN"; }
print_error() { print_color "$1" "$COLOR_RED"; }; print_warning() { print_color "$1" "$COLOR_YELLOW"; }
print_info() { print_color "$1" "$COLOR_CYAN"; }; print_bold() { print_color "$1" "${COLOR_BOLD}${COLOR_CYAN}"; }
safe_sleep() { read -t "$1" < /dev/null 2>/dev/null || true; }
confirm_action() { read -rp "${COLOR_YELLOW}>>> ${1} (y/N): ${COLOR_RESET}" c; [[ "$c" =~ ^[yY]([eE][sS])?$ ]]; }


# ---【V5.6 权威网络与环境准备函数】---
prepare_system_and_network() {
    print_bold "第一阶段: 系统和网络环境权威配置"

    # 1. 检测网络，并在必要时执行永久性修复
    if ! ping -c 1 -W 3 google.com &>/dev/null; then
        print_warning "DNS解析失败。正在检查直接IP连通性..."
        if ! ping -c 1 -W 3 8.8.8.8 &>/dev/null; then print_error "!! 致命网络错误: 无法 PING 通外部IP (8.8.8.8)。请检查网关或防火墙设置。"; exit 1; fi
        
        print_warning "确认为DNS问题。将尝试通过 NetworkManager (nmcli) 进行永久性修复..."
        
        if ! command -v nmcli &>/dev/null; then
            print_warning "未找到 'nmcli' 命令。正在尝试安装 'NetworkManager'..."
            if command -v yum &>/dev/null; then yum install -y NetworkManager >/dev/null;
            elif command -v apt-get &>/dev/null; then apt-get update -qq >/dev/null; apt-get install -y network-manager >/dev/null;
            else print_error "!! 无法安装 NetworkManager。无法自动修复网络。"; exit 1; fi
            if ! command -v nmcli &>/dev/null; then print_error "!! 安装 'NetworkManager' 후 'nmcli' 命令仍然不存在。"; exit 1; fi
        fi
        
        # 获取活跃的网络连接
        local active_con=$(nmcli -t -f NAME,DEVICE,STATE c show --active | grep ':\(connected\|connected (site-only)\)' | head -n 1 | cut -d: -f1)
        if [ -z "$active_con" ]; then print_error "!! 未找到活跃的网络连接。无法配置DNS。"; exit 1; fi
        print_info "找到活跃网络连接: '${active_con}'"
        
        # 备份当前DNS
        print_info "正在备份当前DNS设置到 ${DNS_BACKUP_FILE}..."
        nmcli -g ipv4.dns,ipv4.ignore-auto-dns con show "${active_con}" > "${DNS_BACKUP_FILE}"
        
        print_info "正在配置新的公共DNS (8.8.8.8, 1.1.1.1) 并禁用自动DNS..."
        nmcli con mod "${active_con}" ipv4.dns "8.8.8.8 1.1.1.1"
        nmcli con mod "${active_con}" ipv4.ignore-auto-dns yes
        
        print_info "正在重新加载网络连接以应用更改..."
        nmcli con down "${active_con}" &>/dev/null || true # Ignore errors if it's already down
        sleep 2
        nmcli con up "${active_con}"
        
        print_info "等待网络稳定..."
        sleep 5

        if ! ping -c 1 -W 3 google.com &>/dev/null; then print_error "!! 使用nmcli修复后DNS仍然解析失败！请检查防火墙是否阻止了UDP 53端口。"; exit 1; fi
        print_success "网络DNS配置已成功修复并永久生效！"
    else
        print_success "网络与DNS检测正常。"
    fi
    
    # 2. 检查并安装核心工具
    print_info "正在检查并安装缺失的核心工具..."
    local packages_to_install=()
    if command -v apt-get &>/dev/null; then
        ! command -v gpg &>/dev/null && packages_to_install+=("gnupg")
        ! command -v lsb_release &>/dev/null && packages_to_install+=("lsb-release")
    elif command -v yum &>/dev/null || command -v dnf &>/dev/null; then
        ! command -v yum-config-manager &>/dev/null && packages_to_install+=("yum-utils")
    fi
    
    if [ ${#packages_to_install[@]} -gt 0 ]; then
        local unique_packages=$(echo "${packages_to_install[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' ')
        print_warning "即将自动安装以下缺失的工具包: ${unique_packages}"
        if command -v apt-get &>/dev/null; then apt-get update -qq >/dev/null; apt-get install -y ${unique_packages} >/dev/null;
        else $(command -v dnf || command -v yum) install -y ${unique_packages} >/dev/null; fi
        print_success "核心工具安装完成。"
    else
        print_success "所有核心工具均已存在。"
    fi
}

# 其他函数 (ensure_docker_ready, setup_buildx 等) 保持与v5.5版本一致
ensure_docker_ready() {
    print_bold "第二阶段: Docker环境部署"
    if docker info >/dev/null 2>&1; then print_success "Docker已安装并正在运行。"; return 0; fi

    if ! command -v docker &> /dev/null; then
        print_warning "Docker未安装，正在尝试自动安装..."; if [ -f /etc/os-release ]; then . /etc/os-release; OS_ID=$ID; else print_error "!! 无法检测操作系统类型。"; exit 1; fi
        case "$OS_ID" in
            ubuntu|debian)
                print_info "正在为 Debian/Ubuntu 系统安装 Docker..."
                apt-get update -qq >/dev/null
                apt-get install -y --no-install-recommends ca-certificates curl gnupg lsb-release >/dev/null
                mkdir -p /etc/apt/keyrings; curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
                apt-get update -qq >/dev/null; apt-get install -y --no-install-recommends docker-ce docker-ce-cli containerd.io docker-buildx-plugin >/dev/null
                ;;
            centos|rhel|fedora|rocky|almalinux)
                print_info "正在为 RHEL/CentOS 系统安装 Docker..."
                yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo >/dev/null
                yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin >/dev/null
                ;;
            *) print_error "!! 不支持的操作系统: $OS_ID。"; exit 1;;
        esac
        print_info "正在启动并设置Docker开机自启..."; systemctl start docker && systemctl enable docker; safe_sleep 3
    fi

    if ! docker info >/dev/null 2>&1; then print_warning "Docker 服务未运行，正在尝试启动..."; systemctl start docker; safe_sleep 3; if ! docker info >/dev/null 2>&1; then print_error "!! 启动 Docker 服务失败。请检查日志: journalctl -u docker.service"; exit 1; fi; fi
    if ! docker buildx version &>/dev/null; then print_error "!! Docker buildx 插件缺失！"; exit 1; fi
    print_success "Docker 环境准备就绪。"
}
setup_buildx() {
    print_bold "第三阶段: Docker Buildx 多架构构建环境配置"
    print_info "正在配置多架构构建支持 (binfmt)..."
    if ! docker image inspect tonistiigi/binfmt:latest &>/dev/null; then print_info "正在拉取 'tonistiigi/binfmt' 镜像..."; if ! docker pull tonistiigi/binfmt:latest; then print_error "!! 拉取 'tonistiigi/binfmt' 镜像失败。"; exit 1; fi; fi
    if ! docker run --rm --privileged tonistiigi/binfmt:latest --install all >/dev/null 2>&1; then
        print_error "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 致命错误 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        print_error "   无法通过特权容器与系统内核交互。这几乎总是由 AppArmor 或 SELinux 安全策略导致。"
        print_error "--------------------------- 【首选】一键修复方案 ---------------------------"
        if command -v apt-get &>/dev/null; then print_error "   Ubuntu/Debian 系统: ${COLOR_CYAN}sudo apt-get install apparmor-utils -y && sudo aa-complain /etc/apparmor.d/docker${COLOR_RESET}";
        else print_error "   CentOS/RHEL 系统: ${COLOR_CYAN}sudo setenforce 0 && sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config${COLOR_RESET}"; fi
        print_error "----------------------------------------------------------------------"
        print_error "   请为您的系统执行上述命令，然后重新运行本脚本。"
        print_error "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"; exit 1
    fi
    print_success "Binfmt 支持已成功配置。"
    print_info "正在设置 Buildx builder '$BUILDER_NAME'..."
    if docker buildx ls | grep -q "^${BUILDER_NAME}"; then docker buildx rm --force "$BUILDER_NAME" >/dev/null 2>&1 || true; fi
    if ! docker buildx create --name "$BUILDER_NAME" --driver docker-container --bootstrap --use >/dev/null 2>&1; then print_error "!! 创建 Buildx builder '$BUILDER_NAME' 失败！"; exit 1; fi
    print_success "Buildx builder '$BUILDER_NAME' 已就绪并设为默认。"
}
build_image() {
    if [[ -z "$1" ]] && docker image inspect "$IMAGE_NAME" &>/dev/null; then print_info "镜像 '$IMAGE_NAME' 已存在，跳过构建。"; return; fi
    setup_buildx; TMP_WORKDIR=$(mktemp -d); cd "$TMP_WORKDIR"
    cli_url="https://github.com/nexus-xyz/nexus-cli/releases/download/${NEXUS_CLI_VERSION}/nexus-network-linux-arm64"
    print_info "正在生成 Dockerfile...";
    cat > Dockerfile <<EOF
FROM --platform=linux/arm64 ubuntu:24.04
ENV DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y --no-install-recommends curl screen ca-certificates && rm -rf /var/lib/apt/lists/*
RUN curl -L -o /usr/local/bin/nexus-network ${cli_url} && chmod +x /usr/local/bin/nexus-network
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
VOLUME /root/.nexus
EOF
    cat > entrypoint.sh <<'EOF'
#!/bin/bash
set -e
if [ -z "$NODE_ID" ]; then echo "错误: 未设置NODE_ID环境变量!" >&2; exit 1; fi
mkdir -p /root/.nexus && echo "$NODE_ID" > /root/.nexus/node-id
LOG_FILE="/root/nexus.log"; SESSION="nexus_${NODE_ID}"
echo "正在screen会话($SESSION)中启动 Nexus 节点 $NODE_ID ..."
screen -dmS "$SESSION" bash -c "nexus-network start --node-id \$NODE_ID | tee \$LOG_FILE"
sleep 2
if ! screen -ls | grep -q "$SESSION"; then echo "!!! 节点启动失败，请检查日志: $LOG_FILE" >&2; cat "$LOG_FILE" >&2; exit 1; fi
echo "节点 $NODE_ID 启动成功。"
tail -f /dev/null
EOF
    print_info "正在构建镜像 '$IMAGE_NAME'..."; if ! docker buildx build --builder "$BUILDER_NAME" -t "$IMAGE_NAME" . --load; then print_error "!! Docker 镜像构建失败。"; exit 1; fi
    print_success "镜像 '$IMAGE_NAME' 构建成功。"
}

# --- 节点管理与UI函数 ---
run_container() { local node_id="$1"; [ -z "$node_id" ] && { print_error "Node ID不能为空。"; return 1; }; local cname="${BASE_CONTAINER_NAME}-${node_id}"; if [ -n "$(docker ps -a -q -f name="^${cname}$")" ]; then docker stop "$cname" &>/dev/null || true; docker rm "$cname" &>/dev/null || true; fi; mkdir -p "$LOG_DIR"; local log_file="${LOG_DIR}/nexus-${node_id}.log"; touch "$log_file"; print_info "正在启动节点 ${node_id}..."; if ! docker run -d --name "$cname" -v "${log_file}:/root/nexus.log" -e NODE_ID="$node_id" --restart unless-stopped "$IMAGE_NAME" &>/dev/null; then print_error "!! 容器 '${cname}' 启动失败。"; return 1; fi; safe_sleep 3; if [ -n "$(docker ps -q -f name="^${cname}$")" ]; then print_success "节点 $node_id 启动成功。日志文件: $log_file"; else print_error "节点 $node_id 启动后未在运行！请检查日志。"; cat "$log_file"; fi; }
stop_node() { local cname="${BASE_CONTAINER_NAME}-${1}"; if [ -n "$(docker ps -q -f name="^${cname}$")" ]; then docker stop "$cname" &>/dev/null && print_success "节点 ${1} 已停止。"; else print_info "节点 ${1} 已是停止状态或不存在。"; fi; }
start_node() { local cname="${BASE_CONTAINER_NAME}-${1}"; if [ -n "$(docker ps -a -q -f name="^${cname}$")" ]; then docker start "$cname" &>/dev/null; safe_sleep 2; if [ -n "$(docker ps -q -f name="^${cname}$")" ]; then print_success "节点 ${1} 已启动。"; fi; else print_error "未找到节点 ${1}。"; fi; }
restart_node() { local cname="${BASE_CONTAINER_NAME}-${1}"; if [ -n "$(docker ps -a -q -f name="^${cname}$")" ]; then docker restart "$cname" &>/dev/null; safe_sleep 2; print_success "节点 ${1} 已重启。"; else print_error "未找到节点 ${1}。"; fi; }
uninstall_node() { local cname="${BASE_CONTAINER_NAME}-${1}"; print_info "正在卸载节点 ${1}..."; if [ -n "$(docker ps -a -q -f name="^${cname}$")" ]; then docker stop "$cname" &>/dev/null || true; docker rm "$cname" &>/dev/null || true; fi; rm -f "${LOG_DIR}/nexus-${1}.log"; print_success "节点 ${1} 已卸载。"; }
get_all_node_ids() { docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//" | sort -u; }
view_node_logs() { docker logs -f "${BASE_CONTAINER_NAME}-${1}"; }
list_nodes() { print_color "============================== 当前 Nexus 节点状态 ===============================" "$COLOR_BLUE"; printf "%-40s %-28s %-12s %-18s\n" "$(print_bold "节点ID(容器名)")" "$(print_bold "状态")" "$(print_bold "CPU")" "$(print_bold "内存")"; print_color "----------------------------------------------------------------------------------" "$COLOR_BLUE"; local nodes=$(get_all_node_ids); if [ -z "$nodes" ]; then print_warning "未找到任何 Nexus 节点。"; else declare -A stats_map; if [ -n "$(docker ps -q -f name="${BASE_CONTAINER_NAME}-")" ]; then local stats_output; stats_output=$(docker stats --no-stream --format "{{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"); while IFS=$'\t' read -r name cpu mem; do stats_map["$name"]="$cpu\t$mem"; done <<< "$stats_output"; fi; for id in $nodes; do local cname="${BASE_CONTAINER_NAME}-${id}"; local status=$(docker ps -a -f name="^${cname}$" --format "{{.Status}}"); local s_color="$COLOR_RED"; local cpu="N/A"; local mem="N/A"; if [[ "$status" == *"Up"* ]]; then s_color="$COLOR_GREEN"; if [[ -v stats_map["$cname"] ]]; then IFS=$'\t' read -r cpu mem <<< "${stats_map[$cname]}"; fi; elif [[ "$status" == *"Exited"* ]]; then s_color="$COLOR_YELLOW"; fi; printf "%-40s %-28s %-12s %-18s\n" "$id ($cname)" "$(print_color "$status" "$s_color")" "$cpu" "$mem"; done; fi; print_color "==================================================================================" "$COLOR_BLUE"; }
select_node_action() { local action_callback="$1"; local prompt_message="$2"; local nodes=($(get_all_node_ids)); if [ ${#nodes[@]} -eq 0 ]; then print_warning "无节点可操作。"; read -n 1 -s -r -p "按任意键返回..."; return; fi; echo "选择要'${prompt_message}'的节点:"; for i in "${!nodes[@]}"; do printf "  ${COLOR_CYAN}%d.${COLOR_RESET} %s\n" "$((i+1))" "${nodes[$i]}"; done; read -rp "请输入选项 (0 返回): " choice; if [[ "$choice" =~ ^[1-9][0-9]*$ ]] && [ "$choice" -le ${#nodes[@]} ]; then "$action_callback" "${nodes[$((choice-1))]}"; fi; read -n 1 -s -r -p "按任意键返回..."; }
select_multiple_nodes_action() { local action_callback="$1"; local prompt_message="$2"; local nodes=($(get_all_node_ids)); if [ ${#nodes[@]} -eq 0 ]; then print_warning "无节点可操作。"; read -n 1 -s -r -p "按任意键返回..."; return; fi; echo "选择要'${prompt_message}'的节点(多选用空格; 'all'全选):"; for i in "${!nodes[@]}"; do printf "  ${COLOR_CYAN}%d.${COLOR_RESET} %s\n" "$((i+1))" "${nodes[$i]}"; done; read -rp "请输入选项 (0 返回): " choices_str; if [ "$choices_str" = "0" ] || [ -z "$choices_str" ]; then return; fi; local selected=(); if [ "$choices_str" = "all" ]; then selected=("${nodes[@]}"); else for c in $choices_str; do if [[ "$c" =~ ^[1-9][0-9]*$ ]] && [ "$c" -le ${#nodes[@]} ]; then selected+=("${nodes[$((c-1))]}"); fi; done; fi; if [ ${#selected[@]} -gt 0 ] && confirm_action "确认'${prompt_message}'选中的 ${#selected[@]} 个节点?"; then for id in "${selected[@]}"; do "$action_callback" "$id"; done; print_success "批量操作完成。"; fi; read -n 1 -s -r -p "按任意键返回..."; }
menu_install_single() { read -rp "请输入要安装的 Node ID: " id; id=$(echo "$id"|xargs); if [ -n "$id" ]; then build_image; run_container "$id"; else print_warning "ID 无效。"; fi; read -n 1 -s -r -p "按任意键返回..."; }
menu_batch_install() { build_image; print_info "请输入多个Node ID(每行一个,空行结束):"; local ids=(); while read -r line && [ -n "$line" ]; do ids+=("$(echo "$line"|xargs)"); done; if [ ${#ids[@]} -gt 0 ] && confirm_action "确认安装 ${#ids[@]} 个新节点?"; then for id in "${ids[@]}"; do run_container "$id"; done; fi; read -n 1 -s -r -p "按任意键返回..."; }
menu_restore_network() { print_bold "恢复网络配置"; if [ ! -f "${DNS_BACKUP_FILE}" ]; then print_warning "未找到DNS备份文件: ${DNS_BACKUP_FILE}。无法恢复。"; read -n 1 -s -r -p "按任意键返回..."; return; fi; if ! confirm_action "将从备份文件恢复DNS配置。这将重启您的网络连接，确定吗？"; then return; fi; local active_con=$(nmcli -t -f NAME,DEVICE,STATE c show --active | grep ':\(connected\|connected (site-only)\)' | head -n 1 | cut -d: -f1); if [ -z "$active_con" ]; then print_error "!! 未找到活跃网络连接。无法恢复。"; read -n 1 -s -r -p "按任意键返回..."; return; fi; read -r old_dns old_auto_dns < "${DNS_BACKUP_FILE}"; print_info "正在将 '${active_con}' 的DNS恢复为 '${old_dns:-<empty>}' 并设置自动DNS为 '${old_auto_dns}'..."; nmcli con mod "${active_con}" ipv4.dns "${old_dns}"; nmcli con mod "${active_con}" ipv4.ignore-auto-dns "${old_auto_dns}"; nmcli con down "${active_con}" &>/dev/null || true; sleep 2; nmcli con up "${active_con}"; print_success "网络配置已恢复！请检查您的网络连接。"; read -n 1 -s -r -p "按任意键返回..."; }
menu_update() { while true; do clear; print_color "===== 系统维护与更新 =====" "$COLOR_BLUE"; echo " 1. 强制重构镜像"; echo " 2. 更新所有运行中节点"; echo " 3. 清理所有数据"; echo " 0. 返回"; read -rp "请输入选项: " choice; case $choice in 1) build_image "--force";; 2) if confirm_action "确认更新所有运行中节点?"; then build_image "--force"; for id in $(docker ps --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//"); do run_container "$id"; done; fi;; 3) if confirm_action "【警告】将删除所有节点、镜像、日志和builder！确定吗?"; then docker rm -f $(docker ps -a -q --filter "name=${BASE_CONTAINER_NAME}-") >/dev/null 2>&1 || true; if docker image inspect "$IMAGE_NAME" &>/dev/null; then docker rmi -f "$IMAGE_NAME"; fi; if docker buildx ls | grep -q "$BUILDER_NAME"; then docker buildx rm -f "$BUILDER_NAME"; fi; print_success "清理完成。"; fi;; 0) break;; *) print_error "无效选项。";; esac; read -n 1 -s -r -p "按任意键返回..."; done; }

# --- 主入口 ---
main_menu() {
    if [ "$(id -u)" -ne 0 ]; then print_error "错误: 脚本需要root权限运行。"; exit 1; fi
    prepare_system_and_network
    ensure_docker_ready
    while true; do
        clear; print_color "===== Nexus 管理脚本 ${SCRIPT_VERSION} =====" "$COLOR_BLUE"; list_nodes; echo;
        print_info "--- 节点管理 ---";
        echo " 1. 安装/启动单节点   4. 停止节点"; echo " 2. 查看节点日志     5. 启动节点"; echo " 3. 卸载节点         6. 重启节点";
        print_info "--- 批量操作 ---";
        echo " 7. 批量安装新节点   10. 批量卸载"; echo " 8. 批量停止节点      9. 批量启动";
        print_info "--- 系统维护 ---";
        echo " 11. 更新与维护"; echo " 12. 恢复网络配置 (重要！)"; echo "  0. 退出脚本"; echo
        read -rp "请输入选项: " choice
        case $choice in
            1) menu_install_single ;; 2) select_node_action view_node_logs "查看日志" ;; 3) select_node_action uninstall_node "卸载" ;;
            4) select_node_action stop_node "停止" ;; 5) select_node_action start_node "启动" ;; 6) select_node_action restart_node "重启" ;;
            7) menu_batch_install ;; 8) select_multiple_nodes_action stop_node "停止" ;; 9) select_multiple_nodes_action start_node "启动" ;;
            10) select_multiple_nodes_action uninstall_node "卸载" ;; 11) menu_update ;; 12) menu_restore_network ;; 0) exit 0 ;; *) print_error "无效选项。" && safe_sleep 1 ;;
        esac
    done
}

main_menu
