#!/bin/bash
# Description: Nexus 多节点管理脚本
# Author: 哈哈哈哈 (推特: @ferdie_jhovie) - 免费开源，请勿相信收费。
# 如有问题，可联系推特，仅此一个账号。
# Last Updated: 2024-07-28

# 确保在任何命令失败时立即退出，在尝试使用未设置的变量时退出，并且管道中的任何命令失败时退出。
set -euo pipefail

# ============== 配置变量 =============
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs"     # 宿主机上存放所有 Nexus 节点日志的目录
SCRIPT_DIR="/root/nexus_scripts" # 宿主机上存放轮换脚本的目录

# ============== 权限检查 ==============
# 检查是否以root用户权限运行
if [[ "$EUID" -ne 0 ]]; then
    echo "错误：请以root用户权限运行此脚本。例如：sudo bash $(basename "$0")"
    exit 1
fi

# ============== 基础环境检查与安装函数 ==============

# 检查并安装 Docker
function check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "检测到未安装 Docker，正在安装..."
        echo "更新 apt 包列表..."
        apt update -y || { echo "错误：apt update 失败。请检查网络连接或源配置。"; return 1; }

        echo "安装 Docker 依赖项..."
        apt install -y apt-transport-https ca-certificates curl software-properties-common || \
            { echo "错误：安装 Docker 前置组件失败。"; return 1; }

        echo "添加 Docker 官方 GPG 密钥..."
        if ! curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -; then
            echo "错误：添加 Docker GPG 密钥失败。"; return 1;
        fi
        
        echo "添加 Docker APT 仓库..."
        if ! add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"; then
            echo "错误：添加 Docker APT 仓库失败。"; return 1;
        fi
        
        echo "再次更新 apt 包列表以获取 Docker 包信息..."
        apt update -y || { echo "错误：apt update 失败。"; return 1; }

        echo "安装 Docker CE..."
        apt install -y docker-ce || { echo "错误：安装 docker-ce 失败。"; return 1; }
        
        echo "启用并启动 Docker 服务..."
        systemctl enable docker || echo "警告：无法设置 Docker 开机自启，请手动检查：systemctl enable docker"
        systemctl start docker || echo "警告：无法立即启动 Docker 服务，请手动检查：systemctl start docker"
        
        echo "Docker 安装完成。"
        # 对于非root用户，还需要将其加入docker组，但此脚本强制root运行，故此提示保留为通用提醒。
        # if [[ "$(whoami)" != "root" ]]; then
        #     echo "提示：建议您将当前用户添加到 'docker' 组以避免每次都使用 sudo。执行：'sudo usermod -aG docker \$USER'，然后重新登录或重启您的终端。"
        # fi
        return 0
    fi
    return 0
}

# 检查并安装 Node.js/npm/pm2
function check_pm2() {
    local installed_node=false
    local installed_pm2=false

    if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
        echo "检测到未安装 Node.js/npm，正在安装..."
        apt update -y || { echo "错误：apt update 失败。"; return 1; }
        # 使用 NodeSource 官方推荐脚本安装 Node.js 18.x
        if curl -fsSL https://deb.nodesource.com/setup_18.x | bash -; then
            if apt-get install -y nodejs; then
                echo "Node.js/npm 安装完成。"
                installed_node=true
            else
                echo "错误：安装 Node.js 失败。"; return 1;
            fi
        else
            echo "错误：下载 Node.js setup script 失败。"; return 1;
        fi
    fi

    if ! command -v pm2 >/dev/null 2>&1; then
        echo "检测到未安装 pm2，正在安装..."
        if npm install -g pm2; then
            echo "pm2 安装完成。"
            installed_pm2=true
        else
            echo "错误：安装 pm2 失败。"; return 1;
        fi
    fi

    if [[ "$installed_pm2" == true ]]; then
        # 配置 PM2 启动脚本，以便在系统重启后能自动恢复进程
        pm2 startup systemd || echo "警告：PM2 无法配置为系统启动服务，请手动检查。您可以使用 'pm2 startup' 查看命令。"
        pm2 save || echo "警告：PM2 无法保存当前进程列表，重启后可能无法自动恢复。您可以尝试 'pm2 save --force'。"
    fi
    return 0
}

# ============== Docker 镜像构建函数 ==============

# 构建docker镜像函数
function build_image() {
    echo "正在构建 Docker 镜像: $IMAGE_NAME ..."
    local workdir
    # 创建一个临时目录用于存放 Dockerfile 和 entrypoint.sh
    workdir=$(mktemp -d -t nexus-docker-build-XXXXXX)
    if [[ -z "$workdir" ]]; then
        echo "错误：无法创建临时目录。"
        return 1
    fi
    # 确保在脚本退出时（包括错误退出）删除临时目录
    trap "rm -rf '$workdir'" EXIT # trap只对当前shell有效，不是子shell。

    # Dockerfile 内容
    cat > "$workdir/Dockerfile" <<EOF
FROM ubuntu:24.04

# 设置环境变量，确保apt安装过程是非交互式的
ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id

# 安装必要工具和 Nexus Network CLI
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    bash \
    procps \
    && rm -rf /var/lib/apt/lists/*

# 自动下载并安装最新版 nexus-network CLI
# NONINTERACTIVE=1 防止脚本在安装过程中询问用户
RUN curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh \
    && ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network

# 拷贝自定义的 entrypoint 脚本到容器内部，并赋予执行权限
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# 设置容器启动时执行的命令，exec确保/entrypoint.sh成为PID 1
ENTRYPOINT ["/entrypoint.sh"]
EOF

    # entrypoint.sh 脚本内容
    # 注意：此处将 nexus-network 的实际日志文件 (通常在 ~/.nexus/logs/nexus-network.log)
    # 通过软链接方式指向宿主机挂载的 /root/nexus.log，确保日志写入宿主机文件
    cat > "$workdir/entrypoint.sh" <<EOF
#!/bin/bash
# Docker容器启动时执行的入口脚本
set -euo pipefail

PROVER_ID_FILE="/root/.nexus/node-id"
# NEXUS_LOG_FILE 是宿主机挂载的日志文件在容器内的路径
NEXUS_LOG_FILE="/root/nexus.log"
# NEXUS_NETWORK_INTERNAL_LOG 是 nexus-network 程序默认写入日志的路径
NEXUS_NETWORK_INTERNAL_LOG="/root/.nexus/logs/nexus-network.log"

# 检查 NODE_ID 环境变量是否设置
if [ -z "\$NODE_ID" ]; then
    echo "错误：未设置 NODE_ID 环境变量。容器无法启动。"
    exit 1
fi

# 确保 node-id 文件所在目录存在
mkdir -p "\$(dirname "\$PROVER_ID_FILE")" || { echo "错误：无法创建 prover id 目录。"; exit 1; }
# 将 NODE_ID 写入文件
echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo "成功设置 node-id: \$NODE_ID"

# 检查 nexus-network 命令是否可用
if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 命令未安装或不可用。请检查 Docker 镜像构建过程。"
    exit 1
fi

# 确保 nexus 内部日志目录存在，并创建/清理用于日志的软链接
mkdir -p "\$(dirname "\$NEXUS_NETWORK_INTERNAL_LOG")" || { echo "错误：无法创建内部日志目录。"; exit 1; }
# 如果存在旧的内部日志文件或软链接，先删除
rm -f "$NEXUS_NETWORK_INTERNAL_LOG" || true
# 创建从内部日志路径到宿主机挂载日志路径的软链接
ln -s "$NEXUS_LOG_FILE" "$NEXUS_NETWORK_INTERNAL_LOG" || { echo "错误：无法创建日志文件软链接。Nexus 日志可能无法写入到外部文件。"; exit 1; }
echo "已将 Nexus 内部日志路径链接到挂载的宿主机日志文件：$NEXUS_NETWORK_INTERNAL_LOG -> $NEXUS_LOG_FILE"

echo "[$(date '+%Y-%m-%d %H:%M:%S')] 启动 nexus-network 节点..."
# 在后台启动 nexus-network。'start' 命令通常会启动一个守护进程并退出。
# 标准输出和错误输出将被重定向到 /dev/null，因为主要的日志应该由 Nexus 写入到其自己的日志文件。
(nexus-network start --node-id "\$NODE_ID" >/dev/null 2>&1 ) &

# 给 nexus-network 守护进程一些时间来启动
sleep 5

# 检查 nexus-network 进程是否成功启动
if pgrep -f "nexus-network start" >/dev/null; then
    echo "节点进程已在后台成功启动。PID: $(pgrep -f "nexus-network start" | head -n 1)"
    echo "详细日志请查看：$NEXUS_LOG_FILE （通过 docker logs 命令）"
else
    echo "错误：nexus-network 节点启动失败，请检查容器日志或宿主机日志文件是否有错误信息。"
    # 如果启动失败，容器应该退出
    exit 1
fi

# 通过 'tail -f' 命令保持容器持续运行，并实时显示节点日志
# exec tail -f 会替换掉当前 shell，成为 PID 1 进程，以便 Docker 正确管理容器生命周期。
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 实时跟踪节点日志 (日志路径：$NEXUS_NETWORK_INTERNAL_LOG)..."
exec tail -f "$NEXUS_NETWORK_INTERNAL_LOG"
EOF

    # 构建 Docker 镜像
    if docker build -t "$IMAGE_NAME" "$workdir"; then
        echo "Docker 镜像 $IMAGE_NAME 构建完成。"
        rm -rf "$workdir" # 成功构建后，清理临时目录
        trap - EXIT     # 禁用退出陷阱，因为已经手动清理
        return 0
    else
        echo "错误：Docker 镜像构建失败。请检查错误信息。"
        rm -rf "$workdir" # 失败时也清理临时目录
        trap - EXIT     # 禁用退出陷阱
        return 1
    fi
}

# ============== 节点管理函数 ==============

# 启动容器
function run_container() {
    local node_id="$1"
    if [[ -z "$node_id" ]]; then
        echo "错误：run_container 函数需要 node_id 参数。"
        return 1
    fi

    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "尝试启动容器 $container_name (Node ID: $node_id)..."

    # 停止并删除同名的旧容器（如果存在）
    if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        echo "检测到旧容器 $container_name，正在停止并删除..."
        if ! docker rm -f "$container_name"; then
            echo "警告：无法停止或删除旧容器 $container_name，尝试继续。"
        fi
    fi

    # 确保宿主机上的日志目录存在
    mkdir -p "$LOG_DIR" || { echo "错误：无法创建日志目录 $LOG_DIR。"; return 1; }
    
    # 确保宿主机上的日志文件存在且不是目录，并设置正确权限
    if [[ -d "$log_file" ]]; then
        echo "警告：检测到旧日志文件 $log_file 是一个目录。正在删除并重建为文件。"
        rm -rf "$log_file" || { echo "错误：无法删除旧的日志目录 $log_file。"; return 1; }
    fi
    if ! touch "$log_file"; then
        echo "错误：无法创建日志文件 $log_file。"; return 1;
    fi
    if ! chmod 644 "$log_file"; then # rW-r--r-- (拥有者读写，其他人只读)
        echo "警告：无法设置日志文件 $log_file 的权限。"; # 警告但不退出
    fi
    
    # 运行 Docker 容器
    # --restart unless-stopped：除非明确停止容器，否则Docker守护进程启动或重启时自动重启容器。
    if docker run -d \
        --name "$container_name" \
        -v "$log_file":/root/nexus.log \
        -e NODE_ID="$node_id" \
        --restart unless-stopped \
        "$IMAGE_NAME"; then
        echo "容器 $container_name 已成功启动！日志已映射到宿主机路径：$log_file"
        return 0
    else
        echo "错误：启动容器 $container_name 失败。请检查 Docker 日志以获取更多信息。"
        return 1
    fi
}

# 停止并卸载容器、删除日志文件
function uninstall_node() {
    local node_id="$1"
    if [[ -z "$node_id" ]]; then
        echo "错误：uninstall_node 函数需要 node_id 参数。"
        return 1
    fi

    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "正在停止并删除容器 $container_name..."
    if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        if docker rm -f "$container_name"; then # -f 强制停止并删除
            echo "容器 $container_name 已停止并删除。"
        else
            echo "警告：无法停止或删除容器 $container_name。请手动检查 Docker 状态。"
        fi
    else
        echo "容器 $container_name 不存在，无需删除。"
    fi

    if [[ -e "$log_file" ]]; then # -e 检查文件或目录是否存在
        echo "正在删除日志文件或目录 $log_file ..."
        if rm -rf "$log_file"; then # -r 递归删除目录，-f 强制删除
            echo "日志文件/目录 $log_file 已删除。"
        else
            echo "警告：无法删除日志文件/目录 $log_file。请手动检查权限或文件状态。"
        fi
    else
        echo "日志文件/目录不存在：$log_file。"
    fi

    echo "节点 $node_id 已卸载完成。"
    return 0
}

# ============== 节点信息查看函数 ==============

# 获取所有运行中的节点ID
function get_running_nodes() {
    docker ps --filter "name=^${BASE_CONTAINER_NAME}-" --filter "status=running" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//"
}

# 获取所有节点ID（包括已停止的）
function get_all_nodes() {
    docker ps -a --filter "name=^${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//" | sort -u
}

# 显示所有节点状态
function list_nodes() {
    local all_node_ids=($(get_all_nodes))
    
    if [[ ${#all_node_ids[@]} -eq 0 ]]; then
        echo "当前没有 Nexus 节点容器。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "当前节点状态概览："
    echo "--------------------------------------------------------------------------------------------------------------------------"
    printf "%-6s %-20s %-10s %-12s %-15s %-10s %-20s %-15s\n" "序号" "节点ID" "状态" "CPU%" "内存使用/限制" "Mem%" "启动时间" "镜像ID"
    echo "--------------------------------------------------------------------------------------------------------------------------"
    
    local i=0
    for node_id in "${all_node_ids[@]}"; do
        ((i++))
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"

        # 使用 docker inspect 获取创建时间和 Image ID
        local inspect_output=$(docker inspect --format '{{.State.Status}}\n{{.Created}}\n{{.Config.Image}}' "$container_name" 2>/dev/null || true)
        if [[ -z "$inspect_output" ]]; then
            # Container might be completely removed or inspect failed
            printf "%-6d %-20s %-10s %-12s %-15s %-10s %-20s %-15s\n" \
                "$i" \
                "$node_id" \
                "未知" \
                "N/A" \
                "N/A" \
                "N/A" \
                "N/A" \
                "N/A"
            continue
        fi

        IFS=$'\n' read -r status_raw created_time image_full_name <<< "$inspect_output"
        local status=$(echo "$status_raw" | cut -c1 | tr '[:lower:]' '[:upper:]')$(echo "$status_raw" | cut -c2-) # Capitalize first letter
        local image_short_id=$(echo "$image_full_name" | cut -d':' -f2 | cut -c-12 || echo "$image_full_name" | cut -c-12) # For nexus-node:latest it extracts 'latest' for ID. Fallback to image name if not ID.

        local cpu_usage="N/A"
        local mem_usage_limit="N/A"
        local mem_percent="N/A"

        # 如果容器正在运行，获取实时统计数据
        if [[ "$status_raw" == "running" ]]; then
            local stats_output=$(docker stats "$container_name" --no-stream --format "{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}" 2>/dev/null || true)
            if [[ -n "$stats_output" ]]; then
                IFS=$'\t' read -r cpu_perc mem_usage_raw mem_perc_raw <<< "$stats_output"
                cpu_usage=$(echo "$cpu_perc" | xargs)
                mem_usage_limit=$(echo "$mem_usage_raw" | xargs)
                mem_percent=$(echo "$mem_perc_raw" | xargs)
            fi
        fi
        
        printf "%-6d %-20s %-10s %-12s %-15s %-10s %-20s %-15s\n" \
            "$i" \
            "$node_id" \
            "$status" \
            "$cpu_usage" \
            "$mem_usage_limit" \
            "$mem_percent" \
            "$(date -d "$created_time" '+%Y-%m-%d %H:%M')" \
            "$image_short_id"
    done
    echo "--------------------------------------------------------------------------------------------------------------------------"
    echo "提示："
    echo "- 状态：容器当前运行状态 (e.g., Up, Exited, Created)"
    echo "- CPU%：容器CPU使用百分比"
    echo "- 内存使用/限制：容器当前使用的内存及限制"
    echo "- Mem%：容器内存使用百分比"
    echo "- 启动时间：容器创建的时间"
    echo "- 镜像ID：容器所用的Docker镜像简短ID"
    read -p "按任意键返回菜单"
}


# 查看指定节点日志 (需要用户选择)
function select_node_to_view() {
    local all_nodes=($(get_all_nodes))
    
    if [[ ${#all_nodes[@]} -eq 0 ]]; then
        echo "当前没有节点可供查看日志。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "请选择要查看日志的节点："
    echo "0. 返回主菜单"
    local i=0
    for node_id in "${all_nodes[@]}"; do
        ((i++))
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}" 2>/dev/null || true)
        local display_status="未知"
        if [[ $status == Up* ]]; then
            display_status="运行中"
        elif [[ -n "$status" ]]; then
            display_status="已停止"
        fi
        printf "%d. 节点 %-20s [%s]\n" "$i" "$node_id" "$display_status"
    done

    local choice
    read -rp "请输入选项(0-$i): " choice

    if [[ "$choice" = "0" ]]; then
        return # 返回主菜单
    fi

    if [[ "$choice" -ge 1 ]] && [[ "$choice" -le "$i" ]]; then
        local selected_node=${all_nodes[$((choice-1))]}
        
        # Log view mode selection
        local container_name="${BASE_CONTAINER_NAME}-${selected_node}"
        if ! docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
            echo "错误：容器 $container_name 不存在或已移除。无法查看日志。"
            read -p "按任意键返回菜单"
            return 1
        fi

        echo "------------------------------------------------"
        echo "请选择日志查看模式："
        echo "1. 原始日志（可能包含颜色代码和控制字符）"
        echo "2. 清理后的日志（移除颜色代码和控制字符）"
        echo "3. 返回上级菜单"
        echo "------------------------------------------------"
        
        local log_mode
        while true; do
            read -rp "请选择(1-3): " log_mode
            case "$log_mode" in
                1)
                    echo "开始显示原始日志 (Ctrl+C 退出)..."
                    docker logs -f "$container_name"
                    break
                    ;;
                2)
                    echo "开始显示清理后的日志 (Ctrl+C 退出)..."
                    # 更强大的 sed 命令去除 ANSI 颜色/控制码
                    docker logs -f "$container_name" | sed -E 's/\x1b\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g' | sed -E 's/\x1b\[?25l|\x1b\[?25h//g'
                    break
                    ;;
                3)
                    echo "取消日志查看。"
                    break
                    ;;
                *)
                    echo "无效的选择。请重新输入 1, 2 或 3。"
                    ;;
            esac
        done
    else
        echo "无效的选项。请重新选择。"
        read -p "按任意键继续"
    fi
    return 0
}


# ============== 批量操作函数 ==============

# 批量安装并启动多个节点
function batch_start_nodes() {
    echo "请按行输入您要启动的 node-id (每个 ID 占一行)。"
    echo "输入完成后，请按回车键，然后按 Ctrl+D 结束输入。"
    echo "例如："
    echo "my-nexus-id-01"
    echo "my-nexus-id-02"
    echo "[按回车]"
    echo "[再按 Ctrl+D 结束]"
    
    local node_ids=()
    while IFS= read -r line; do
        line=$(echo "$line" | xargs) # 移除前后空格
        if [[ -n "$line" ]]; then
            node_ids+=("$line")
        fi
    done
    
    if [[ ${#node_ids[@]} -eq 0 ]]; then
        echo "未输入任何 node-id。操作已取消。"
        read -p "按任意键继续"
        return
    fi

    echo "您将启动以下节点：${node_ids[*]}"
    read -rp "确认要启动这些节点吗？(y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "操作已取消。"
        read -p "按任意键继续"
        return
    fi

    echo "---------------------------------------------------------------------------------------------------"
    echo "开始构建 Docker 镜像 (如果尚未构建或需要更新)..."
    if ! build_image; then
        echo "镜像构建失败，无法继续批量启动节点。"
        read -p "按任意键继续"
        return
    fi

    echo "---------------------------------------------------------------------------------------------------"
    echo "开始批量启动节点..."
    local start_errors=0
    for node_id in "${node_ids[@]}"; do
        echo "--------------------------------------------------"
        echo "正在尝试启动节点：$node_id"
        if run_container "$node_id"; then
            echo "节点 $node_id 启动命令已执行，等待5秒以便资源分配..."
            sleep 5 # 短暂延迟，避免并发问题
        else
            echo "错误：节点 $node_id 启动失败。"
            ((start_errors++))
        fi
    done

    echo "---------------------------------------------------------------------------------------------------"
    if [[ "$start_errors" -eq 0 ]]; then
        echo "所有指定节点已成功启动或正在启动！"
    else
        echo "完成批量启动，但有 $start_errors 个节点启动失败。"
    fi
    read -p "按任意键返回菜单"
}

# 批量停止并卸载指定节点
function batch_uninstall_nodes() {
    local all_nodes=($(get_all_nodes))
    
    if [[ ${#all_nodes[@]} -eq 0 ]]; then
        echo "当前没有节点可供操作。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "当前所有 Nexus 节点列表："
    echo "----------------------------------------"
    echo "序号  节点ID                状态"
    echo "----------------------------------------"
    for i in "${!all_nodes[@]}"; do
        local node_id="${all_nodes[$i]}"
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}" 2>/dev/null || true)
        local display_status="未知"
        if [[ $status == Up* ]]; then
            display_status="运行中"
        elif [[ -n "$status" ]]; then
            display_status="已停止"
        fi
        printf "%-6d %-20s [%s]\n" $((i+1)) "$node_id" "$display_status"
    done
    echo "----------------------------------------"

    echo "请选择要删除的节点（可多选，输入数字序号，用空格分隔，或输入 'all' 删除全部）："
    echo "0. 返回主菜单"
    
    local choices
    read -rp "请输入您的选择 (例如: 1 3 5 或 all 或 0): " choices

    if [[ "$choices" = "0" ]]; then
        return
    fi

    local selected_nodes_to_delete=()
    if [[ "$choices" == "all" ]]; then
        selected_nodes_to_delete=("${all_nodes[@]}")
    else
        read -ra selected_indices <<< "$choices" # 将输入的字符串按空格分割成数组
        for idx_str in "${selected_indices[@]}"; do
            # 确保输入是有效数字
            if [[ "$idx_str" =~ ^[0-9]+$ ]]; then
                local idx=$((idx_str-1)) # 转换为0-based索引
                if [[ "$idx" -ge 0 ]] && [[ "$idx" -lt ${#all_nodes[@]} ]]; then
                    selected_nodes_to_delete+=("${all_nodes[$idx]}")
                else
                    echo "警告：无效的序号被跳过: $idx_str"
                fi
            else
                echo "警告：无效的输入被跳过 (非数字): $idx_str"
            fi
        done
    fi

    if [[ ${#selected_nodes_to_delete[@]} -eq 0 ]]; then
        echo "没有选择任何有效节点。操作已取消。"
        read -p "按任意键继续"
        return
    fi

    echo "您选择了删除以下节点："
    for node in "${selected_nodes_to_delete[@]}"; do
        echo "- $node"
    done
    read -rp "警告：此操作不可逆！确认要删除以上所有选定的节点及其日志吗？(y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "操作已取消。"
        read -p "按任意键继续"
        return
    fi

    local uninstall_errors=0
    echo "---------------------------------------------------------------------------------------------------"
    echo "开始批量卸载..."
    for node_id in "${selected_nodes_to_delete[@]}"; do
        echo "--------------------------------------------------"
        echo "正在卸载节点：$node_id"
        if ! uninstall_node "$node_id"; then
            echo "错误：卸载节点 $node_id 失败！"
            ((uninstall_errors++))
        fi
    done

    echo "---------------------------------------------------------------------------------------------------"
    if [[ "$uninstall_errors" -eq 0 ]]; then
        echo "所有选定节点已成功卸载！"
    else
        echo "完成批量卸载，但有 $uninstall_errors 个节点卸载失败。"
    fi
    read -p "按任意键返回菜单"
}

# 删除全部节点
function uninstall_all_nodes() {
    local all_nodes=($(get_all_nodes))
    
    if [[ ${#all_nodes[@]} -eq 0 ]]; then
        echo "当前没有 Nexus 节点容器。无需执行删除操作。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "*****************************************************"
    echo "              ！！！ 极度危险操作 ！！！              "
    echo "*****************************************************"
    echo "此操作将**永久性**删除所有 Nexus 节点容器及其相关日志文件！"
    echo "当前共有 ${#all_nodes[@]} 个 Nexus 节点将被删除："
    for node_id in "${all_nodes[@]}"; do
        echo "- $node_id"
    done
    echo "所有相关数据文件 (位于 $LOG_DIR 和 $SCRIPT_DIR 及其子目录) 将被清理。"
    echo "----------------------------------------------------"
    
    read -rp "您确定要删除所有 Nexus 节点吗？(请输入 'yes' 以确认，否则输入其他取消): " confirm_all
    if [[ ! "$confirm_all" == "yes" ]]; then
        echo "操作已取消。"
        read -p "按任意键返回菜单"
        return
    fi

    local uninstall_all_errors=0
    echo "---------------------------------------------------------------------------------------------------"
    echo "开始删除所有节点..."
    for node_id in "${all_nodes[@]}"; do
        echo "--------------------------------------------------"
        echo "正在卸载节点：$node_id"
        if ! uninstall_node "$node_id"; then
            echo "错误：卸载节点 $node_id 失败！"
            ((uninstall_all_errors++))
        fi
    done

    echo "---------------------------------------------------------------------------------------------------"
    echo "清理 PM2 轮换进程 (如果存在)..."
    pm2 stop "nexus-rotate" >/dev/null 2>&1 || true
    pm2 delete "nexus-rotate" >/dev/null 2>&1 || true
    echo "PM2 轮换进程清理完毕。"

    echo "---------------------------------------------------------------------------------------------------"
    echo "清理所有 Nexus 相关目录 (日志目录: $LOG_DIR, 脚本目录: $SCRIPT_DIR)..."
    if [[ -d "$LOG_DIR" ]]; then
        if rm -rf "$LOG_DIR"; then
            echo "日志目录 $LOG_DIR 已清理。"
        else
            echo "警告：无法清理日志目录 $LOG_DIR。"
        fi
    fi
    if [[ -d "$SCRIPT_DIR" ]]; then
        if rm -rf "$SCRIPT_DIR"; then
            echo "脚本目录 $SCRIPT_DIR 已清理。"
        else
            echo "警告：无法清理脚本目录 $SCRIPT_DIR。"
        fi
    fi

    echo "---------------------------------------------------------------------------------------------------"
    if [[ "$uninstall_all_errors" -eq 0 ]]; then
        echo "所有 Nexus 节点及相关数据已**彻底**删除！"
    else
        echo "删除操作完成，但有 $uninstall_all_errors 个节点卸载失败，或部分文件清理失败。请手动检查。"
    fi
    read -p "按任意键返回菜单"
}

# ============== 批量节点轮换启动函数 ==============

# 批量节点轮换启动
function batch_rotate_nodes() {
    check_pm2 # 确保 PM2 已安装，因为轮换逻辑需要用到 PM2
    if [[ $? -ne 0 ]]; then
        echo "PM2 及其依赖安装失败，无法继续节点轮换设置。"
        read -p "按任意键返回菜单"
        return 1
    fi

    echo "请按行输入您要参与轮换的 node-id (每个 ID 占一行)。"
    echo "输入完成后，请按回车键，然后按 Ctrl+D 结束输入。"
    
    local node_ids=()
    while IFS= read -r line; do
        line=$(echo "$line" | xargs)
        if [[ -n "$line" ]]; then
            node_ids+=("$line")
        fi
    done

    if [[ ${#node_ids[@]} -eq 0 ]]; then
        echo "未输入任何 node-id。操作已取消。"
        read -p "按任意键继续"
        return
    fi

    local total_nodes=${#node_ids[@]}
    local default_nodes_per_round=$(( (total_nodes + 1) / 2 )) # 默认每轮启动总节点数的一半 (向上取整)

    local nodes_per_round
    while true; do
        read -rp "请输入每两小时要启动的节点数量（默认：${default_nodes_per_round}，最大不能超过 $total_nodes）: " nodes_per_round_input
        nodes_per_round=${nodes_per_round_input:-$default_nodes_per_round} # 如果用户未输入则使用默认值

        # 校验输入是否为数字，且在有效范围内
        if [[ "$nodes_per_round" =~ ^[0-9]+$ ]] && (( nodes_per_round >= 1 )) && (( nodes_per_round <= total_nodes )); then
            break # 有效输入，退出循环
        else
            echo "无效的节点数量 '$nodes_per_round_input'。请输入一个 1 到 ${total_nodes} 之间的数字。"
        fi
    done

    echo "---------------------------------------------------------------------------------------------------"
    echo "您将轮换启动以下 $total_nodes 个节点：${node_ids[*]}"
    echo "将分为 $(( (total_nodes + nodes_per_round - 1) / nodes_per_round )) 组，每两小时轮换启动 $nodes_per_round 个节点。"
    read -rp "确认要设置节点轮换吗？(y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "操作已取消。"
        read -p "按任意键继续"
        return
    fi

    echo "---------------------------------------------------------------------------------------------------"
    echo "开始构建 Docker 镜像 (如果尚未构建或需要更新)..."
    if ! build_image; then
        echo "镜像构建失败，无法继续节点轮换设置。"
        read -p "按任意键继续"
        return
    fi

    echo "---------------------------------------------------------------------------------------------------"
    echo "准备生成节点轮换脚本文件..."
    # 创建脚本目录
    mkdir -p "$SCRIPT_DIR" || { echo "错误：无法创建脚本目录 $SCRIPT_DIR。"; return 1; }
    # 清理旧的组启动脚本
    rm -f "$SCRIPT_DIR"/start_group*.sh || true

    # 根据每组数量生成独立的组启动脚本
    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    echo "总节点数：$total_nodes，每组启动：$nodes_per_round 个，分为 $num_groups 组。"

    for ((group=1; group<=num_groups; group++)); do
        local group_script_path="${SCRIPT_DIR}/start_group${group}.sh"
        # 写入每个组的启动脚本头
        cat > "$group_script_path" <<EOF
#!/bin/bash
set -euo pipefail
# 此脚本用于启动第 ${group} 组的 Nexus 节点。

# 重要的轮换逻辑：在启动本组节点前，停止并删除所有现有名称匹配的 Nexus 容器。
# 这确保了在任何给定时间点，只有当前组的节点在运行。
echo "[$(date '+%Y-%m-%d %H:%M:%S')] (组 ${group}) 停止所有现有的 Nexus 容器，以便启动本组节点..."
# 'xargs -r' 确保如果没有输出，xargs不会运行命令
docker ps -a --filter "name=^${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | xargs -r docker rm -f >/dev/null 2>&1 || true 
echo "[$(date '+%Y-%m-%d %H:%M:%S')] (组 ${group}) 开始启动第 ${group} 组节点..."
EOF

        # 计算本组节点ID的索引范围
        local start_index=$(( (group - 1) * nodes_per_round ))
        local end_index=$(( start_index + nodes_per_round - 1 ))
        if (( end_index >= total_nodes )); then
            end_index=$(( total_nodes - 1 )) # 确保不超出节点总数
        fi

        # 遍历并将节点ID添加到当前组的启动脚本中
        for ((i=start_index; i<=end_index; i++)); do
            local node_id=${node_ids[$i]}
            local container_name="${BASE_CONTAINER_NAME}-${node_id}"
            local log_file="${LOG_DIR}/nexus-${node_id}.log"
            
            # 在宿主机确保日志目录和文件准备就绪
            mkdir -p "$LOG_DIR" || { echo "警告：无法在脚本中创建日志目录 $LOG_DIR。"; continue; }
            if [[ -d "$log_file" ]]; then rm -rf "$log_file" || { echo "警告：无法删除旧的日志目录 $log_file。"; continue; }; fi
            touch "$log_file" || { echo "警告：无法创建日志文件 $log_file。"; continue; }
            chmod 644 "$log_file" || { echo "警告：无法设置日志文件 $log_file 权限。"; continue; }

            echo "echo \"[$(date '+%Y-%m-%d %H:%M:%S')] (组 ${group}) 正在启动节点：$node_id ...\"" >> "$group_script_path"
            echo "docker run -d --name \"$container_name\" -v \"$log_file\":/root/nexus.log -e NODE_ID=\"$node_id\" --restart unless-stopped \"$IMAGE_NAME\" >/dev/null || echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 警告：节点 $node_id 启动失败！\"" >> "$group_script_path"
            echo "sleep 10" >> "$group_script_path" # 每个节点启动间加入短暂延迟
        done
        chmod +x "$group_script_path" || { echo "错误：无法设置组启动脚本权限 $group_script_path。"; return 1; }
    done

    # 创建主轮换控制脚本
    local rotate_script_path="${SCRIPT_DIR}/rotate.sh"
    cat > "$rotate_script_path" <<EOF
#!/bin/bash
set -euo pipefail

# 这是由 Nexus 多节点管理工具生成的节点轮换主控制脚本。

CURRENT_GROUP=1      # 当前要启动的组序号
NUM_GROUPS=${num_groups} # 总共的组数量
SLEEP_TIME=7200      # 每组节点运行时间（秒，即 2 小时）

echo "[$(date '+%Y-%m-%d %H:%M:%S')] === Nexus 节点轮换主进程启动 === "
echo "总共有 \$NUM_GROUPS 组节点进行轮换，每组运行 \$((SLEEP_TIME / 3600)) 小时。"

# 用于记录当前容器状态的辅助函数
function get_container_summary() {
    local node_prefix="${BASE_CONTAINER_NAME}-"
    local running_containers=\$(docker ps --filter "name=\${node_prefix}" --format "{{.Names}}" 2>/dev/null)
    local exited_containers=\$(docker ps -a --filter "name=\${node_prefix}" --filter "status=exited" --format "{{.Names}}" 2>/dev/null)

    local running_count=0
    local exited_count=0
    if [[ -n "\$running_containers" ]]; then
        running_count=\$(echo "\$running_containers" | wc -l)
    fi
    if [[ -n "\$exited_containers" ]]; then
        exited_count=\$(echo "\$exited_containers" | wc -l)
    fi
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 摘要：当前有 \$running_count 个容器正在运行，\$exited_count 个已停止。"
    echo "\$running_containers" | while IFS= read -r cname; do echo "  - \${cname#\${node_prefix}} (运行中)"; done
    echo "\$exited_containers" | while IFS= read -r cname; do echo "  - \${cname#\${node_prefix}} (已停止)"; done
}

# 主轮换循环
while true; do
    echo "----------------------------------------------------------------------"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 开始第 \${CURRENT_GROUP} 组的轮换周期..."
    
    local script_to_run="${SCRIPT_DIR}/start_group\${CURRENT_GROUP}.sh"
    if [[ -f "\$script_to_run" ]]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 执行第 \${CURRENT_GROUP} 组的启动脚本: \$(basename "\$script_to_run")"
        if bash "\$script_to_run"; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] 第 \${CURRENT_GROUP} 组节点已成功启动 (或启动命令已执行)。"
        else
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] 错误：执行第 \${CURRENT_GROUP} 组启动脚本失败。"
            # 即使本组启动失败，也继续等待，确保整个轮换流程不会卡死
        fi
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 严重错误：未找到第 \${CURRENT_GROUP} 组的启动脚本 (\$script_to_run)。"
        # 可能是脚本被意外删除，此时可能需要管理员介入
    fi

    get_container_summary # 显示本次操作后的容器摘要

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 等待 \$((SLEEP_TIME / 3600)) 小时，直到下一次轮换..."
    # 使用 sleep 的 PID，方便捕获和终止，但在 PM2 管理下，PM2会负责管理这个sleep
    sleep \$SLEEP_TIME &
    local sleep_pid=\$!
    wait \$sleep_pid # 等待 sleep 命令完成

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 等待时间结束，进入下一轮换周期。"
    
    # 更新下一组的索引 (循环到下一组，如果到最后一组则回到第一组)
    CURRENT_GROUP=\$(( CURRENT_GROUP % NUM_GROUPS + 1 ))
done
EOF
    chmod +x "$rotate_script_path" || { echo "错误：无法设置轮换脚本权限 $rotate_script_path。"; return 1; }

    # 使用 pm2 来管理主轮换脚本
    echo "---------------------------------------------------------------------------------------------------"
    echo "停止旧的 'nexus-rotate' pm2 进程 (如果存在)..."
    pm2 stop "nexus-rotate" >/dev/null 2>&1 || true
    pm2 delete "nexus-rotate" >/dev/null 2>&1 || true

    echo "使用 pm2 启动节点轮换主进程 '$rotate_script_path' ..."
    # 设置 PM2 的日志输出路径，确保日志不会过多污染宿主机根目录
    if pm2 start "$rotate_script_path" \
        --name "nexus-rotate" \
        --max-restarts 10 \
        --restart-delay 5000 \
        --min-uptime 5000 \
        --output "$LOG_DIR/pm2-nexus-rotate-stdout.log" \
        --error "$LOG_DIR/pm2-nexus-rotate-stderr.log"; then
        echo "---------------------------------------------------------------------------------------------------"
        echo "节点轮换已通过 PM2 成功启动！"
        echo "  - 使用 'pm2 status' 查看 PM2 进程状态。"
        echo "  - 使用 'pm2 logs nexus-rotate' 实时查看轮换过程的日志。"
        echo "  - 轮换日志文件位置：$LOG_DIR/pm2-nexus-rotate-stdout.log"
        echo "  - 错误日志文件位置：$LOG_DIR/pm2-nexus-rotate-stderr.log"
        echo "  - 如需停止轮换，请执行：'pm2 stop nexus-rotate'"
        echo "  - 如需完全删除轮换进程，请执行：'pm2 delete nexus-rotate'"
        pm2 save || echo "警告：PM2 无法保存当前进程列表，重启后可能无法自动恢复。"
    else
        echo "错误：pm2 启动轮换脚本失败。请检查 PM2 安装是否正常，或手动查看 pm2 log for troubleshooting."
    fi

    read -p "按任意键返回菜单"
    return 0
}


# ============== 定时任务管理 ==============

# 设置定时清理日志任务（每2天清理一次，只保留最近2天的日志）
function setup_log_cleanup_cron() {
    echo "正在设置 Nexus 节点日志的自动清理任务..."
    # Cron 表达式: 0 3 */2 * * 表示每隔2天在凌晨3点执行
    # find ... -mtime +2 -delete 查找修改时间超过2天前的文件并删除
    local cron_job="0 3 */2 * * find $LOG_DIR -type f -name 'nexus-*.log' -mtime +2 -delete >/dev/null 2>&1"
    
    # 获取当前用户的 crontab 内容
    local current_crontab_entries=$(crontab -l 2>/dev/null || true) # 如果crontab为空会报错，所以需要加 || true
    
    # 过滤掉所有可能包含 Nexus 日志清理命令的旧行
    # 使用 awk 来避免 grep -v F 对字符串精确匹配可能导致的意外
    local new_crontab_content=""
    if [[ -n "$current_crontab_entries" ]]; then
        new_crontab_content=$(echo "$current_crontab_entries" | awk '!/find \/root\/nexus_logs -type f -name '\''nexus-\*.log'\'' -mtime \+2 -delete/ && !/pm2-nexus-rotate/') # Also filter out old PM2 output redirect
    fi
    
    # 如果新的清理任务尚不存在，则添加它
    if ! echo "$new_crontab_content" | grep -qF "$cron_job"; then
        new_crontab_content=$(echo -e "${new_crontab_content}\n${cron_job}" | sed '/^$/d') # 添加新任务并删除可能的空行
    fi

    # 将新的 crontab 内容应用
    if echo "$new_crontab_content" | crontab -; then
        echo "已成功设置每2天自动清理节点日志任务（保留最近2天的日志）。"
        echo "日志目录：$LOG_DIR"
    else
        echo "警告：无法设置 cron 任务。请手动检查 cron 服务是否运行。"
    fi
    echo "注意：PM2 会将其自身启动脚本的日志管理，不需要单独为其设置cron清理。"
    echo "您可以通过 'crontab -l' 查看已设置的定时任务。"
    echo "-------------------------------------------------------------------"
    # 等待一秒让用户读取信息，然后返回
    sleep 1
}

# ============== 主菜单函数 ==============

function main_menu() {
    setup_log_cleanup_cron # 在脚本启动时设置或更新日志清理的定时任务

    while true; do
        clear # 清屏以获得更清晰的菜单界面
        echo "=================================================================="
        echo "||           Nexus 多节点管理工具 By @ferdie_jhovie           ||"
        echo "||                       免费开源，切勿相信收费                  ||"
        echo "||                                                             ||"
        echo "||                   如有问题，请联系作者推特:                 ||"
        echo "||                       @ferdie_jhovie                        ||"
        echo "||                  (谨此只有一个号，请勿上当受骗)              ||"
        echo "=================================================================="
        echo "|| 1. 安装并启动单个新 Nexus 节点                               ||"
        echo "|| 2. 批量安装并启动多个 Nexus 节点                             ||"
        echo "|| 3. 显示所有 Nexus 节点状态 (包括运行中/已停止)              ||"
        echo "|| 4. 查看指定 Nexus 节点的实时运行日志                        ||"
        echo "|| 5. 批量停止并卸载指定 Nexus 节点 (及其日志)                  ||"
        echo "|| 6. 批量节点轮换启动 (PM2 守护，确保一部分节点持续运行)     ||"
        echo "|| 7. 删除所有 Nexus 节点、日志和相关脚本 (DANGEROUS!)          ||"
        echo "|| 8. 退出脚本                                                ||"
        echo "=================================================================="

        local choice
        read -rp "请输入您的选择 (1-8): " choice

        case "$choice" in
            1)
                check_docker || { read -p "Docker 安装失败，按任意键返回菜单"; continue; }
                read -rp "请输入您要为此节点使用的 Node-ID: " NODE_ID
                if [[ -z "$NODE_ID" ]]; then
                    echo "Node-ID 不能为空。操作已取消。"
                    read -p "按任意键继续"
                    continue
                fi
                echo "------------------------------------"
                if build_image && run_container "$NODE_ID"; then
                    echo "单个节点 $NODE_ID 已成功安装并启动。"
                else
                    echo "单个节点 $NODE_ID 安装或启动失败。请查看上面的错误信息。"
                fi
                read -p "按任意键返回菜单"
                ;;
            2)
                check_docker || { read -p "Docker 安装失败，按任意键返回菜单"; continue; }
                batch_start_nodes
                ;;
            3)
                list_nodes
                ;;
            4)
                select_node_to_view
                ;;
            5)
                batch_uninstall_nodes
                ;;
            6)
                check_docker || { read -p "Docker 安装失败，按任意键返回菜单"; continue; }
                batch_rotate_nodes
                ;;
            7)
                uninstall_all_nodes
                ;;
            8)
                echo "感谢使用 Nexus 多节点管理工具！"
                exit 0
                ;;
            *)
                echo "无效的选项 '$choice'。请输入一个 1 到 8 之间的数字。"
                read -p "按任意键继续"
                ;;
        esac
    done
}

# ============== 脚本入口点 ==============
main_menu
