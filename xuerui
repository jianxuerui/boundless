#!/bin/bash
set -e

# =========================================================================================
# Nexus 多节点管理脚本 (ARM64专用Docker版) - 性能优化版
# 作者: 哈哈哈哈 (推特 @ferdie_jhovie)
# 优化: AI Assistant
# 描述: 此脚本使用 Docker 管理多个 Nexus 节点，特别为 ARM64 架构优化。
#       【V4 优化】:
#       1. 【资源控制】: 新增CPU和内存限制，可自由配置，避免节点占用过多系统资源。
#       2. 【镜像瘦身】: 改用 Alpine Linux 作为基础镜像，大幅减小镜像体积 (~80MB vs >200MB)。
#       3. 【进程优化】: 移除容器内 screen，采用 Docker 原生方式管理进程，更稳定、资源占用更低。
#       4. 【日志简化】: 直接利用 Docker 日志驱动，无需手动挂载日志文件，通过`docker logs`查看。
#       5. 【功能完善】: 实现了批量卸载和彻底清理功能。
#       【V3.1 更新】: 更新二进制文件下载地址至 v0.10.1。
# =========================================================================================

# --- 配置项 ---

# -- 核心配置 --
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest-arm64-optimized"
LOG_DIR="/root/nexus_logs" # 注意: 新版默认用`docker logs`，此项保留用于向后兼容或未来扩展
BUILDER_NAME="nexus_builder" # 为我们的项目创建一个专用的 builder

# -- 性能与资源配置 (请根据您的服务器性能调整) --
CPU_LIMIT="0.5" # 分配给每个容器的CPU核心数，例如 "0.5" 代表半个核心, "1" 代表一个核心
MEMORY_LIMIT="512m" # 分配给每个容器的内存上限，例如 "256m", "512m", "1g"

# --- 核心功能函数 ---

# 检查 Docker 是否安装 (与原版相同)
function check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "检测到未安装 Docker，正在为您安装..."
        # 此处使用 apt 安装，适用于 Debian/Ubuntu 系统
        apt-get update
        apt-get install -y apt-transport-https ca-certificates curl software-properties-common
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
        add-apt-repository "deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
        apt-get update
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        systemctl enable docker
        systemctl start docker
        echo "Docker 安装完成！"
    fi
    # 确保 buildx 插件可用
    if ! docker buildx version >/dev/null 2>&1; then
        echo "错误：未找到 Docker buildx 插件。请确保您的 Docker 版本包含 buildx。"
        echo "尝试安装命令: apt-get install docker-buildx-plugin"
        exit 1
    fi
}

# 设置 Buildx 以支持跨平台构建 (与原版相同)
function setup_buildx() {
    if docker buildx ls | grep -q "${BUILDER_NAME}.*running"; then
        echo "Buildx 环境 '$BUILDER_NAME' 已准备就绪。"
        docker buildx use $BUILDER_NAME
        return
    fi
    echo "检测到需要设置跨平台构建环境 (QEMU)..."
    if docker buildx ls | grep -q "$BUILDER_NAME"; then
        docker buildx inspect $BUILDER_NAME --bootstrap
    else
        docker buildx create --name $BUILDER_NAME --driver docker-container --use
    fi
    if ! docker run --rm --privileged tonistiigi/binfmt | grep -q "setting up"; then
        docker run --rm --privileged tonistiigi/binfmt --install all
    fi
    echo "Buildx 环境设置完成。"
}

# 构建 Docker 镜像 (优化版)
function build_image() {
    if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        echo "镜像 $IMAGE_NAME 已存在，跳过构建。"
        return
    fi
    
    setup_buildx
    echo "正在准备构建环境..."
    WORKDIR=$(mktemp -d)
    cd "$WORKDIR"

    # --- Dockerfile 内容开始 (优化) ---
    cat > Dockerfile <<EOF
# 【优化】使用更轻量的 Alpine 作为基础镜像
ARG TARGETPLATFORM=linux/arm64
FROM --platform=\$TARGETPLATFORM alpine:latest

# 【优化】使用apk安装依赖，--no-cache减小镜像层大小
RUN apk add --no-cache curl bash ca-certificates

# 直接从 GitHub Releases 下载指定版本 v0.10.1 的 ARM64 二进制文件。
RUN echo "正在下载 Nexus ARM64 二进制文件..." \
    && curl -L -o /usr/local/bin/nexus-network https://github.com/nexus-xyz/nexus-cli/releases/download/v0.10.1/nexus-network-linux-arm64 \
    && chmod +x /usr/local/bin/nexus-network

# 复制并设置入口点脚本
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# 设置容器启动时执行的命令
ENTRYPOINT ["/entrypoint.sh"]
EOF
    # --- Dockerfile 内容结束 ---

    # --- entrypoint.sh 内容开始 (优化) ---
    # 【优化】移除 screen，让 nexus-network 作为主进程 (PID 1)
    # 这样 Docker 可以直接管理其生命周期和日志
    cat > entrypoint.sh <<EOF
#!/bin/sh
set -e

# alpine 默认使用 sh，更轻量

if [ -z "\$NODE_ID" ]; then
    echo "错误：未通过 -e NODE_ID=... 设置环境变量！"
    exit 1
fi

echo "正在为节点 \$NODE_ID 配置身份文件..."
mkdir -p /root/.nexus
echo "\$NODE_ID" > /root/.nexus/node-id

echo "配置完成。正在启动 nexus-network 主进程..."
echo "日志将由 Docker 直接捕获, 请使用 'docker logs <容器名>' 查看"

# 使用 exec，将 shell 进程替换为 nexus-network 进程
# 这是 Docker 容器中的最佳实践
exec nexus-network start --node-id "\$NODE_ID"
EOF
    # --- entrypoint.sh 内容结束 ---

    echo "正在使用 builder '$BUILDER_NAME' 构建 Docker 镜像 $IMAGE_NAME..."
    docker buildx build --builder $BUILDER_NAME --platform linux/arm64 -t "$IMAGE_NAME" . --load

    echo "清理构建目录..."
    cd - >/dev/null
    rm -rf "$WORKDIR"
    echo "镜像 $IMAGE_NAME 构建完成！"
}

# 启动一个节点容器 (优化版)
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"

    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "检测到旧容器 $container_name，正在删除..."
        docker rm -f "$container_name"
    fi
    
    echo "正在启动容器 $container_name..."
    echo "  - CPU 限制: $CPU_LIMIT"
    echo "  - 内存限制: $MEMORY_LIMIT"
    
    # 【优化】增加 --cpus 和 --memory 参数进行资源限制
    # 【优化】移除日志卷挂载，使用 Docker 默认日志驱动
    docker run -d --name "$container_name" \
        -e NODE_ID="$node_id" \
        --cpus="$CPU_LIMIT" \
        --memory="$MEMORY_LIMIT" \
        --restart unless-stopped \
        "$IMAGE_NAME"
    
    echo "容器 $container_name 已启动！"
    echo "请使用 'docker logs -f $container_name' 查看实时日志。"
}

# --- 辅助管理函数 ---

function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    echo "正在停止并删除容器 $container_name..."
    if docker rm -f "$container_name" >/dev/null 2>&1; then
        echo "容器 $container_name 已删除。"
    else
        echo "容器 $container_name 不存在或已删除。"
    fi
    # 由于日志不再挂载到主机，不再需要删除主机日志文件
}

function list_nodes() {
    echo "--------------------------------- 当前 Nexus 节点状态 ---------------------------------"
    # 【优化】格式化输出，直接在 stats 命令中完成
    printf "%-28s %-15s %-12s %-20s\n" "节点 ID (容器名)" "状态" "CPU %" "内存使用"
    echo "-------------------------------------------------------------------------------------"
    
    # 获取所有相关容器的名字
    containers=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-*" --format "{{.Names}}")

    if [ -z "$containers" ]; then
        echo "未找到任何 Nexus 节点容器。"
    else
        # 合并 docker ps 和 docker stats 的信息
        for name in $containers; do
            # 获取状态和创建时间等信息
            info=$(docker ps -a --filter "name=$name" --format "{{.Status}}\t{{.Names}}")
            status=$(echo -e "$info" | cut -f1)
            
            node_id=$(echo "$name" | sed "s/${BASE_CONTAINER_NAME}-//")
            
            # 只有运行中的容器才有 stats
            if [[ "$status" == Up* ]]; then
                 stats=$(docker stats --no-stream --format "{{.CPUPerc}}\t{{.MemUsage}}" "$name")
                 cpu_perc=$(echo -e "$stats" | cut -f1)
                 mem_usage=$(echo -e "$stats" | cut -f2)
                 printf "%-28s %-15s %-12s %-20s\n" "$node_id ($name)" "$status" "$cpu_perc" "$mem_usage"
            else
                 printf "%-28s %-15s %-12s %-20s\n" "$node_id ($name)" "$status" "N/A" "N/A"
            fi
        done
    fi
    echo "-------------------------------------------------------------------------------------"
}


function get_all_node_ids() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-*" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//g" | sort -u
}

function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
         echo "错误：未找到节点 $node_id 的容器。"
         return 1
    fi
    echo "正在显示节点 '$node_id' 的日志... 按 Ctrl+C 退出。"
    sleep 1
    docker logs -f "$container_name"
}

function batch_start_nodes() {
    echo "请输入多个 Node ID，每行一个。输入空行或按 Ctrl+D 结束："
    local node_ids=()
    while IFS= read -r line; do
        line=$(echo "$line" | xargs)
        [ -z "$line" ] && break
        node_ids+=("$line")
    done
    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 Node ID，操作取消。"
        return
    fi
    echo "准备启动 ${#node_ids[@]} 个节点..."
    build_image
    echo "开始批量启动容器..."
    for node_id in "${node_ids[@]}"; do
        run_container "$node_id"
        sleep 1
    done
    echo "所有节点启动任务已提交！"
}

# 选择节点执行操作 (与原版相同)
function select_node_for_action() {
    local action_callback=$1
    local prompt_message=$2
    local all_nodes=($(get_all_node_ids))
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有可操作的节点。"
        read -p "按任意键返回..."
        return
    fi
    echo "请选择要'$prompt_message'的节点："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        printf "%2d. 节点 %-25s\n" $((i+1)) "${all_nodes[$i]}"
    done
    read -rp "请输入选项 (0-${#all_nodes[@]}): " choice
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt ${#all_nodes[@]} ]; then
        echo "无效的选项，请重试。"
        sleep 1
        return
    fi
    [ "$choice" -eq 0 ] && return
    local selected_node_id=${all_nodes[$((choice-1))]}
    "$action_callback" "$selected_node_id"
}

# 【新功能】批量卸载节点
function batch_uninstall_nodes() {
    local all_nodes=($(get_all_node_ids))
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有可卸载的节点。"
        read -p "按任意键返回..."
        return
    fi

    echo "警告：此操作将停止并删除以下所有节点容器："
    printf " - %s\n" "${all_nodes[@]}"
    read -rp "确定要继续吗？ [y/N]: " confirmation
    if [[ "$confirmation" != "y" && "$confirmation" != "Y" ]]; then
        echo "操作已取消。"
        return
    fi
    
    echo "正在批量卸载节点..."
    for node_id in "${all_nodes[@]}"; do
        uninstall_node "$node_id"
    done
    echo "所有节点已卸载。"
    read -p "按任意键返回菜单..."
}

# 【新功能】卸载所有节点并删除镜像
function uninstall_all_nodes_and_image() {
    echo "!!!!!! 极度危险操作 !!!!!! "
    echo "此操作将:"
    echo "1. 停止并删除所有本脚本创建的 Nexus 节点容器。"
    echo "2. 删除 Docker 镜像 $IMAGE_NAME。"
    
    read -rp "请再次确认是否要执行此毁灭性操作 [输入 'yes' 确认]: " confirmation
    if [ "$confirmation" != "yes" ]; then
        echo "操作已取消。"
        return
    fi

    # 卸载所有节点
    local all_nodes=($(get_all_node_ids))
     if [ ${#all_nodes[@]} -gt 0 ]; then
        echo "正在卸载所有节点容器..."
        for node_id in "${all_nodes[@]}"; do
            uninstall_node "$node_id"
        done
        echo "所有节点容器已删除。"
    else
        echo "没有找到需要卸载的节点容器。"
    fi

    # 删除镜像
    if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        echo "正在删除 Docker 镜像 $IMAGE_NAME..."
        if docker rmi -f "$IMAGE_NAME"; then
            echo "镜像 $IMAGE_NAME 已成功删除。"
        else
            echo "错误：删除镜像 $IMAGE_NAME 失败。"
        fi
    else
        echo "镜像 $IMAGE_NAME 不存在，无需删除。"
    fi
    
    echo "完全清理完成。"
    read -p "按任意键返回菜单..."
}


# --- 主菜单循环 ---
function main_menu() {
    while true; do
        clear
        echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
        echo "=============== Nexus 多节点管理 (ARM64 Docker版) - V4 优化版 ==============="
        echo "1. 安装/启动单个节点"
        echo "2. 批量安装/启动多个节点"
        echo "3. 查看指定节点日志"
        echo "4. 卸载指定节点"
        echo "5. 【新】批量卸载所有节点"
        echo "6. 【新】卸载所有节点并删除镜像 (危险!)"
        echo "7. 退出脚本"
        echo "-------------------------------------------------------------------------------------"
        echo "当前资源限制: CPU=${CPU_LIMIT}, 内存=${MEMORY_LIMIT}"
        echo "====================================================================================="
        list_nodes

        read -rp "请输入选项(1-7): " choice

        case $choice in
            1)
                read -rp "请输入您的 Node ID: " NODE_ID
                if [ -z "$NODE_ID" ]; then
                    echo "Node ID 不能为空！"
                else
                    build_image
                    run_container "$NODE_ID"
                fi
                read -p "操作完成，按任意键返回菜单..."
                ;;
            2)
                batch_start_nodes
                read -p "操作完成，按任意键返回菜单..."
                ;;
            3)
                select_node_for_action "view_node_logs" "查看日志"
                ;;
            4)
                select_node_for_action "uninstall_node" "卸载"
                read -p "操作完成，按任意键返回..."
                ;;
            5)
                batch_uninstall_nodes
                ;;
            6)
                uninstall_all_nodes_and_image
                ;;
            7)
                echo "退出脚本。"
                exit 0
                ;;
            *)
                echo "无效选项，请重新输入。"
                sleep 1
                ;;
        esac
    done
}

# --- 脚本执行入口 ---
check_docker
main_menu
