#!/bin/bash
#===============================================================================
#
#        FILE: nexus_manager.sh
#
#        USAGE: ./nexus_manager.sh
#
#      DESCRIPTION: Manages Nexus nodes using Docker, including deployment,
#                   monitoring, and scaling.
#
#       AUTHOR: 哈哈哈哈 (Github/Twitter: @ferdie_jhovie)
#       VERSION: 1.4.0
#     LAST CHANGE: 2024-07-26 (Refined compatibility and PM2 usage)
#
#===============================================================================

set -e # Exit immediately if a command exits with a non-zero status.

# --- 全局配置 ---
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs"
PROVER_ID_FILE="/root/.nexus/node-id" # 保持与 entrypoint 一致

# --- 内存自动分配相关配置 ---
# 容器内存分配比例（例如，占宿主机总内存的比例，例如 0.25 代表 1/4）
CONTAINER_MEM_RATIO=0.25
# 容器内存最大限制 (MB)，避免单个节点占用过多资源
CONTAINER_MEM_MAX_MB=8192  # 8GB
# 容器内存最小限制 (MB)，确保节点至少有基础运行内存
CONTAINER_MEM_MIN_MB=2048  # 2GB
# --- 配置结束 ---

# --- Helper Functions ---

# -----------------------------------------------------------------------------
# 函数：install_utility_if_not_exists
# 描述：检查一个实用程序是否存在，如果不存在则尝试安装。
# 参数：$1 - 实用程序的名称（如 jq, bc, docker-ce 等）
#       $2 - 对应的包管理器包名（有时与实用程序名不同）
#       $3 - 指定命令名称，如果与实用程序名不同（如 docker 对应 docker-ce）
# 返回：0 - 存在或安装成功, 1 - 失败
# -----------------------------------------------------------------------------
function install_utility_if_not_exists() {
    local utility=$1
    local package_name=${2:-$utility} # 如果没指定第二个参数，则包名就是命令名
    local cmd_to_check=${3:-$utility} # 如果没指定第三个参数，则检查命令名就是命令名

    if ! command -v "$cmd_to_check" &>/dev/null; then
        echo "检测到未安装 '$utility' (命令: '$cmd_to_check')，正在尝试安装包 '$package_name'..."

        local apt_install=""
        local yum_install=""
        local dnf_install=""

        case "$(id -n -g 1000)" in # 粗略判断是不是普通用户，非root也提示权限
            root) ;; # root用户不打印这个
            *) echo "警告: 以非root用户身份运行，安装软件包可能需要 sudo 权限。" ;;
        esac

        if command -v apt-get &>/dev/null; then # Debian/Ubuntu
            apt_install="sudo apt-get update -qq && sudo apt-get install -y -qq \"$package_name\""
        elif command -v yum &>/dev/null; then # CentOS/RHEL
            yum_install="sudo yum install -y \"$package_name\""
        elif command -v dnf &>/dev/null; then # Fedora/RHEL 8+
            dnf_install="sudo dnf install -y \"$package_name\""
        else
            echo "错误: 当前系统不支持自动安装 '$utility'。请手动安装包 '$package_name'。"
            return 1
        fi

        if ! eval "$apt_install$yum_install$dnf_install"; then
            echo "错误: 安装 '$package_name' 失败！请手动安装并重试。"
            return 1
        fi

        if ! command -v "$cmd_to_check" &>/dev/null; then
            echo "错误: 安装 '$package_name' 后仍找不到 '$cmd_to_check' 命令。"
            return 1
        else
            echo "'$utility' (命令: '$cmd_to_check') 已成功安装。"
            return 0
        fi
    fi
    echo "'$utility' (命令: '$cmd_to_check') 已存在。"
    return 0
}

# -----------------------------------------------------------------------------
# 函数：check_docker
# 描述：确保 Docker 已安装并运行。
# -----------------------------------------------------------------------------
function check_docker() {
    if ! command -v docker &>/dev/null; then
        echo "检测到未安装 Docker，正在安装..."
        # 优先使用更现代、更通用的 Docker 安装脚本，减少对特定 OS 版本依赖
        # https://docs.docker.com/engine/install/ubuntu/  -> Add Docker's official GPG key and repository
        # 使用 get.docker.com 脚本可以更好地适配各种 Linux 发行版

        if ! install_utility_if_not_exists "curl"; then echo "安装 curl 失败，请检查您的网络或手动安装 curl."; return 1; fi
        if ! install_utility_if_not_exists "gpg"; then echo "安装 gpg 失败，请检查您的网络或手动安装 gpg."; return 1; fi

        # 确保 docker.io 作为软件包名时也受支持
        install_utility_if_not_exists "docker" "docker-ce" "docker" || \
        install_utility_if_not_exists "docker" "docker.io" "docker"

        # 如果上面一种安装方式失败，我们尝试使用官方 get.docker.com 的脚本，通常会尝试安装最新版本
        if ! command -v docker &>/dev/null; then
            echo "尝试使用 get.docker.com 脚本安装 Docker..."
            # 添加 Docker 的官方 GPG 密钥和软件源
            if ! install_utility_if_not_exists "wget" "wget"; then echo "安装 wget 失败，请手动安装 wget"; return 1; fi
            
            # 一次性安装和配置
            # 如果系统是 debian-like
            if command -v apt-get &>/dev/null; then
                # 确保必要的工具被安装
                sudo apt-get update -qq
                sudo apt-get install -y -qq ca-certificates curl gnupg
                sudo install -m 0755 -d /etc/apt/keyrings
                curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                sudo chmod a+r /etc/apt/keyrings/docker.gpg
                echo \
                  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
                  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
                  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                sudo apt-get update -qq
                sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            elif command -v yum &>/dev/null || command -v dnf &>/dev/null; then # 尝试安装 CentOS/RHEL
                local package_manager=$(command -v dnf &>/dev/null && echo "dnf" || echo "yum")
                sudo "$package_manager" update -y
                sudo "$package_manager" install -y -q container-tools
            else
                echo "错误：无法确定您的 Linux 发行版以自动安装 Docker。"
                return 1
            fi

            if ! command -v docker &>/dev/null; then
                echo "Docker 安装失败！"
                return 1
            fi
        fi

        # 启用并启动 Docker 服务 (针对 systemd 系统)
        if command -v systemctl &>/dev/null; then
            if ! sudo systemctl is-enabled docker &>/dev/null; then
                sudo systemctl enable docker
            fi
            if ! sudo systemctl is-active docker &>/dev/null; then
                sudo systemctl start docker
            fi
            echo "Docker 服务已启动。"
        else
            echo "警告: 无法使用 systemctl 启动或启用 Docker 服务，请检查 Docker 手动启动。"
        fi
    else
        echo "Docker 已安装并可用。"
    fi

    # 再次检查 Docker 服务状态
    if ! sudo systemctl is-active docker &>/dev/null; then
        echo "错误: Docker 服务未运行。请尝试手动启动 Docker ('sudo systemctl start docker')。"
        return 1
    fi
    
    # 允许当前用户运行 Docker 命令 (如果当前用户不是 root 且不在 docker 用户组中)
    if ! id -nG $(id -u) | grep -q 'docker'; then
        echo "检测到当前用户不在 'docker' 用户组中，尝试将其添加到组..."
        if sudo usermod -aG docker $(id -un); then
            echo "成功将当前用户 '$(id -un)' 添加到 'docker' 用户组。"
            echo "请注销并重新登录，或在新开一个终端，以使组更改生效。"
        else
            echo "警告: 无法自动将当前用户添加到 'docker' 组。请手动执行 'sudo usermod -aG docker $(id -un)'，然后重新登录，或以 root 身份运行此脚本。"
        fi
    fi

    echo "Docker 已准备就绪。"
    return 0
}

# -----------------------------------------------------------------------------
# 函数：check_nodejs_and_pm2
# 描述：确保 Node.js 和 npm 已安装，PM2 是用于轮换脚本的管理工具。
# -----------------------------------------------------------------------------
function check_nodejs_and_pm2() {
    if ! command -v node &>/dev/null || ! command -v npm &>/dev/null; then
        echo "检测到未安装 Node.js/npm，正在安装..."
        if command -v apt-get &>/dev/null; then
            # 使用 NodeSource 安装 LTS 版本（当前推荐是 18.x 或 20.x）
            local node_version="18.x" # 考虑根据实际情况更新 LTS 版本
            if ! curl -fsSL "https://deb.nodesource.com/setup_${node_version}" | sudo -E bash -; then
                echo "从 NodeSource 安装 Node.js 的配置失败。"
                return 1
            fi
            sudo apt-get update -qq
            if ! sudo apt-get install -y -qq nodejs; then
                echo "安装 Node.js 失败。"
                return 1
            fi
        elif command -v yum &>/dev/null || command -v dnf &>/dev/null; then
            local package_manager=$(command -v dnf &>/dev/null && echo "dnf" || echo "yum")
            echo "注意: 自动安装 Node.js 在 RPM 系发行版上可能需要从 NodeSource 或直接编译安装，脚本仅提供基础支持。"
            echo "建议您根据发行版教程手动安装 Node.js."
            # 简单的安装方法，可能不是最新的 LTS 版本，具体取决于你的 YUM/DNF 源
            sudo "$package_manager" install -y nodejs || echo "安装 Node.js 命令失败，请手动安装。"
        else
            echo "无法自动安装 Node.js。请手动安装 Node.js (npm 包括在内)。"
            return 1
        fi
        if ! command -v node &>/dev/null || ! command -v npm &>/dev/null; then
            echo "Node.js 或 npm 安装失败。"
            return 1
        else
            echo "Node.js 和 npm 已安装。"
        fi
    fi
    
    if ! command -v pm2 &>/dev/null; then
        echo "检测到未安装 pm2，正在全局安装..."
        # 需要 Node.js 和 npm
        if ! sudo npm install -g pm2; then
            echo "安装 pm2 失败！"
            return 1
        else
            echo "pm2 已全局安装成功。"
        fi
    fi
    echo "Node.js, npm, 和 pm2 已准备就绪。"
    return 0
}

# -----------------------------------------------------------------------------
# 函数：build_image
# 描述：构建 Nexus Docker 镜像。
# -----------------------------------------------------------------------------
function build_image() {
    if docker images -q "$IMAGE_NAME" 2>/dev/null | grep -q .; then
        echo "Docker 镜像 '$IMAGE_NAME' 已存在，跳过构建。"
        # 这里可以选择是否需要强制重新构建。如果用户需要总是最新，则移除这个检查。
        return 0
    fi

    echo "开始构建 Nexus Docker 镜像 (Image Name: ${IMAGE_NAME})..."
    local WORKDIR
    if ! WORKDIR=$(mktemp -d); then
        echo "错误: 创建临时目录失败！"
        return 1
    fi
    
    echo "使用临时目录: $WORKDIR"
    cd "$WORKDIR" || return 1

    # 创建 Dockerfile
    cat > Dockerfile <<EOF
# Use a minimal base image like Ubuntu for better compatibility.
# ConsiderAlpine if space is a concern, but Ubuntu is often simpler for user installation.
FROM ubuntu:24.04

LABEL maintainer="哈哈哈哈 <哈哈哈哈@example.com>"
LABEL version="1.0"

# Set debconf to noninteractive to avoid prompts during apt installs.
ENV DEBIAN_FRONTEND=noninteractive
# Ensure PROVER_ID_FILE path is consistent
ENV PROVER_ID_FILE="/root/.nexus/node-id"

# Install essential packages, including curl for downloading.
# Clean up apt cache to reduce image size.
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    bash \
    ca-certificates \
    && echo "Essential packages installed." \
    && rm -rf /var/lib/apt/lists/*

# Download and install the latest Nexus network CLI.
# Using NONINTERACTIVE=1 env var to automate the installation process.
RUN curl -fsSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh \
    && if [ ! -f /root/.nexus/bin/nexus-network ]; then \
           echo "Error: nexus-network binary not found after installation script."; \
           exit 1; \
       fi \
    && ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network \
    && echo "Nexus network installed successfully." \
    && rm -rf /root/.nexus # Clean up downloaded installation files to reduce layer size

# Copy entrypoint script and make it executable.
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh \
    && echo "Entrypoint script prepared."

# The entrypoint script will handle starting the Nexus node.
ENTRYPOINT ["/entrypoint.sh"]

# Keep container running with a simple command, or let the entrypoint handle it.
# CMD ["tail", "-f", "/dev/null"] # Can be used if entrypoint doesn't keep it running
EOF

    # 创建 entrypoint.sh
    cat > entrypoint.sh <<EOF
#!/bin/bash
# Set trap to call cleanup logic on exit
trap cleanup EXIT

cleanup() {
    echo "清理 Nexus Node..."
    # Consider stopping services managed by screen if they are critical to stop gracefully
    screen -S nexus -X quit >/dev/null 2>&1 || true
    # Ensure container exits cleanly if needed, but 'set -e' already handles this for script failure.
}

# Use Nexus's standard installation directory for node ID.
# ENV PROVER_ID_FILE="/root/.nexus/node-id" # Defined in Dockerfile for build time, not runtime usually.

if [ -z "\$NODE_ID" ]; then
    echo "Error: NODE_ID environment variable is not set."
    echo "Please ensure your 'docker run' command includes -e NODE_ID=<your_node_id>"
    exit 1
fi

# Ensure Nexus's working directory and the node-id file exist.
# The nexus-network install script should have created /root/.nexus
mkdir -p /root/.nexus
echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo "Node ID set to: \$NODE_ID (Stored in \$PROVER_ID_FILE)"

# Verify nexus-network is accessible
if ! command -v nexus-network &>/dev/null; then
    echo "Error: 'nexus-network' command not found."
    echo "Please check the Dockerfile and Nexus installation steps for errors."
    exit 1
fi

echo "Starting Nexus network node..."

# Use 'screen' to run nexus-network in the background,
# redirecting all its stdout and stderr to nexus.log.
# The -d flag runs in detached mode, and -S names the session 'nexus'.
# Redirect output: '&>>' appends to both stdout and stderr.
# The node needs to be started in a shell context to be picked up by screen correctly.
screen -dmS nexus bash -c "exec nexus-network start --node-id \"\$NODE_ID\" >> /root/nexus.log 2>&1"

# Wait a few seconds for the node to initialize and start
sleep 5

# Check if the screen session is active. If not, something went wrong.
if ! screen -list | grep -q "nexus"; then
    echo "Error: Failed to start Nexus node in screen session."
    echo "Checking Nexus log for details:"
    cat /root/nexus.log
    exit 1
fi

echo "Nexus node started successfully in detached screen session 'nexus'."
echo "Container will keep running. Access logs via 'docker logs \$HOSTNAME' or '/root/nexus.log' within the container."

# Keep the container running.
# The 'screen -dmS nexus' command might daemonize and exit, so we need something to keep the container alive.
# 'tail -f /dev/null' is a common pattern to keep a container running indefinitely.
# If nexus-network itself daemonizes properly and runs indefinitely, this might be redundant or even conflict.
# Let's try to rely on nexus-network itself if screen manages it properly, but use tail as fallback.
echo "Keeping container alive..."
# If screen detaches successfully and nexus-network runs, this tail won't run as nexus-network would exit the script
# If nexus-network fails, screen session might terminate and then this would execute.
# A more robust approach would be to have nexus-network foreground the process, but that might be out of scope for this script's modification.
tail -f /dev/null

EOF

    # Build the Docker image. The --platform linux/amd64 is good practice if you're on an M1/M2 Mac and need to build x86 images.
    # For general compatibility, it's fine without unless targeting specific architectures.
    if ! docker build --platform linux/amd64 -t "$IMAGE_NAME" .; then
        echo "错误: Docker 镜像构建失败！"
        cd - > /dev/null
        rm -rf "$WORKDIR"
        return 1
    fi

    cd - > /dev/null
    rm -rf "$WORKDIR"
    echo "Nexus Docker 镜像构建成功！ (Image Name: ${IMAGE_NAME})"
    return 0
}

# -----------------------------------------------------------------------------
# 函数：get_host_memory
# 描述：获取宿主机的总内存和可用内存（以 MB 为单位）。
# 返回值：以空格分隔的总内存 (MB) 和可用内存 (MB)。
# -----------------------------------------------------------------------------
function get_host_memory() {
    local total_mem_kb=0
    local available_mem_kb=0

    # 尝试从 /proc/meminfo 获取内存信息
    if [ -f /proc/meminfo ]; then
        if grep -q "MemTotal" /proc/meminfo; then
            total_mem_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        fi
        if grep -q "MemAvailable" /proc/meminfo; then
            available_mem_kb=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
        fi
    fi

    # 如果 MemAvailable 未获取到（比如旧系统），尝试使用 MemFree 作为备用
    if [ -z "$available_mem_kb" ] || [ "$available_mem_kb" -le 0 ]; then
        if [ -f /proc/meminfo ] && grep -q "MemFree" /proc/meminfo; then
            available_mem_kb=$(grep MemFree /proc/meminfo | awk '{print $2}')
        fi
    fi

    # 将 KB 转换为 MB，使用 bash 的整数运算
    local total_mem_mb=$((total_mem_kb / 1024))
    local available_mem_mb=$((available_mem_kb / 1024))

    # 确保返回的值是数字且不为负，避免错误计算
    if [ -z "$total_mem_mb" ] || (( total_mem_mb < 0 )); then total_mem_mb=0; fi
    if [ -z "$available_mem_mb" ] || (( available_mem_mb < 0 )); then available_mem_mb=0; fi

    echo "$total_mem_mb $available_mem_mb"
}

# -----------------------------------------------------------------------------
# 函数：run_container
# 描述：启动一个 Nexus 节点容器。
# 参数：$1 - 节点的唯一 ID
# 返回值：0 - 启动成功, 1 - 启动失败
# -----------------------------------------------------------------------------
function run_container() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    # 检查容器是否已存在并清理旧容器
    if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        echo "检测到已存在的容器 '$container_name'，正在尝试停止并删除..."
        if ! docker rm -f "$container_name" &>/dev/null; then
            echo "警告: 删除旧容器 '$container_name' 失败。请手动检查（可能正在运行或被占用）。"
            # 可以选择在这里返回错误，或者尝试继续，但可能导致名称冲突
            # return 1
        else
            echo "旧容器 '$container_name' 已成功移除。"
        fi
    fi

    # 确保宿主机的日志目录存在
    if ! mkdir -p "$LOG_DIR"; then
        echo "错误: 无法创建日志目录 '$LOG_DIR'。请检查权限。"
        return 1
    fi
    
    # 确保宿主机的日志文件存在且可写，用于 Docker logs 的文件挂载（虽然Docker log是stdout/stderr捕获，但我们为了宿主机也能看到）
    # 这里实际的作用是给容器内部的 `/root/nexus.log` 提供一个基础的宿主机文件路径进行挂载。
    # 如果容器内生成的 /root/nexus.log 不覆盖宿主机挂载文件，效果就是宿主机日志文件会被容器进程追加内容
    if ! touch "$log_file" &>/dev/null || ! chmod 644 "$log_file" &>/dev/null; then
        echo "警告: 无法创建或修改宿主机日志文件 '$log_file'。容器内日志将挂载，但宿主机文件可能不可写。"
    fi

    # --- 计算容器内存限制 ---
    local host_total_mem_mb
    local host_available_mem_mb
    read host_total_mem_mb host_available_mem_mb <<< $(get_host_memory)

    if [ -z "$host_total_mem_mb" ] || [ "$host_total_mem_mb" -le 0 ] || [ -z "$host_available_mem_mb" ]; then
        echo "错误: 无法获取宿主机内存信息（总/可用: ${host_total_mem_mb}/${host_available_mem_mb} MB）。无法计算内存分配。"
        return 1
    fi

    if ! install_utility_if_not_exists "bc"; then
        echo "错误: 'bc' 工具未安装，无法精确计算内存分配。请安装 'bc' 并重试。"
        return 1
    fi

    # 计算基于总内存比例的内存值
    # bc浮点运算，printf %.0f 四舍五入成整数
    local allocated_mem_float=$(echo "$host_total_mem_mb * $CONTAINER_MEM_RATIO" | bc)
    local allocated_mem_mb=$(printf "%.0f" "$allocated_mem_float")

    # 确保内存值在配置的最小和最大限制之间
    if (( allocated_mem_mb > CONTAINER_MEM_MAX_MB )); then
        allocated_mem_mb="$CONTAINER_MEM_MAX_MB"
    fi
    if (( allocated_mem_mb < CONTAINER_MEM_MIN_MB )); then
        allocated_mem_mb="$CONTAINER_MEM_MIN_MB"
    fi

    # 最终的安全检查：确保分配的内存不超过宿主机当前可用内存
    if (( allocated_mem_mb > host_available_mem_mb )); then
        echo "警告: 根据配置比例计算出的内存分配量 (${allocated_mem_mb}MB) 可能大于当前宿主机可用内存 (${host_available_mem_mb}MB)。"
        echo "尝试将分配量调整为可用内存的 90%（仍保证至少 ${CONTAINER_MEM_MIN_MB}MB）。"
        
        local available_adjusted_float=$(echo "$host_available_mem_mb * 0.9" | bc)
        allocated_mem_mb=$(printf "%.0f" "$available_adjusted_float")

        # 再次确保不会低于最小值
        if (( allocated_mem_mb < CONTAINER_MEM_MIN_MB )); then
            allocated_mem_mb="$CONTAINER_MEM_MIN_MB"
        fi

        # 如果调整后仍然无法满足最小要求，则报错退出
        if (( allocated_mem_mb > host_available_mem_mb )); then
            echo "错误: 宿主机当前可用内存 (${host_available_mem_mb}MB) 不足以满足节点 '$node_id' 的最小内存要求 (${allocated_mem_mb}MB)。请释放宿主机资源或调整脚本内存配置。"
            return 1
        fi
    fi
    
    echo "为节点 '$node_id' 分配内存: ${allocated_mem_mb}MB (宿主机可用 ${host_available_mem_mb}MB)"

    # 执行 Docker run 命令
    # -d: 后台运行
    # --name: 容器名称
    # -m: 内存限制
    # -v: 挂载宿主机日志文件到容器内的 /root/nexus.log
    # -e NODE_ID: 传递 Node ID 作为环境变量给 entrypoint 脚本
    # "$IMAGE_NAME": 使用的 Docker 镜像
    echo "运行命令: docker run -d --name \"$container_name\" -m ${allocated_mem_mb}m -v \"$log_file:/root/nexus.log\" -e NODE_ID=\"$node_id\" \"$IMAGE_NAME\""
    if ! docker run -d --name "$container_name" -m "${allocated_mem_mb}m" -v "$log_file:/root/nexus.log" -e NODE_ID="$node_id" "$IMAGE_NAME"; then
        echo "错误: 启动容器 '$container_name' 失败。"
        return 1
    fi

    echo "容器 '$container_name' (Node ID: $node_id) 已成功启动！"
    return 0
}

# -----------------------------------------------------------------------------
# 函数：get_all_nodes
# 描述：获取所有已创建（无论运行中或已停止）的 Nexus 节点 ID。
# 返回值：节点 ID 列表，每行一个。
# -----------------------------------------------------------------------------
function get_all_nodes() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort -u
}

# -----------------------------------------------------------------------------
# 函数：get_running_nodes
# 描述：获取所有正在运行的 Nexus 节点 ID。
# 返回值：运行中节点 ID 列表，每行一个。
# -----------------------------------------------------------------------------
function get_running_nodes() {
    docker ps --filter "name=${BASE_CONTAINER_NAME}" --filter "status=running" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort -u
}

# -----------------------------------------------------------------------------
# 函数：list_nodes
# 描述：列出所有节点的状态。
# -----------------------------------------------------------------------------
function list_nodes() {
    local all_nodes_names=($(docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" 2>/dev/null || true))

    if [ ${#all_nodes_names[@]} -eq 0 ]; then
        echo "当前系统中未发现任何 Nexus 节点。"
        echo "----------------------------------------"
        read -p "按任意键返回主菜单..."
        return
    fi
    
    echo "==================== Nexus 节点列表 ===================="
    echo "序号  节点ID                容器名称                状态            内存限制 (MB) 内存使用"
    echo "------------------------------------------------------------------------------------------"

    # 使用 sort -V 对 Node ID 进行版本号排序，这样 1, 2, 10 会排对
    local sorted_node_ids=($(printf "%s\n" "${all_nodes_names[@]}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort -uV))

    for i in "${!sorted_node_ids[@]}"; do
        local node_id=${sorted_node_ids[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        
        local node_status="未知"
        local container_id=""
        local container_state=""
        local memory_limit=""
        local memory_usage=""

        if container_id=$(docker ps -a --filter "name=${container_name}" --format "{{.ID}}" 2>/dev/null); then
            container_state=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}" 2>/dev/null)
            # 获取内存限制和使用情况，只有在容器运行中才能获取到（-a 会显示Stopped）
            # 对于Stopped容器，-m参数显示的是运行时的限制，usage显示0
            if docker ps -a --filter "name=${container_name}" &>/dev/null; then
                local container_info=$(docker inspect --format='{{.HostConfig.Memory}} {{.State.Running}} {{.Id}}' "$container_name" 2>/dev/null)
                if [ -n "$container_info" ]; then
                    local mem_bytes=$(echo "$container_info" | awk '{print $1}')
                    local is_running=$(echo "$container_info" | awk '{print $2}')
                    local id=$(echo "$container_info" | awk '{print $3}')

                    if [ -n "$mem_bytes" ] && ((mem_bytes > 0)); then
                        memory_limit=$((mem_bytes / 1024 / 1024)) # Convert bytes to MB
                    fi

                    if [ "$is_running" = "true" ]; then
                        # 获取运行时内存使用，单位 MB
                        local mem_usage_bytes=$(docker stats --no-stream "$container_name" | awk 'NR==2 {print $4}' | sed 's/[^0-9.]//g') # Removes 'MiB', 'GiB', etc. and unit characters. Assuming bytes by default if no suffix, or handle suffixes if available in 'docker stats' output.
                        # 'docker stats' output unit is usually bytes if no M/G/T is present or if units are bytes, or it depends on docker version.
                        # Let's rely on a more explicit parsing if needed. Often 'docker stats' returns in MB by default.
                        # The previous regex might remove useful decimal points, let's re-parse to be more precise.
                        # Fetching just memory bytes, and handling possible units (KiB, MiB, GiB)
                        mem_usage_bytes=$(docker stats --no-stream "$container_name" | awk 'NR==2 {print $4}' | sed -e 's/[^0-9.]*//g' -e 's/MiB//' -e 's/GiB//' -e 's/KiB//' -e 's/TiB//')

                        # Crude conversion based on what we might see. Usually docker stats uses MiB by default.
                        # If 'M' is present in raw output and not removed, process.
                        # Simpler approach: trust 'docker stats' output formatting or ensure a consistent unit.
                        # Example 'docker stats' output for MEM USAGE / LIMIT: 12.3MiB / 8.00GiB
                        # We want the usage part in MiB.
                        local mem_usage_raw=$(docker stats --no-stream "$container_name" | awk 'NR==2 {print $4}')
                        if [[ "$mem_usage_raw" == *"GiB"* ]]; then
                            mem_usage_bytes=$(echo "$mem_usage_raw" | sed 's/GiB//' | awk '{print $1 * 1024}') # GiB to MiB
                        elif [[ "$mem_usage_raw" == *"MiB"* ]]; then
                            mem_usage_bytes=$(echo "$mem_usage_raw" | sed 's/MiB//' | awk '{print $1}')
                        elif [[ "$mem_usage_raw" == *"KiB"* ]]; then
                            mem_usage_bytes=$(echo "$mem_usage_raw" | sed 's/KiB//' | awk '{print $1 / 1024}') # KiB to MiB
                        else
                            # Assume bytes if no unit. Less likely with docker stats.
                            mem_usage_bytes=$(echo "$mem_usage_raw" | sed 's/[^0-9.]//g') # Only numbers
                            # No easy conversion without knowing unit, assume we already got numbers if they are there.
                        fi
                        memory_usage=$(printf "%.2f" $mem_usage_bytes)
                    fi
                fi
            fi
            # Print results
            printf "%-5s %-25s %-25s %-15s %-12s %-10s\n" $((i+1)) "$node_id" "$container_name" "$container_state" "${memory_limit:-N/A}" "${memory_usage:-N/A} MiB"
        else
            printf "%-5s %-25s %-25s %-15s %-12s %-10s\n" $((i+1)) "$node_id" "$container_name" "不存在" "N/A" "N/A"
        fi
    done
    echo "=================================================================================="
    read -p "按任意键返回主菜单..."
}

# -----------------------------------------------------------------------------
# 函数：uninstall_node
# 描述：停止并卸载指定节点（删除容器、宿主机日志文件）。
# 参数：$1 - 节点的唯一 ID
# -----------------------------------------------------------------------------
function uninstall_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "正在处理节点 '$node_id' (容器: '$container_name')..."
    
    # 首先尝试停止并删除容器
    if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        echo "正在停止并删除容器 '$container_name'..."
        if ! docker rm -f "$container_name" &>/dev/null; then
            echo "警告: 删除容器 '$container_name' 失败。请检查是否运行中或被占用。"
        else
            echo "容器 '$container_name' 已成功停止并删除。"
        fi
    else
        echo "容器 '$container_name' 不存在，无需删除。"
    fi

    # 删除宿主机的日志文件
    if [ -f "$log_file" ]; then
        echo "正在删除宿主机日志文件 '$log_file'..."
        if ! rm -f "$log_file"; then
            echo "警告: 删除日志文件 '$log_file' 失败。请检查权限。"
        else
            echo "宿主机日志文件 '$log_file' 已删除。"
        fi
    else
        echo "宿主机日志文件 '$log_file' 不存在。"
    fi
    
    echo "节点 '$node_id' 的清理工作完成。"
    return 0
}

# -----------------------------------------------------------------------------
# 函数：batch_uninstall_nodes
# 描述：列出所有节点，允许用户选择批量停止并卸载节点。
# -----------------------------------------------------------------------------
function batch_uninstall_nodes() {
    local all_nodes=($(printf "%s\n" $(get_all_nodes) | sort -uV)) # Ensure sorted
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有已创建的 Nexus 节点可供卸载。"
        read -p "按任意键返回主菜单..."
        return
    fi

    echo "================== 批量卸载节点 ==================="
    echo "可用 Nexus 节点列表:"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status="不存在"
        if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
             status=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}")
        fi
        printf "%3d. 节点ID: %-25s | 状态: %s\n" $((i+1)) "$node_id" "$status"
    done
    echo "--------------------------------------------------"
    echo "0. 返回主菜单"
    echo "all. 卸载所有列出的节点"
    echo ""
    echo "请输入要卸载节点的序号 (例如: 1 3 5) 或输入 'all' 卸载所有。"
    
    read -rp "请输入您的选择: " choices

    # 如果选择了 0, 直接返回
    if [ "$choices" == "0" ]; then
        echo "已取消卸载操作，返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    # 如果选择了 'all'
    if [ "$choices" == "all" ]; then
        echo "您已选择卸载所有节点！"
        read -rp "请再次确认，输入 'yes' 继续: " confirm_all
        if [ "$confirm_all" == "yes" ]; then
            echo "开始卸载所有节点..."
            for node_id in "${all_nodes[@]}"; do
                uninstall_node "$node_id"
            done
            echo "所有节点的卸载操作已完成。"
        else
            echo "已取消卸载所有节点的操作。"
        fi
        read -p "按任意键继续..."
        return
    fi

    # 处理多个序号输入
    IFS=' ' read -r -a selected_indices <<< "$choices"
    local successful_uninstall_count=0
    local failed_uninstall_count=0

    for index_str in "${selected_indices[@]}"; do
        # Trim whitespace
        index_str=$(echo "$index_str" | xargs)
        
        if [[ "$index_str" =~ ^[0-9]+$ ]]; then
            local index_num=$((index_str))
            
            # Check if the index is valid
            if [ "$index_num" -ge 1 ] && [ "$index_num" -le ${#all_nodes[@]} ]; then
                local selected_node_id=${all_nodes[$((index_num-1))]}
                echo "正在执行卸载操作: Node ID '${selected_node_id}'"
                if uninstall_node "$selected_node_id"; then
                    ((successful_uninstall_count++))
                else
                    ((failed_uninstall_count++))
                fi
            else
                echo "警告: 序号 '$index_str' 无效，节点列表中不存在该序号。"
            fi
        else
            echo "警告: 输入 '$index_str' 不是一个有效的序号，已跳过。"
        fi
    done

    echo "--------------------------------------------------"
    if [ "$successful_uninstall_count" -gt 0 ]; then
        echo "$successful_uninstall_count 个节点卸载成功。"
    fi
    if [ "$failed_uninstall_count" -gt 0 ]; then
        echo "$failed_uninstall_count 个节点的卸载操作遇到问题。"
    fi
    if [ ${#selected_indices[@]} -eq 0 ] || [ $(echo "$choices" | wc -w) -eq 0 ]; then
        echo "没有选择任何节点进行卸载。"
    fi

    read -p "按任意键返回主菜单..."
}

# -----------------------------------------------------------------------------
# 函数：select_node_to_view
# 描述：让用户选择一个节点来查看其日志。
# -----------------------------------------------------------------------------
function select_node_to_view() {
    local all_nodes=($(printf "%s\n" $(get_all_nodes) | sort -uV)) # Ensure sorted
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有已创建的 Nexus 节点。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "请选择要查看日志的节点："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status="不存在"
        
        if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
             status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}")
        fi
        
        if [[ "$status" == Up* ]]; then
            echo "$((i+1)). 节点 '$node_id' [运行中]"
        else
            echo "$((i+1)). 节点 '$node_id' [已停止:$status]"
        fi
    done

    read -rp "请输入选项 (0-${#all_nodes[@]}): " choice

    if [ "$choice" = "0" ]; then
        return
    fi

    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
        local selected_node=${all_nodes[$((choice-1))]}
        view_node_logs "$selected_node"
    else
        echo "无效的选项 '$choice'。"
        read -p "按任意键继续"
    fi
}

# -----------------------------------------------------------------------------
# 函数：view_node_logs
# 描述：实时查看指定节点的容器日志。
# 参数：$1 - 节点的唯一 ID
# -----------------------------------------------------------------------------
function view_node_logs() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    if ! docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        echo "错误: 容器 '$container_name' 不存在。可能已被移除或未创建。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "正在连接到容器 '$container_name' 查看日志..."
    echo "按下 Ctrl+C 退出日志流。"
    echo "--------------------------------------------------------------------------"
    
    echo "日志查看模式:"
    echo "1. 原始日志 (包含 ANSI 颜色代码)"
    echo "2. 清理后的日志 (移除 ANSI 颜色代码，有时更适合无终端环境或纯文本处理)"
    read -rp "请选择 (1-2，默认1): " log_mode

    if [ "$log_mode" = "2" ]; then
        # 使用 sed 移除 ANSI 颜色代码
        # 匹配所有可能的 ANSI escape sequences
        docker logs -f "$container_name" 2>/dev/null | sed -e 's/\x1B\[[0-9;]*m//g' -e 's/\x1B\[?25h//g' -e 's/\x1B\[?25l//g'
    else
        # 直接查看日志，保留颜色
        docker logs -f "$container_name"
    fi
    
    echo "--------------------------------------------------------------------------"
    echo "日志查看已退出。"
    read -p "按任意键返回主菜单..."
}

# -----------------------------------------------------------------------------
# 函数：batch_rotate_nodes
# 描述：自动化批量部署，按照设定的轮次启动和停止 Nexus 节点。
#       此函数使用了 PM2 来守护轮换脚本的执行。
# -----------------------------------------------------------------------------
function batch_rotate_nodes() {
    # 首先确保 Docker 已准备好，然后检查 Node.js/npm/pm2
    check_docker || return 1
    check_nodejs_and_pm2 || return 1

    echo "===== Nexus 节点批量轮换启动 ====="
    echo "请输入您想管理的一系列节点的 ID（每行一个），这些 ID 将用于创建容器名称。"
    echo "每行输入一个节点 ID。输入一个空行后按 Enter，然后输入 Ctrl+D 结束输入。"
    echo "例如:"
    echo "node-worker-1"
    echo "gpu-node-alpha"
    echo ""
    
    local node_ids_input=()
    while IFS= read -r line; do
        local trimmed_line=$(echo "$line" | xargs) # Remove leading/trailing whitespace
        if [ -n "$trimmed_line" ]; then
            node_ids_input+=("$trimmed_line")
        fi
    done

    if [ ${#node_ids_input[@]} -eq 0 ]; then
        echo "未输入任何节点 ID。返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    local total_input_nodes=${#node_ids_input[@]}
    echo "您总共输入了 $total_input_nodes 个节点 ID。"

    # 计算默认的每轮节点数量，例如总量的一半（向上取整）
    local nodes_per_round=$(( (total_input_nodes + 1) / 2 ))
    
    # 用户自定义每轮启动的数量
    read -rp "请输入每轮启动的节点数量（默认: $nodes_per_round, 输入 0 为仅启动一次，不轮换）: " input_nodes_per_round
    
    local batch_mode="rotate" # 默认轮换模式
    if [[ "$input_nodes_per_round" =~ ^[0-9]+$ ]]; then
        if [ "$input_nodes_per_round" -eq 0 ]; then
            batch_mode="single_run"
            echo "将执行一次性启动任务，不进行轮换。"
        elif [ "$input_nodes_per_round" -ge 1 ] && [ "$input_nodes_per_round" -le "$total_input_nodes" ]; then
            nodes_per_round=$input_nodes_per_round
            echo "设置每轮启动 $nodes_per_round 个节点。"
        else
            echo "输入的节点数量 '$input_nodes_per_round' 无效。使用默认值 $nodes_per_round。"
        fi
    else
        echo "无效输入，使用默认值 $nodes_per_round。"
    fi
    
    # 确切的节点列表，后续会使用此列表生成脚本
    local node_ids=()
    for nid in "${node_ids_input[@]}"; do
        node_ids+=("$nid")
    done

    # 清理旧的轮换启动脚本和配置
    echo "正在清理旧的轮换启动脚本目录和 PM2 配置..."
    local script_dir="/root/nexus_scripts"
    if [ -d "$script_dir" ]; then
        rm -rf "$script_dir"
    fi
    mkdir -p "$script_dir"
    
    # 停止并删除名为 "nexus-rotate" 的 PM2 任务，忽略错误（如果不存在）
    pm2 delete nexus-rotate >/dev/null 2>&1 || echo "PM2: 未找到旧的 'nexus-rotate' 任务，继续执行。"

    # 构建 Nexus Docker 镜像
    echo "正在构建 Nexus Docker 镜像..."
    build_image
    if [ $? -ne 0 ]; then
        echo "错误: Docker 镜像构建失败。请根据上述错误信息排查。"
        read -p "按任意键返回主菜单..."
        return
    fi
    echo "Docker 镜像构建成功，准备启动节点。"

    # --- 生成主轮换脚本（rotate.sh） ---
    echo "正在生成轮换启动脚本..."
    local num_actual_groups=0
    if [ "$batch_mode" == "rotate" ]; then
        num_actual_groups=$(( (total_input_nodes + nodes_per_round - 1) / nodes_per_round ))
        echo "根据设置，节点将被分为 $num_actual_groups 组进行轮换启动（每组约 $nodes_per_round 个节点）。"
    else # batch_mode == "single_run"
        num_actual_groups=1
        nodes_per_round=$total_input_nodes # single_run 即所有节点一组
        echo "将执行一次性启动任务，启动所有 $total_input_nodes 个节点。"
    fi

    # 每次批量操作时清理现有的同名容器
    echo "开始清理之前可能存在的 Nexus 节点容器..."
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f >/dev/null 2>&1
    echo "现有 Nexus 节点容器清理完成。"
    
    # 准备主控制脚本内容
    cat > "$script_dir/nexus_rotation_manager.sh" <<EOF
#!/bin/bash
# Auto-generated Nexus Node Rotation Manager Script

echo "[\$(date '+%Y-%m-%d %H:%M:%S')] ==== Nexus Node Rotation Manager Started ===="

# Configuration for rotation
readonly ROTATION_WAIT_INTERVAL_SECONDS=7200 # Default to 2 hours. Adjust as needed.

# Array of Node IDs to manage (as provided by user)
# Use 'eval' to properly quote array elements if node IDs have spaces etc.
declare -a NODE_IDS=($(printf '"%s" ' "${node_ids_input[@]}"))
# Total number of nodes
readonly TOTAL_NODES=\${#NODE_IDS[@]}
# Nodes per batch
readonly NODES_PER_BATCH=$nodes_per_round
# Total number of batches/groups
readonly NUM_BATCHES=$num_actual_groups
# Batch execution mode
readonly BATCH_MODE="$batch_mode"

# Function to execute a batch of node starts
execute_batch() {
    local batch_index=\$1 # 1-based index of the batch
    local start_node_index=\$2
    local end_node_index=\$3

    echo ""
    echo "[\$(date '+%Y-%m-%d %H:%M:%S')] === Executing Batch \${batch_index}/\${NUM_BATCHES} (Nodes: \${start_node_index} to \${end_node_index}) ==="

    # Check host memory once per batch, to ensure dynamic adjustment if possible
    local host_total_mem_mb=\$(_get_host_memory_mb "total")
    local host_available_mem_mb=\$(_get_host_memory_mb "available")
    
    if [ -z "\$host_total_mem_mb" ] || [ "\$host_total_mem_mb" -eq 0 ]; then
        echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Warning: Could not retrieve host memory for this batch. Memory allocation may fail."
    fi

    for ((i=\${start_node_index}; i<\${end_node_index}; i++)); do
        local node_id="\${NODE_IDS[\$i]}"
        local container_name="${BASE_CONTAINER_NAME}-\${node_id}"
        local log_file="${LOG_DIR}/nexus-\${node_id}.log"
        local docker_run_command=""
        local allocated_mem_mb_for_script=0

        # --- Calculate Memory for the current node in this batch ---
        if [ -n "\$host_total_mem_mb" ] && [ -n "\$host_available_mem_mb" ] && [ -n "\$(command -v bc)" ]; then
            # Calculate based on ratio, clamp to min/max, and then check against available
            local allocated_mem_float="(\$host_total_mem_mb * $CONTAINER_MEM_RATIO)"
            allocated_mem_mb_for_script=\$(echo "\$allocated_mem_float / 1024" | bc) # From KB to MB

            if (( allocated_mem_mb_for_script > $CONTAINER_MEM_MAX_MB )); then allocated_mem_mb_for_script=$CONTAINER_MEM_MAX_MB; fi
            if (( allocated_mem_mb_for_script < $CONTAINER_MEM_MIN_MB )); then allocated_mem_mb_for_script=$CONTAINER_MEM_MIN_MB; fi

            # Final check against host available memory
            if (( allocated_mem_mb_for_script > host_available_mem_mb )); then
                echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Warning: Node \$node_id memory request (\$allocated_mem_mb_for_script MB) exceeds available host memory (\$host_available_mem_mb MB). Adjusting..."
                local available_adjusted_float="(\$host_available_mem_mb * 0.9)"
                allocated_mem_mb_for_script=\$(echo "\$available_adjusted_float / 1024" | bc)
                if (( allocated_mem_mb_for_script < $CONTAINER_MEM_MIN_MB )); then allocated_mem_mb_for_script=$CONTAINER_MEM_MIN_MB; fi
                if (( allocated_mem_mb_for_script > host_available_mem_mb )); then allocated_mem_mb_for_script=$((host_available_mem_mb)); fi # Max out available
            fi
        else
            # Fallback if bc or host memory is unavailable, try to set a sensible default or just 2GB
            allocated_mem_mb_for_script=$CONTAINER_MEM_MIN_MB
        fi
        
        local mem_param=""
        if (( allocated_mem_mb_for_script > 0 )); then
            mem_param="-m \${allocated_mem_mb_for_script}m"
            echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Node \$node_id will be allocated \${allocated_mem_mb_for_script} MB RAM."
        else
             echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Node \$node_id memory allocation could not be determined, running without explicit limit."
        fi

        # Prepare docker run command. Use printf for safer quoting of arguments.
        local quoted_container_name=\$(printf "%q" "\$container_name")
        local quoted_log_file=\$(printf "%q" "\$log_file")
        local quoted_node_id=\$(printf "%q" "\$node_id")
        
        echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Starting container for Node ID: \$node_id (\${container_name})..."
        docker_run_command="docker run -d --name \$quoted_container_name \$mem_param -v \$quoted_log_file:/root/nexus.log -e NODE_ID=\$quoted_node_id $IMAGE_NAME"
        
        echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Executing: \$docker_run_command"
        eval "\$docker_run_command"
        local run_status=\$?

        if [ "\$run_status" -ne 0 ]; then
            echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Error: Failed to start container for node '\$node_id'."
            # Append specific error if available, though docker itself usually logs to journald/syslog
            # In a robust system, you might check docker logs for this container name immediately.
        else
            echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Container start command issued for node '\$node_id'. Waiting 5s for init..."
            sleep 5 # Give some time for container to spin up and entrypoint to start Nexus
        fi
        echo "" # Blank line for separation
    done
    echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Batch \${batch_index} finished."
}

# Helper to get host memory in MB as it might be called from the generated script.
# Arguments: 'total' or 'available'
_get_host_memory_mb() {
    local mem_type="total"
    if [ "$1" == "available" ]; then mem_type="available"; fi
    
    local total_mem_kb=0
    local available_mem_kb=0

    if [ -f /proc/meminfo ]; then
        total_mem_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        if [ -n "$total_mem_kb" ]; then total_mem_kb=$((total_mem_kb)); fi
        
        available_mem_kb=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
        if [ -z "$available_mem_kb" ] || [ "$available_mem_kb" -le 0 ]; then
            available_mem_kb=$(grep MemFree /proc/meminfo | awk '{print $2}')
        fi
        if [ -n "$available_mem_kb" ]; then available_mem_kb=$((available_mem_kb)); fi
    fi

    local total_mem_mb=$((total_mem_kb / 1024))
    local available_mem_mb=$((available_mem_kb / 1024))

    if [ "$mem_type" == "total" ]; then
        echo "\$total_mem_mb"
    else
        echo "\$available_mem_mb"
    fi
}

# Main loop for rotation logic
# Add sleep logic only if NOT in single_run mode
if [ "\$BATCH_MODE" == "rotate" ]; then
    # Start with cleaning existing containers before the first batch
    echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Performing initial clean up of existing nodes."
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f >/dev/null 2>&1
    echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Initial clean up complete."

    for ((batch_num=1; batch_num <= \$NUM_BATCHES; batch_num++)); do
        start_idx=\$(( (batch_num - 1) * NODES_PER_BATCH ))
        end_idx=\$(( batch_num * NODES_PER_BATCH ))
        if (( end_idx > TOTAL_NODES )); then end_idx=\$TOTAL_NODES; fi
        
        # Ensure end_idx doesn't exceed bounds in case of zero nodes total or faulty calculation
        if (( start_idx >= TOTAL_NODES )); then break; fi # Exit loop if we've processed all nodes

        execute_batch \$batch_num \$start_idx \$end_idx
        
        # If this is not the last batch, clean up nodes before starting next batch and wait.
        if [ "\$batch_num" -lt "\$NUM_BATCHES" ]; then
            echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Finished batch \$batch_num. Cleaning up started nodes before next batch."
            docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f >/dev/null 2>&1
            echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Nodes from Batch \$batch_num cleaned. Waiting \${ROTATION_WAIT_INTERVAL_SECONDS} seconds before starting next batch."
            sleep \${ROTATION_WAIT_INTERVAL_SECONDS}
        else
            # This is the last batch. Don't clean up yet. Wait for the interval for continuous operation.
            echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Last batch completed. Waiting \${ROTATION_WAIT_INTERVAL_SECONDS} seconds before starting the cycle again."
            sleep \${ROTATION_WAIT_INTERVAL_SECONDS}
            # After the wait, we want to restart the loop (implicitly done by while true)
        fi
    done
else # batch_mode == "single_run"
    echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Single run mode activated. Starting all nodes in one go."
    execute_batch 1 0 \$((TOTAL_NODES)) # Execute all nodes in a single batch.
    echo "[\$(date '+%Y-%m-%d %H:%M:%S')] All nodes initiated for single run mode. Process finished."
fi

# This script is managed by PM2, which keeps it running in a loop (if mode is 'rotate')
# or it exits after the single run.
EOF

    # Make the main script executable
    chmod +x "$script_dir/nexus_rotation_manager.sh"

    echo "Node rotation management script '$script_dir/nexus_rotation_manager.sh' generated."
    echo "Starting the script via PM2..."
    
    # Start the manager script with PM2
    # --watch might be useful if the script needs to react to external changes, but here we control loop via script itself.
    # Use -- interpreter /bin/bash if you don't specify .sh extension explicitly.
    if ! pm2 start "$script_dir/nexus_rotation_manager.sh" --name "nexus-rotate" --interpreter "/bin/bash"; then
        echo "错误: 通过 PM2 启动 'nexus-rotate' 任务失败。"
        echo "请确保 PM2 已正确安装，并检查 '$script_dir/nexus_rotation_manager.sh' 是否可执行并包含有效内容。"
        echo "您可以尝试手动运行该脚本进行调试: $script_dir/nexus_rotation_manager.sh"
        read -p "按任意键返回主菜单..."
        return 1
    fi

    pm2 save # 保存 PM2 的进程列表，以便系统重启后恢复
    echo "PM2 task 'nexus-rotate' started successfully."
    echo "You can manage it using PM2 commands:"
    echo "  pm2 status          : View current PM2 tasks"
    echo "  pm2 logs nexus-rotate : View detailed logs of the rotation manager"
    echo "  pm2 stop nexus-rotate : Stop the rotation manager"
    echo "  pm2 restart nexus-rotate : Restart the rotation manager"
    echo "  pm2 delete nexus-rotate : Remove the rotation manager task"
    read -p "按任意键返回主菜单..."
    return 0
}


# -----------------------------------------------------------------------------
# 函数：cleanup_old_containers
# 描述：定时清理超过一定时间的旧容器，例如移除停止超过 X 天的。
#       （实际部署中更常用的方式是，当需要启动新节点时，先移除旧的同名容器）
#       这是一个可选的后台任务，或通过 cron job 实现。
#       由于该脚本是交互式的，这里不为它创建一个长期的后台进程。
# -----------------------------------------------------------------------------
function setup_log_cleanup_cron() {
    # Optional: Set up a cron job for cleaning old logs/containers.
    # This script is not designed to be run as a daemon itself.
    # For this script, it's better to manually clean or use existing system tools.
    # If you want automatic cleanup:
    # Add an entry to root's crontab (crontab -e as root):
    # 0 2 * * * /path/to/this/script.sh --cleanup-old-logs --retention-days 7
    # And implement the logic here based on that command.
    echo "注：脚本的日志文件位于 $LOG_DIR。您可以通过手动清理旧文件或配置 cron job 来管理磁盘空间。"
}


# -----------------------------------------------------------------------------
# 函数：display_menu
# 描述：显示主菜单界面。
# -----------------------------------------------------------------------------
function display_menu() {
    clear
    echo "********************************************************"
    echo "**           Nexus Multi-Node Management Tool         **"
    echo "********************************************************"
    echo "   Author: 哈哈哈哈 (Github/Twitter: @ferdie_jhovie)"
    echo "   Version: 1.4.0 (Refined compatibility and batch operations)"
    echo "--------------------------------------------------------"
    echo " [1] Single Node: Install & Start a new Nexus Node"
    echo " [2] Management: List all Nexus Nodes (status, details)"
    echo " [3] Batch Management: Stop & Uninstall selected nodes"
    echo " [4] Log Viewer: View logs for a specific Nexus Node"
    echo " [5] Batch Deployment: Automate rotation and deployment of nodes"
    echo " [6] Global Cleanup: Permanently remove all Nexus nodes & resources"
    echo " [7] Exit Script"
    echo "--------------------------------------------------------"
}

# ---- Main Script Execution Logic ----

# 预先检查所需的工具
# 如果某些基础工具缺失，先尝试安装，否则后续很多功能都会失败
install_utility_if_not_exists "docker" "docker-ce" "docker" || { echo "Docker installation failed. Aborting."; exit 1; }
install_utility_if_not_exists "curl" "curl" || { echo "curl installation failed. Aborting."; exit 1; }
install_utility_if_not_exists "gpg" "gpg" || { echo "gpg installation failed. Aborting."; exit 1; }
install_utility_if_not_exists "bc" "bc" || echo "Warning: 'bc' not found. Memory allocation calculations might be limited."


# Main application loop
while true; do
    display_menu
    read -rp "Please select an option (1-7): " main_choice

    case $main_choice in
        1) # 1. Single Node: Install & Start a new Nexus Node
            echo "--- Option 1: Start a New Nexus Node ---"
            check_docker # Ensure Docker is ready before proceeding
            
            read -rp "Enter a unique Node ID (e.g., my-nexus-node-01): " node_id_input
            local NODE_ID=$(echo "$node_id_input" | xargs) # Trim whitespace
            
            if [ -z "$NODE_ID" ]; then
                echo "Error: Node ID cannot be empty!"
            else
                echo "Preparing to install and start node '$NODE_ID'..."
                # Build the image first, ensure it's available for new nodes.
                # This might be inefficient if called for every single node, but guarantees it's ready.
                # In a production setup, you might build the image once outside this loop or only when needed.
                build_image
                if [ $? -ne 0 ]; then
                    echo "Docker image build failed. Please review the errors above."
                else
                    echo "Image '$IMAGE_NAME' is ready. Starting container..."
                    if run_container "$NODE_ID"; then
                        echo "Successfully initiated start for node '$NODE_ID'."
                    else
                        echo "Failed to start container for node '$NODE_ID'."
                    fi
                fi
            fi
            read -p "Press Enter to return to the main menu..."
            ;;
            
        2) # 2. Management: List all nodes
            list_nodes
            ;;
            
        3) # 3. Batch Management: Stop & Uninstall nodes
            batch_uninstall_nodes
            ;;
            
        4) # 4. Log Viewer: View logs for a node
            select_node_to_view
            ;;
            
        5) # 5. Batch Deployment: Automate rotation and deployment
            batch_rotate_nodes
            ;;
            
        6) # 6. Global Cleanup: Delete all nodes
            echo "!!! WARNING !!! This action will permanently delete ALL existing Nexus nodes"
            echo "and their associated Docker containers and log files!"
            
            local existing_nodes_count=0
            if nodes=$(get_all_nodes); then
                existing_nodes_count=$(echo "$nodes" | wc -l)
            fi

            if [ "$existing_nodes_count" -eq 0 ]; then
                echo "No Nexus nodes found to clean up."
            else
                echo "Found $existing_nodes_count Nexus node(s). They will be removed."
                # You might list them here if needed
            fi

            read -rp "Are you absolutely sure you want to delete ALL Nexus nodes? Type 'confirm-all' to proceed: " confirm_global_cleanup
            if [ "$confirm_global_cleanup" == "confirm-all" ]; then
                echo "Proceeding with global cleanup..."
                local nodes_to_delete_global=($(get_all_nodes))
                if [ ${#nodes_to_delete_global[@]} -eq 0 ]; then
                    echo "No Nexus nodes were found during the cleanup execution."
                else
                    for node_id in "${nodes_to_delete_global[@]}"; do
                        uninstall_node "$node_id"
                    done
                    echo "Global cleanup completed. All Nexus nodes and their resources have been removed."
                fi
            else
                echo "Global cleanup operation cancelled."
            fi
            read -p "Press Enter to return to the main menu..."
            ;;
            
        7) # 7. Exit Script
            echo "Exiting Nexus Multi-Node Management Tool. Goodbye!"
            exit 0
            ;;
            
        *) # Invalid input
            echo "Invalid option '$main_choice'. Please enter a number between 1 and 7."
            read -p "Press Enter to continue..."
            ;;
    esac
done
