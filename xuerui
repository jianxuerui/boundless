#!/bin/bash
set -e

BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs" # 默认日志目录

# ==========================================================================
#                         !!! 重 要 提 示 !!!
# 本脚本将在 '$LOG_DIR' 路径下创建日志目录和文件。
# 默认路径 '/root/nexus_logs' 通常需要 root 权限。
# 请使用 'sudo ./nexus_manager.sh' 命令运行此脚本，以确保所有功能正常工作。
# 如果您不希望使用 '/root' 目录，请修改上方 'LOG_DIR' 变量为其他路径，
# 例如：LOG_DIR="$HOME/nexus_logs" (这将使用当前用户家目录下的nexus_logs)。
# ==========================================================================


# 检查 Docker 是否安装
function check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "检测到未安装 Docker，正在安装..."
        apt update || { echo "错误：apt update 失败。"; exit 1; }
        apt install -y apt-transport-https ca-certificates curl software-properties-common || { echo "错误：安装依赖失败。"; exit 1; }
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - || { echo "错误：添加 Docker GPG 密钥失败。"; exit 1; }
        add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" || { echo "错误：添加 Docker APT 仓库失败。"; exit 1; }
        apt update || { echo "错误：再次 apt update 失败。"; exit 1; }
        apt install -y docker-ce || { echo "错误：安装 docker-ce 失败。"; exit 1; }
        systemctl enable docker || { echo "错误：启用 Docker 服务失败。"; exit 1; }
        systemctl start docker || { echo "错误：启动 Docker 服务失败。"; exit 1; }
        echo "Docker 安装完成并已启动。"
    fi
}

# 检查 Node.js/npm/pm2 是否安装
function check_pm2() {
    if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
        echo "检测到未安装 Node.js/npm，正在安装..."
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash - || { echo "错误：NodeSource setup 失败。"; exit 1; }
        apt-get install -y nodejs || { echo "错误：安装 nodejs 失败。"; exit 1; }
        echo "Node.js/npm 安装完成。"
    fi
    if ! command -v pm2 >/dev/null 2>&1; then
        echo "检测到未安装 pm2，正在安装..."
        npm install -g pm2 || { echo "错误：安装 pm2 失败。"; exit 1; }
        echo "pm2 安装完成。"
    fi
}

# 获取系统总内存（MB）
function get_total_system_ram_mb() {
    awk '/MemTotal:/ {print int($2/1024)}' /proc/meminfo
}

# 计算每节点内存限制（MB）
# 参数：
# $1: 需要分配内存的节点总数（例如，当前批次或当前轮次将启动的节点数）
# $2: 可用于 Nexus 节点的系统内存百分比
function calculate_per_node_memory_mb() {
    local num_nodes_to_allocate=$1
    local percentage=$2
    local total_ram_mb=$(get_total_system_ram_mb)

    if [ "$num_nodes_to_allocate" -eq 0 ]; then
        echo 0 # 没有节点，不分配内存
        return
    fi

    # 计算 Nexus 节点总共可使用的内存量
    local allocatable_ram_mb=$(( (total_ram_mb * percentage) / 100 ))

    # 计算每节点内存（整数除法）
    local per_node_ram_mb=$(( allocatable_ram_mb / num_nodes_to_allocate ))

    # 确保每个节点有一个最低内存限制 (例如 512MB)，防止分配过小
    local min_per_node_mb=512
    if [ "$per_node_ram_mb" -lt "$min_per_node_mb" ]; then
        per_node_ram_mb="$min_per_node_mb"
        # 如果强制最低内存后，总分配超过了设定的百分比，给出警告
        if [ $((num_nodes_to_allocate * min_per_node_mb)) -gt "$allocatable_ram_mb" ]; then
             echo "警告: 根据您设定的系统内存百分比 (${percentage}%) 和当前节点数量 (${num_nodes_to_allocate}个)，总可用内存不足以保证每节点 ${min_per_node_mb}MB。脚本将强制使用此最低限制，可能超出设定百分比或导致系统资源争抢，请注意！" >&2
        fi
    fi

    echo "$per_node_ram_mb"
}

# 构建docker镜像函数
function build_image() {
    echo "正在构建 Docker 镜像 $IMAGE_NAME..."
    WORKDIR=$(mktemp -d)
    # 错误处理：mktemp 失败
    if [ ! -d "$WORKDIR" ]; then
        echo "错误：无法创建临时目录。"
        exit 1
    fi
    cd "$WORKDIR"

    cat > Dockerfile <<EOF
FROM ubuntu:24.04

ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id

RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    bash \
    && rm -rf /var/lib/apt/lists/*

# 自动下载安装最新版 nexus-network
RUN curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh \
    && ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
EOF

    cat > entrypoint.sh <<EOF
#!/bin/bash
set -e

PROVER_ID_FILE="/root/.nexus/node-id"

if [ -z "\$NODE_ID" ]; then
    echo "错误：未设置 NODE_ID 环境变量"
    exit 1
fi

echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo "使用的 node-id: \$NODE_ID"

if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 未安装或不可用"
    exit 1
fi

echo "启动 nexus-network 节点..."
# 使用 exec 将 nexus-network 设为容器主进程，以便 Docker 正确处理信号。
# 日志将输出到 /root/nexus.log。
exec nexus-network start --node-id "\$NODE_ID" &>> /root/nexus.log
EOF

    # 错误处理：Docker 镜像构建失败
    if ! docker build -t "$IMAGE_NAME" .; then
        echo "错误：Docker 镜像 '$IMAGE_NAME' 构建失败。请检查您的 Dockerfile 内容或 Docker 环境。"
        cd - >/dev/null # 无论如何返回原目录
        rm -rf "$WORKDIR"
        exit 1
    fi

    cd - >/dev/null # 返回上一个目录
    rm -rf "$WORKDIR"
    echo "Docker 镜像 '$IMAGE_NAME' 构建完成。"
}

# 启动容器（挂载宿主机日志文件，并添加内存限制）
function run_container() {
    local node_id=$1
    local mem_limit_mb=$2 # 新参数：内存限制（MB）
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "正在准备启动容器 '$container_name' ..."

    # 确保日志目录存在且可写
    mkdir -p "$LOG_DIR" || { echo "错误：无法创建日志目录 '$LOG_DIR'。请检查权限或尝试使用 'sudo' 运行脚本。"; exit 1; }
    if [ ! -d "$LOG_DIR" ]; then
        echo "错误：日志目录 '$LOG_DIR' 未能成功创建。请检查文件系统状态或权限。"
        exit 1
    fi
    if [ ! -w "$LOG_DIR" ]; then
        echo "错误：日志目录 '$LOG_DIR' 不可写。请检查权限。"
        exit 1
    fi
    
    # 确保宿主机日志文件存在并有写权限
    # 如果宿主机上的 log_file 路径被误创建为目录，则删除它
    if [ -d "$log_file" ]; then
        echo "警告: 检测到日志文件路径 '$log_file' 是一个目录，正在尝试删除以便创建文件..."
        rm -rf "$log_file" || { echo "错误: 无法删除目录 '$log_file'。请手动删除或检查权限。"; exit 1; }
    fi

    # 检查文件不存在则创建，并设置权限
    if [ ! -f "$log_file" ]; then
        touch "$log_file" || { echo "错误: 无法创建日志文件 '$log_file'。请检查目录 '$LOG_DIR' 权限。"; exit 1; }
        chmod 644 "$log_file" || { echo "警告: 无法设置日志文件 '$log_file' 的权限。请手动调整或检查权限。"; }
    fi

    # 检查现有容器并删除它
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "检测到旧容器 '$container_name'，先删除..."
        docker rm -f "$container_name" || { echo "错误: 无法删除旧容器 '$container_name'。请手动处理或检查权限。"; exit 1; }
    fi

    echo "正在为容器 '$container_name' 启动节点，并分配内存: ${mem_limit_mb}MB"
    # 使用 -m 参数设置内存限制
    if ! docker run -d --name "$container_name" -v "$log_file":/root/nexus.log -e NODE_ID="$node_id" -m "${mem_limit_mb}m" "$IMAGE_NAME"; then
        echo "错误：Docker 容器 '$container_name' 启动失败。请检查日志，错误详情如下："
        docker logs "$container_name" # 尝试显示日志以帮助诊断
        exit 1 # 启动失败是关键错误，直接退出
    fi

    echo "容器 '$container_name' 已启动！"
    sleep 3 # 给Docker和nexus-network一点时间启动

    # 可选检查：如果容器在启动后立即退出
    if ! docker ps --filter "name=$container_name" --filter "status=running" --format "{{.Names}}" | grep -qw "$container_name"; then
        echo "警告：容器 '$container_name' 启动后似乎没有保持运行，可能已退出。请检查容器日志获取详细信息。"
        docker logs "$container_name" # 显示日志以供诊断
        read -rp "按任意键继续 (或 Ctrl+C 退出)..." # 不在此处立即退出，让用户决定
    fi
}

# 停止并卸载容器和镜像、删除日志
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "停止并删除容器 '$container_name'..."
    docker rm -f "$container_name" 2>/dev/null || echo "容器 '$container_name' 不存在或已停止，跳过删除。"

    # 在尝试删除前检查是否为文件
    if [ -f "$log_file" ]; then
        echo "删除日志文件 '$log_file' ..."
        rm -f "$log_file" || { echo "警告: 无法删除日志文件 '$log_file'。请手动删除或检查权限。"; }
    elif [ -d "$log_file" ]; then
        echo "警告: 日志路径 '$log_file' 是一个目录，无法直接删除。请手动处理或检查原因。"
    else
        echo "日志文件不存在：'$log_file'"
    fi

    echo "节点 '$node_id' 已卸载完成。"
}

# 显示所有运行中的节点
function list_nodes() {
    echo "当前节点状态："
    echo "------------------------------------------------------------------------------------------------------------------------"
    # 调整列宽以适应完整的内存字符串，例如 "100MiB / 1.00GiB"
    printf "%-6s %-20s %-10s %-15s %-15s %-15s %-20s\n" "序号" "节点ID" "CPU使用率" "内存使用" "内存限制" "状态" "启动时间"
    echo "------------------------------------------------------------------------------------------------------------------------"
    
    local all_nodes=($(get_all_nodes))
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "                                没有发现 Nexus 节点。请尝试安装节点（选项1或5）。"
        echo "------------------------------------------------------------------------------------------------------------------------"
        read -p "按任意键返回菜单"
        return
    fi

    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        # docker stats 返回格式："CPU%,MemUsage / MemLimit,Mem% (Mem% 这里被移除了以简化)"
        local container_info=$(docker stats --no-stream --format "{{.CPUPerc}},{{.MemUsage}}" "$container_name" 2>/dev/null) 
        
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}")
        local created_time=$(docker ps -a --filter "name=$container_name" --format "{{.CreatedAt}}")

        local cpu_usage="N/A"
        local mem_usage="N/A"
        local mem_limit="N/A"

        if [ -n "$container_info" ]; then
            IFS=',' read -r cpu_usage_raw full_mem_usage_raw <<< "$container_info"
            
            cpu_usage="$cpu_usage_raw" # CPU usage often comes with a % already, ensure consistent display
            
            # 解析内存使用字符串 (例如 "1.23MiB / 1.00GiB")
            local current_mem_str=$(echo "$full_mem_usage_raw" | awk -F' / ' '{print $1}')
            local limit_mem_str=$(echo "$full_mem_usage_raw" | awk -F' / ' '{print $2}')

            if [ -n "$current_mem_str" ]; then
                mem_usage="$current_mem_str"
            fi
            if [ -n "$limit_mem_str" ]; then
                mem_limit="$limit_mem_str"
            fi
        fi
        
        # 显示节点信息
        printf "%-6d %-20s %-10s %-15s %-15s %-15s %-20s\n" \
            $((i+1)) \
            "$node_id" \
            "$cpu_usage" \
            "$mem_usage" \
            "$mem_limit" \
            "$(echo "$status" | cut -d' ' -f1)" \
            "$created_time"
    done
    echo "------------------------------------------------------------------------------------------------------------------------"
    echo "提示："
    echo "- CPU使用率：显示容器CPU使用百分比"
    echo "- 内存使用：显示容器当前使用的内存"
    echo "- 内存限制：显示容器的内存限制 (由脚本根据总内存和同时运行节点数计算)"
    echo "- 状态：显示容器的运行状态"
    echo "- 启动时间：显示容器的创建时间"
    read -p "按任意键返回菜单"
}

# 获取所有运行中的节点ID
function get_running_nodes() {
    docker ps --filter "name=${BASE_CONTAINER_NAME}" --filter "status=running" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 获取所有节点ID（包括已停止的）
function get_all_nodes() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 查看节点日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "容器 '$container_name' 未运行或不存在，请检查节点ID是否正确"
        read -p "按任意键返回菜单"
        return
    fi

    echo "请选择日志查看模式："
    echo "1. 原始日志（可能包含颜色代码）"
    echo "2. 清理后的日志（移除颜色代码）"
    read -rp "请选择(1-2): " log_mode

    echo "查看日志，按 Ctrl+C 退出日志查看"
    if [ "$log_mode" = "2" ]; then
        docker logs -f "$container_name" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/\x1b\[?25l//g' | sed 's/\x1b\[?25h//g'
    else
        docker logs -f "$container_name"
    fi
}

# 安装并启动单个节点
function start_single_node() {
    check_docker
    read -rp "请输入您的 node-id: " NODE_ID
    if [ -z "$NODE_ID" ]; then
        echo "node-id 不能为空，请重新选择。"
        read -p "按任意键继续"
        return
    fi

    # 默认给单个节点分配1GB内存，如果系统内存较低则自适应调整
    local default_single_node_mem_mb=1024
    local total_system_ram_mb=$(get_total_system_ram_mb)

    # 如果系统总内存不足1GB，则设置为总内存的90%，最低512MB
    if [ "$total_system_ram_mb" -lt "$default_single_node_mem_mb" ]; then
        local calculated_default_mem=$(( (total_system_ram_mb * 90) / 100 ))
        if [ "$calculated_default_mem" -lt 512 ]; then
            default_single_node_mem_mb=512
        else
            default_single_node_mem_mb="$calculated_default_mem"
        fi
        echo "提示: 您的系统内存较低（${total_system_ram_mb}MB），单节点默认分配内存已自动调整为 ${default_single_node_mem_mb}MB。"
    fi

    read -rp "请输入此单个节点要分配的内存大小（MB，默认：${default_single_node_mem_mb}）: " single_node_mem_input
    if [ -z "$single_node_mem_input" ]; then
        local single_node_mem_mb=$default_single_node_mem_mb
    elif ! [[ "$single_node_mem_input" =~ ^[0-9]+$ ]] || [ "$single_node_mem_input" -lt 1 ]; then
        echo "无效的内存大小，请输入大于0的整数。"
        read -p "按任意键继续"
        return
    else
        local single_node_mem_mb="$single_node_mem_input"
    fi
    
    # 再次检查用户输入的内存是否合理
    if [ "$single_node_mem_mb" -ge "$total_system_ram_mb" ]; then
        echo "警告：您设置的单个节点内存 (${single_node_mem_mb}MB) 接近或超过系统总内存 (${total_system_ram_mb}MB)。这可能会导致系统不稳定，强烈建议减少！"
        read -rp "仍要继续吗？(y/N): " confirm_mem
        if [[ ! "$confirm_mem" =~ ^[Yy]$ ]]; then
            echo "已取消操作。"
            read -p "按任意键继续"
            return
        fi
    fi

    echo "开始构建镜像并启动容器..."
    build_image
    run_container "$NODE_ID" "$single_node_mem_mb"
    read -p "按任意键返回菜单"
}

# 批量启动多个节点（同时启动，均分内存）
function batch_start_nodes() {
    echo "请输入多个 node-id，每行一个，输入空行结束："
    echo "（输入完成后按回车键，然后按 Ctrl+D 结束输入）"
    
    local node_ids=()
    while read -r line; do
        if [ -n "$line" ]; then
            node_ids+=("$line")
        fi
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 node-id，返回主菜单"
        read -p "按任意键继续"
        return
    fi

    local total_system_ram_mb=$(get_total_system_ram_mb)
    echo "系统总内存：${total_system_ram_mb}MB"

    read -rp "请输入所有节点可使用的系统内存百分比 (1-100, 建议: ${DEFAULT_MEMORY_PERCENTAGE}): " mem_percent_input
    if [ -z "$mem_percent_input" ]; then
        local mem_percent=$DEFAULT_MEMORY_PERCENTAGE
    elif ! [[ "$mem_percent_input" =~ ^[0-9]+$ ]] || [ "$mem_percent_input" -lt 1 ] || [ "$mem_percent_input" -gt 100 ]; then
        echo "无效的内存百分比，请输入1到100之间的数字"
        read -p "按任意键继续"
        return
    else
        local mem_percent=$mem_percent_input
    fi

    # 计算每个节点应该获得的内存
    local num_nodes_in_batch=${#node_ids[@]}
    local per_node_mem_mb=$(calculate_per_node_memory_mb "$num_nodes_in_batch" "$mem_percent")
    
    if [ "$per_node_mem_mb" -eq 0 ]; then
        echo "根据您的配置和系统内存，无法为每个节点分配有效内存（可能低于512MB的最低要求）。请检查节点数量或百分比。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "开始构建镜像..."
    build_image

    echo "每个节点将分配 ${per_node_mem_mb}MB 内存。"
    echo "开始启动 ${num_nodes_in_batch} 个节点..."
    for node_id in "${node_ids[@]}"; do
        echo "正在启动节点 $node_id ..."
        run_container "$node_id" "$per_node_mem_mb"
        sleep 2 # 添加短暂延迟
    done

    echo "所有节点启动完成！"
    read -p "按任意键返回菜单"
}

# 选择要查看的节点
function select_node_to_view() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有 Nexus 节点可以查看。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "请选择要查看日志的节点："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}")
        if [[ $status == Up* ]]; then
            echo "$((i+1)). 节点 $node_id [运行中]"
        else
            echo "$((i+1)). 节点 $node_id [已停止]"
        fi
    done

    read -rp "请输入选项(0-${#all_nodes[@]}): " choice

    if [ "$choice" = "0" ]; then
        return
    fi

    if [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
        local selected_node=${all_nodes[$((choice-1))]}
        view_node_logs "$selected_node"
    else
        echo "无效的选项"
        read -p "按任意键继续"
    fi
}

# 批量停止并卸载节点
function batch_uninstall_nodes() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有 Nexus 节点可以卸载。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "当前节点状态："
    echo "----------------------------------------"
    echo "序号  节点ID                状态"
    echo "----------------------------------------"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}")
        if [[ $status == Up* ]]; then
            printf "%-6d %-20s [运行中]\n" $((i+1)) "$node_id"
        else
            printf "%-6d %-20s [已停止]\n" $((i+1)) "$node_id"
        fi
    done
    echo "----------------------------------------"

    echo "请选择要删除的节点（可多选，输入数字，用空格分隔）："
    echo "0. 返回主菜单"
    
    read -rp "请输入选项(0 或 数字，用空格分隔): " choices

    if [ "$choices" = "0" ]; then
        return
    fi

    # 将输入的选项转换为数组
    read -ra selected_choices <<< "$choices"
    
    # 验证输入并执行卸载
    for choice in "${selected_choices[@]}"; do
        if [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
            local selected_node=${all_nodes[$((choice-1))]}
            echo "正在卸载节点 '$selected_node' ..."
            uninstall_node "$selected_node"
        else
            echo "跳过无效选项: '$choice'"
        fi
    done

    echo "批量卸载完成！"
    read -p "按任意键返回菜单"
}

# 删除全部节点
function uninstall_all_nodes() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有 Nexus 节点可以删除。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "警告：此操作将删除所有 Nexus 节点相关的 Docker 容器和日志文件！"
    echo "当前共有 ${#all_nodes[@]} 个节点："
    for node_id in "${all_nodes[@]}"; do
        echo "- $node_id"
    done
    
    read -rp "确定要删除所有节点吗？(y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "已取消操作"
        read -p "按任意键返回菜单"
        return
    fi

    echo "开始删除所有节点..."
    for node_id in "${all_nodes[@]}"; do
        echo "正在卸载节点 '$node_id' ..."
        uninstall_node "$node_id"
    done

    echo "所有节点已删除完成！"
    read -p "按任意键返回菜单"
}

# 批量节点轮换启动
function batch_rotate_nodes() {
    check_pm2
    echo "请输入多个 node-id，每行一个，输入空行结束："
    echo "（输入完成后按回车键，然后按 Ctrl+D 结束输入）"
    
    local node_ids=()
    while read -r line; do
        if [ -n "$line" ]; then
            node_ids+=("$line")
        fi
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 node-id，返回主菜单"
        read -p "按任意键继续"
        return
    fi

    local total_system_ram_mb=$(get_total_system_ram_mb)
    echo "系统总内存：${total_system_ram_mb}MB"

    read -rp "请输入所有轮换节点可使用的系统内存百分比 (1-100, 建议: ${DEFAULT_MEMORY_PERCENTAGE}): " mem_percent_input
    if [ -z "$mem_percent_input" ]; then
        local mem_percent=$DEFAULT_MEMORY_PERCENTAGE
    elif ! [[ "$mem_percent_input" =~ ^[0-9]+$ ]] || [ "$mem_percent_input" -lt 1 ] || [ "$mem_percent_input" -gt 100 ]; then
        echo "无效的内存百分比，请输入1到100之间的数字"
        read -p "按任意键返回菜单"
        return
    else
        local mem_percent=$mem_percent_input
    fi

    # 设置每两小时启动的节点数量
    read -rp "请输入每两小时要启动的节点数量（默认：${#node_ids[@]}的一半，向上取整）: " nodes_per_round_input
    if [ -z "$nodes_per_round_input" ]; then
        local nodes_per_round=$(( (${#node_ids[@]} + 1) / 2 ))
    else
        if ! [[ "$nodes_per_round_input" =~ ^[0-9]+$ ]] || [ "$nodes_per_round_input" -lt 1 ]; then
            echo "无效的节点数量，请输入大于0的数字"
            read -p "按任意键返回菜单"
            return
        fi
        local nodes_per_round="$nodes_per_round_input"
    fi

    if [ "$nodes_per_round" -gt ${#node_ids[@]} ]; then
        nodes_per_round=${#node_ids[@]}
        echo "提示：每轮启动数量已自动调整为节点总数 ${#node_ids[@]}。"
    fi

    # 计算需要多少组
    local total_nodes=${#node_ids[@]}
    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    echo "节点将分为 $num_groups 组进行轮换。"
    
    # 估算每节点内存分配，这是基于用户输入的每轮节点数量，并非所有节点的总和
    local estimated_per_node_mem_mb=$(calculate_per_node_memory_mb "$nodes_per_round" "$mem_percent")
    if [ "$estimated_per_node_mem_mb" -eq 0 ]; then
        echo "根据您的配置和系统内存，无法为每轮节点分配有效内存（可能低于512MB的最低要求）。请检查每轮节点数量或百分比。"
        read -p "按任意键返回菜单"
        return
    fi
    echo "每轮（最多 ${nodes_per_round} 个）节点将共享系统内存，预计每个节点将分配约 ${estimated_per_node_mem_mb}MB 内存。"


    # 直接删除旧的轮换进程
    echo "停止旧的轮换进程 (如果存在)..."
    pm2 delete nexus-rotate 2>/dev/null || true

    echo "开始构建镜像..."
    build_image

    # 创建启动脚本目录
    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir" || { echo "错误：无法创建脚本目录 '$script_dir'。请检查权限。"; exit 1; }
    if [ ! -d "$script_dir" ]; then
        echo "错误：脚本目录 '$script_dir' 未能成功创建。"
        exit 1
    fi

    # 内存计算的辅助函数，用于嵌入到生成的脚本中
    # 这些变量需要是硬编码的，以确保生成的脚本是独立的
    local mem_calc_block_template='
# --- 内存分配逻辑 (由主脚本生成) ---
get_total_system_ram_mb() {
    awk '\''/MemTotal:/ {print int($2/1024)}'\'' /proc/meminfo
}

calculate_per_node_memory_mb() {
    local num_nodes_to_allocate=$1
    local percentage=$2
    local total_ram_mb=$(get_total_system_ram_mb)
    if [ "$num_nodes_to_allocate" -eq 0 ]; then echo 0; return; fi
    local allocatable_ram_mb=$(( (total_ram_mb * percentage) / 100 ))
    local per_node_ram_mb=$(( allocatable_ram_mb / num_nodes_to_allocate ))
    local min_per_node_mb=512 # 最低512MB每节点
    if [ "$per_node_ram_mb" -lt "$min_per_node_mb" ]; then
        per_node_ram_mb="$min_per_node_mb"
    fi
    echo "$per_node_ram_mb"
}
# --- 内存分配逻辑结束 ---
'

    # 为每组创建启动脚本
    for ((group=1; group<=num_groups; group++)); do
        local current_group_nodes_count=0
        local start_idx=$(( (group-1) * nodes_per_round ))
        local end_idx=$(( start_idx + nodes_per_round ))
        if [ "$end_idx" -gt "$total_nodes" ]; then
            end_idx="$total_nodes"
        fi
        
        # 计算当前组的实际节点数量
        current_group_nodes_count=$(( end_idx - start_idx ))

        # 构建组启动脚本内容
        cat > "$script_dir/start_group${group}.sh" <<EOF
#!/bin/bash
set -e

# These are hardcoded to match the main script's globals and ensure self-containment
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs" # Consistent with main script's global LOG_DIR

# 确保日志目录存在且可写 (在 host 上创建)
mkdir -p "\$LOG_DIR" || { echo "[$(date '+%Y-%m-%d %H:%M:%S')] 错误：无法创建日志目录 '\$LOG_DIR'。请检查权限。" >&2; exit 1; }
if [ ! -d "\$LOG_DIR" ]; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 错误：日志目录 '\$LOG_DIR' 未能成功创建。" >&2;
    exit 1
fi
if [ ! -w "\$LOG_DIR" ]; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 错误：日志目录 '\$LOG_DIR' 不可写。请检查权限。" >&2;
    exit 1
fi

${mem_calc_block_template} # 嵌入内存计算函数

# 计算当前轮次节点分配的内存
NUM_NODES_THIS_ROUND=${current_group_nodes_count} # 这一组要启动的节点数量
MEMORY_PERCENTAGE_TOTAL_ALLOC=${mem_percent} # 用于所有Nexus节点的系统总内存百分比 (由主脚本传入)
PER_NODE_MEM_MB=\$(calculate_per_node_memory_mb "\$NUM_NODES_THIS_ROUND" "\$MEMORY_PERCENTAGE_TOTAL_ALLOC")

if [ "\$PER_NODE_MEM_MB" -eq 0 ]; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 警告: 无法为本轮节点分配有效内存。跳过启动本轮次。" >&2
    exit 1
fi
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 本轮将启动 ${current_group_nodes_count} 个节点，每个节点分配 \${PER_NODE_MEM_MB}MB 内存。"

# 停止并删除所有与 BASE_CONTAINER_NAME 匹配的现有容器，确保只有本轮次节点运行
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 停止并删除所有现有 Nexus 容器..."
# 使用 || true 防止没有容器时 xargs 报错，这会阻止轮换脚本的继续执行
docker ps -a --filter "name=\${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f || true

# 启动第${group}组节点
EOF
        
        # 将节点添加到对应的启动脚本
        for (( i=start_idx; i<end_idx; i++ )); do
            local node_id=${node_ids[$i]}
            local container_name="${BASE_CONTAINER_NAME}-${node_id}"
            local log_file="${LOG_DIR}/nexus-${node_id}.log" # 这是指宿主机上的路径

            # 确保宿主机上的日志文件已准备好用于卷挂载
            # 优先检查是否存在目录冲突
            echo "
if [ -d \"$log_file\" ]; then
    echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 警告: 日志文件路径 '$log_file' 冲突，是目录。将尝试删除以便创建文件。\" >&2
    rm -rf \"$log_file\" || { echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 错误: 无法删除目录 '$log_file'。请手动删除或检查权限。\" >&2; exit 1; }
fi
[ -f \"$log_file\" ] || touch \"$log_file\" || { echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 错误: 无法创建日志文件 '$log_file'。请检查目录权限。\" >&2; exit 1; }
chmod 644 \"$log_file\" || { echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 警告: 无法设置日志文件 '$log_file' 的权限。\" >&2; }
" >> "$script_dir/start_group${group}.sh"

            echo "echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 正在启动节点 '$node_id' ...\"" >> "$script_dir/start_group${group}.sh"
            # Docker run 命令也添加错误处理
            echo "docker run -d --name \"\$container_name\" -v \"\$log_file\":/root/nexus.log -e NODE_ID=\"\$node_id\" -m \"\${PER_NODE_MEM_MB}m\" \"\$IMAGE_NAME\" || { echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 错误: 容器 \$container_name 启动失败。\" >&2; docker logs \"\$container_name\" >&2; }" >> "$script_dir/start_group${group}.sh"
            echo "sleep 1" >> "$script_dir/start_group${group}.sh" # 同批次节点间短暂延迟
        done
        echo "sleep 5" >> "$script_dir/start_group${group}.sh" # 组内节点启动后稍作停顿
    done

    # 创建轮换脚本
    cat > "$script_dir/rotate.sh" <<EOF
#!/bin/bash
set -e

# 在开始轮换前确保日志目录可写
mkdir -p "$LOG_DIR" || { echo "[$(date '+%Y-%m-%d %H:%M:%S')] 轮换错误：无法创建日志目录 '\$LOG_DIR'。" >&2; exit 1; }

echo "[$(date '+%Y-%m-%d %H:%M:%S')] 启动 Nexus 节点轮换任务。"
echo "总共有 ${total_nodes} 个节点，将分为 ${num_groups} 组，每轮启动 ${nodes_per_round} 个节点（最后一组可能不足）。"
echo "轮换周期：2小时。"

while true; do
EOF

    # 添加每组启动命令到轮换脚本
    for ((group=1; group<=num_groups; group++)); do
        local start_idx=$(( (group-1) * nodes_per_round ))
        local end_idx=$(( group * nodes_per_round ))
        if [ $end_idx -gt $total_nodes ]; then
            end_idx=$total_nodes
        fi
        local current_group_nodes_count=$(( end_idx - start_idx ))

        cat >> "$script_dir/rotate.sh" <<EOF
    echo "" # 空行以增加日志可读性
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] --- 轮换到第 ${group} 组节点 (${current_group_nodes_count}个节点) ---"
    # 执行生成的组启动脚本
    bash "$script_dir/start_group${group}.sh" || { echo "[$(date '+%Y-%m-%d %H:%M:%S')] 错误：执行启动组脚本失败，本轮次可能未完全启动。" >&2; }
    
    # 容器健康检查（针对本批次启动的节点）
    if [ ${current_group_nodes_count} -gt 0 ]; then
        local check_interval=5 # 秒
        local max_checks=6   # 检查总时长 30 秒 (6 * 5)
        local launched_node_prefix="${BASE_CONTAINER_NAME}-" 

        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 检查本轮次节点启动状态..."
        for ((c=1; c<=max_checks; c++)); do
            local all_running=true
            for i_check in $(seq $start_idx $((end_idx-1))); do
                local node_id_check="${node_ids[$i_check]}"
                local container_name_check="\${launched_node_prefix}\${node_id_check}"
                if ! docker ps --filter "name=\${container_name_check}" --filter "status=running" --format "{{.Names}}" | grep -qw "\${container_name_check}"; then
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 节点 \${node_id_check} 仍在启动或已退出，等待中... (检查 \$c/${max_checks})" >&2
                    docker logs "\${container_name_check}" 2>&1 | tail -n 5 >&2 # 显示最后5行日志
                    all_running=false
                    break
                fi
            done
            if \$all_running; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] 本轮所有节点启动并运行正常。"
                break
            elif [ \$c -eq \$max_checks ]; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] 警告: 部分本轮节点启动后未持续运行。请检查上述错误日志以获取详情。" >&2
            fi
            sleep \$check_interval
        done
    fi

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 第 ${group} 组节点已启动。等待2小时进行下一次轮换..."
    sleep 7200 # 2 小时 = 7200 秒

EOF
    done

    # 完成轮换脚本
    echo "done" >> "$script_dir/rotate.sh"

    # 设置脚本权限
    chmod +x "$script_dir"/*.sh

    # 使用 pm2 启动轮换脚本，并将输出重定向到文件
    pm2 start "$script_dir/rotate.sh" --name "nexus-rotate" --output "$script_dir/nexus-rotate.log" --error "$script_dir/nexus-rotate.err.log" || { echo "错误: PM2 启动轮换进程失败。请检查 pm2 是否正常工作。"; exit 1; }
    pm2 save --force || echo "警告: PM2 保存配置失败，这可能导致下次系统重启后 pm2 进程不会自动恢复。"

    echo "节点轮换已启动！"
    echo "使用 'pm2 status' 查看运行状态"
    echo "使用 'pm2 logs nexus-rotate' 或 'tail -f $script_dir/nexus-rotate.log' 查看轮换日志"
    echo "使用 'pm2 logs nexus-rotate --err' 或 'tail -f $script_dir/nexus-rotate.err.log' 查看轮换错误日志"
    echo "使用 'pm2 stop nexus-rotate' 停止轮换进程"
    echo "使用 'pm2 delete nexus-rotate' 删除轮换进程（将导致永久停止）"
    read -p "按任意键返回菜单"
}

# 设置定时清理日志任务（每2天清理一次，只保留最近2天的日志）
function setup_log_cleanup_cron() {
    # 确保在设置 cron 任务时，日志目录是存在的，因为 cron 任务是独立的
    mkdir -p "$LOG_DIR" || { echo "错误: 无法创建日志目录 '$LOG_DIR' 以设置日志清理定时任务。请检查权限。"; return; }
    
    local cron_job="0 3 */2 * * find $LOG_DIR -type f -name 'nexus-*.log' -mtime +2 -delete"
    # 检查是否已存在相同的定时任务，避免重复添加
    if ! crontab -l 2>/dev/null | grep -Fq "$cron_job"; then
        (crontab -l 2>/dev/null; echo "$cron_job") | crontab - || { echo "错误: 无法设置日志清理定时任务。请检查 'crontab' 命令是否可用及权限。"; }
        echo "已设置每2天自动清理日志任务，只保留最近2天的日志。"
    else
        echo "日志清理定时任务已存在，无需重复设置。"
    fi
}

# 主菜单
clear # 在显示菜单前清屏
echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
echo "如有问题，可联系推特，仅此只有一个号"
echo "=========================================================================="
echo "                         !!! 启 动 提 示 !!!"
echo "为确保脚本正常运行和管理日志文件，本脚本通常需要root权限。"
echo "推荐使用 'sudo ./nexus_manager.sh' 来执行。"
echo "如果选择普通用户执行，请确保您有在 '$LOG_DIR' ('/root/nexus_logs') 写入的权限，"
echo "或将脚本顶部的 'LOG_DIR' 修改为用户可访问的路径 (例如 '$HOME/nexus_logs')。"
echo "=========================================================================="
read -p "按任意键继续运行主菜单..."

setup_log_cleanup_cron # 启动时尝试设置日志清理 cron 任务

while true; do
    clear
    echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
    echo "如有问题，可联系推特，仅此只有一个号"
    echo "========== Nexus 多节点管理 =========="
    echo "1. 安装并启动新节点 (单个节点，手动指定内存)"
    echo "2. 显示所有节点状态 (CPU/内存使用情况)"
    echo "3. 批量停止并卸载指定节点 (可选择多个)"
    echo "4. 查看指定节点日志 (支持去色)"
    echo "5. 批量节点启动 (同时启动所有节点，按百分比均分内存)"
    echo "6. 批量节点轮换启动 (分批启动，每批按百分比均分内存，自动轮换)"
    echo "7. 删除全部节点 (危险操作，彻底清理所有节点及日志)"
    echo "8. 退出"
    echo "==================================="

    read -rp "请输入选项(1-8): " choice

    case $choice in
        1)
            start_single_node
            ;;
        2)
            list_nodes
            ;;
        3)
            batch_uninstall_nodes
            ;;
        4)
            select_node_to_view
            ;;
        5)
            check_docker
            batch_start_nodes
            ;;
        6)
            check_docker
            batch_rotate_nodes
            ;;
        7)
            uninstall_all_nodes
            ;;
        8)
            echo "退出脚本。再见！"
            exit 0
            ;;
        *)
            echo "无效选项，请重新输入。"
            read -p "按任意键继续"
            ;;
    esac
done
