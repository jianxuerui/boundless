#!/bin/bash
set -e

# ================================================================================================
# Nexus 多节点管理脚本 (ARM64 Docker) - 魔改·终极版 v4.1
#
# 原作者: 哈哈哈哈 (推特 @ferdie_jhovie)
# 魔改者: AI & 社区智慧
#
# 【V4.1 更新】:
#   - 【关键修复】修复了 'unexpected EOF while looking for matching `''`' 错误。
#   - 【代码优化】重构了所有 `read -rp` 提示符的实现方式，移除了复杂的函数嵌套，
#     直接在字符串中使用颜色变量，彻底杜绝了由此引发的引号匹配问题。
#
# 【V4.0 更新】:
#   - 【功能重构】: 菜单重新划分为 "节点管理", "批量操作", "系统维护", 结构更清晰。
#   - 【功能新增】: 增加对节点的 停止/启动/重启 功能，支持单个和批量操作。
#   - 【交互升级】: 引入彩色日志输出，状态列表根据运行状态显示不同颜色，信息更直观。
#   - 【核心增强】: 增加强大的更新机制，可一键更新 nexus-cli 版本并滚动升级所有正在运行的节点。
#   - 【配置优化】: 所有核心配置项移至脚本顶部，修改 nexus-cli 版本等操作只需改动一个变量。
# ================================================================================================

# --- 配置项 (可在此处自定义) ---
SCRIPT_VERSION="v4.1 终极修复版"
NEXUS_CLI_VERSION="v0.10.3"  # <--- 这里已更新至 v0.10.3
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest-arm64"
LOG_DIR="/root/nexus_logs"
BUILDER_NAME="nexus_builder"

# --- 颜色定义 ---
COLOR_RESET='\033[0m'
COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[0;33m'
COLOR_BLUE='\033[0;34m'
COLOR_CYAN='\033[0;36m'

# --- 辅助函数 ---
print_color() { echo -e "${2}${1}${COLOR_RESET}"; }
print_success() { print_color "$1" "$COLOR_GREEN"; }
print_error() { print_color "$1" "$COLOR_RED"; }
print_warning() { print_color "$1" "$COLOR_YELLOW"; }
print_info() { print_color "$1" "$COLOR_CYAN"; }

# 【关键修复】重写 confirm_action 以避免复杂的提示符构建
confirm_action() {
    local prompt_message="$1"
    read -rp "${COLOR_YELLOW}${prompt_message} (y/N): ${COLOR_RESET}" confirm
    [[ "$confirm" =~ ^[yY]([eE][sS])?$ ]]
}
trap 'rm -rf "$TMP_WORKDIR"' EXIT HUP INT QUIT TERM
TMP_WORKDIR=""

# --- 核心功能函数 ---
check_docker_daemon() {
    if ! docker info >/dev/null 2>&1; then
        print_error "!! 致命错误: Docker 服务未运行或当前用户无权访问 !!"
        print_error "请确保 Docker 已启动 (systemctl start docker) 并以 root 用户运行脚本 (sudo su)。"
        exit 1
    fi
}

check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        print_warning "未检测到 Docker, 正在尝试自动安装..."
        apt-get update >/dev/null
        apt-get install -y apt-transport-https ca-certificates curl software-properties-common >/dev/null
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - >/dev/null
        add-apt-repository -y "deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" >/dev/null
        apt-get update >/dev/null
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin >/dev/null
        systemctl enable --now docker
        print_success "Docker 安装完成。"
    fi
    if ! docker buildx version >/dev/null 2>&1; then
        print_error "错误：未找到 Docker buildx 插件。请检查 Docker 安装是否完整。"
        exit 1
    fi
}

setup_buildx() {
    if docker buildx ls | grep -q "^${BUILDER_NAME}.*running"; then
        docker buildx use $BUILDER_NAME >/dev/null
        return
    fi
    print_info "首次运行，正在设置 Buildx 环境..."
    if docker buildx ls | grep -q "$BUILDER_NAME"; then
        docker buildx inspect $BUILDER_NAME --bootstrap >/dev/null
    else
        docker buildx create --name $BUILDER_NAME --driver docker-container --use >/dev/null
    fi
    if ! docker run --rm --privileged tonistiigi/binfmt | grep -q "setting up"; then
       docker run --rm --privileged tonistiigi/binfmt --install all >/dev/null
    fi
    print_success "Buildx 环境设置完成。"
}

build_image() {
    local force_build=${1:-""}
    if [[ -z "$force_build" ]] && docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        return
    fi
    
    setup_buildx
    TMP_WORKDIR=$(mktemp -d)
    cd "$TMP_WORKDIR"
    
    local cli_url="https://github.com/nexus-xyz/nexus-cli/releases/download/${NEXUS_CLI_VERSION}/nexus-network-linux-arm64"
    
    print_info "正在生成 Dockerfile 及 entrypoint 脚本..."
    printf '%s\n' \
      'ARG TARGETPLATFORM=linux/arm64' \
      'FROM --platform=$TARGETPLATFORM ubuntu:24.04' \
      'ENV DEBIAN_FRONTEND=noninteractive' \
      'RUN apt-get update && apt-get install -y curl screen bash && rm -rf /var/lib/apt/lists/*' \
      "RUN curl -L -o /usr/local/bin/nexus-network ${cli_url} && chmod +x /usr/local/bin/nexus-network" \
      'COPY entrypoint.sh /entrypoint.sh' \
      'RUN chmod +x /entrypoint.sh' \
      'ENTRYPOINT ["/entrypoint.sh"]' > Dockerfile

    printf '%s\n' \
      '#!/bin/bash' \
      'set -e' \
      'if [ -z "$NODE_ID" ]; then echo "错误: NODE_ID 环境变量未设置!" >&2; exit 1; fi' \
      'mkdir -p /root/.nexus && echo "$NODE_ID" > /root/.nexus/node-id' \
      'if ! command -v nexus-network >/dev/null 2>&1; then echo "错误: nexus-network 命令不存在!" >&2; exit 1; fi' \
      'screen -S nexus -X quit >/dev/null 2>&1 || true' \
      'echo "正在后台启动 Nexus 节点 (NODE_ID: $NODE_ID)..."' \
      'screen -dmS nexus bash -c "nexus-network start --node-id $NODE_ID | tee /root/nexus.log"' \
      'sleep 3' \
      'if ! screen -list | grep -q "nexus"; then' \
      '  echo "!! 启动失败，请检查日志 !! " >&2; cat /root/nexus.log; exit 1;' \
      'fi' \
      'echo "节点启动成功，正在持续输出日志..."' \
      'tail -f /root/nexus.log' > entrypoint.sh

    print_info "正在构建节点镜像 (版本: ${NEXUS_CLI_VERSION})，此过程可能需要几分钟..."
    docker buildx build --builder "$BUILDER_NAME" --platform linux/arm64 -t "$IMAGE_NAME" . --load >/dev/null
    cd - >/dev/null
    rm -rf "$TMP_WORKDIR"
    TMP_WORKDIR=""
    print_success "镜像 '$IMAGE_NAME' 构建完成。"
}

run_container() {
    local node_id="$1"
    if [ -z "$node_id" ]; then print_error "错误: 未提供 Node ID"; return 1; fi
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    docker rm -f "$container_name" >/dev/null 2>&1
    mkdir -p "$LOG_DIR"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"
    touch "$log_file" && chmod 644 "$log_file"
    print_info "正在启动节点 ${node_id}..."
    docker run -d --name "$container_name" \
        -v "$log_file:/root/nexus.log" \
        -e NODE_ID="$node_id" \
        --restart unless-stopped \
        "$IMAGE_NAME" >/dev/null
    
    sleep 2
    if ! docker ps --filter "name=${container_name}" --filter "status=running" | grep -q ${container_name}; then
        print_error "节点 ${node_id} 启动失败！请使用日志功能检查原因。"
        print_error "日志文件: $log_file"
    else
        print_success "节点 $node_id 已成功启动。日志: $log_file"
    fi
}

stop_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_info "正在停止节点 $node_id..."
        docker stop "$container_name" > /dev/null
        print_success "节点 $node_id 已停止。"
    else
        print_error "未找到节点 $node_id。"
    fi
}

start_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_info "正在启动节点 $node_id..."
        docker start "$container_name" > /dev/null
        print_success "节点 $node_id 已启动。"
    else
        print_error "未找到节点 $node_id。请先安装。"
    fi
}

restart_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_info "正在重启节点 $node_id..."
        docker restart "$container_name" > /dev/null
        print_success "节点 $node_id 已重启。"
    else
        print_error "未找到节点 $node_id。"
    fi
}

uninstall_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    print_info "正在卸载节点 $node_id..."
    docker rm -f "$container_name" >/dev/null 2>&1
    rm -f "${LOG_DIR}/nexus-${node_id}.log"
    print_success "节点 $node_id 已卸载。"
}

get_all_node_ids() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort -u
}

view_node_logs() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_error "错误: 未找到容器 $container_name。"
        return 1
    fi
    print_info "按 Ctrl+C 退出日志查看。"
    docker logs -f "$container_name"
}

list_nodes() {
    print_color "============================== 当前 Nexus 节点状态 ===============================" "$COLOR_BLUE"
    printf "%-28s %-18s %-12s %-18s %s\n" "节点 ID (容器名)" "状态" "CPU %" "内存使用" "镜像"
    print_color "--------------------------------------------------------------------------------------" "$COLOR_BLUE"
    
    local all_containers_info
    all_containers_info=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}\t{{.Status}}\t{{.Image}}")

    if [ -z "$all_containers_info" ]; then
        print_warning "未找到任何 Nexus 节点容器。"
    else
        local running_containers_list
        running_containers_list=$(echo "$all_containers_info" | grep -E "Up|running" | awk '{print $1}')
        local stats_output=""
        if [ -n "$running_containers_list" ]; then
            stats_output=$(docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" $(echo "$running_containers_list" | tr '\n' ' '))
        fi

        echo "$all_containers_info" | while IFS=$'\t' read -r name status image; do
            local node_id
            node_id=$(echo "$name" | sed "s/${BASE_CONTAINER_NAME}-//")
            local cpu_perc="N/A"
            local mem_usage="N/A"
            local formatted_status="$status"

            if echo "$status" | grep -q "Up"; then
                local stats_line
                stats_line=$(echo "$stats_output" | grep -w "$name")
                if [ -n "$stats_line" ]; then
                    cpu_perc=$(echo "$stats_line" | awk '{print $2}')
                    mem_usage=$(echo "$stats_line" | awk -F '\t' '{print $3}')
                fi
                formatted_status=$(print_color "$status" "$COLOR_GREEN")
            elif echo "$status" | grep -q "Exited"; then
                formatted_status=$(print_color "$status" "$COLOR_YELLOW")
            else
                formatted_status=$(print_color "$status" "$COLOR_RED")
            fi
            
            printf "%-28s %-28s %-12s %-18s %s\n" "$node_id ($name)" "$formatted_status" "$cpu_perc" "$mem_usage" "$image"
        done
    fi
    print_color "======================================================================================" "$COLOR_BLUE"
}

# --- 菜单处理函数 ---
select_node_action() {
    local action_callback="$1"
    local prompt_message="$2"
    local all_nodes=()
    while IFS= read -r line; do all_nodes+=("$line"); done < <(get_all_node_ids)

    if [ ${#all_nodes[@]} -eq 0 ]; then
        print_warning "当前无任何节点可操作。"
        read -n 1 -s -r -p "按任意键返回..."
        return
    fi
    
    echo "请选择要'${prompt_message}'的节点:"
    for i in "${!all_nodes[@]}"; do
        local node_id="${all_nodes[$i]}"
        local status
        status=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-${node_id}" --format "{{.Status}}")
        printf "  %2d. 节点 %-25s [%s]\n" "$((i+1))" "$node_id" "$status"
    done
    echo "   0. 返回主菜单"
    
    read -rp "请输入选项 (0-${#all_nodes[@]}): " choice
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt ${#all_nodes[@]} ]; then
        print_error "无效输入。"
        sleep 1
        return
    fi
    [ "$choice" -eq 0 ] && return
    
    local selected_node_id="${all_nodes[$((choice-1))]}"
    "$action_callback" "$selected_node_id"
    read -n 1 -s -r -p "操作完成，按任意键返回..."
}

select_multiple_nodes_action() {
    local action_callback="$1"
    local prompt_message="$2"
    local all_nodes=()
    while IFS= read -r line; do all_nodes+=("$line"); done < <(get_all_node_ids)
    if [ ${#all_nodes[@]} -eq 0 ]; then
        print_warning "当前无任何节点可操作。"
        read -n 1 -s -r -p "按任意键返回..."
        return
    fi
    
    echo "请选择要'${prompt_message}'的节点 (可输入多个, 用空格隔开, 或输入'all'全选):"
    for i in "${!all_nodes[@]}"; do
        printf "  %2d. %s\n" "$((i+1))" "${all_nodes[$i]}"
    done
    echo "   0. 返回主菜单"

    read -rp "请输入选项: " choices_str
    if [[ -z "$choices_str" ]] || [[ "$choices_str" == "0" ]]; then return; fi

    local selected_nodes=()
    if [[ "$choices_str" == "all" ]]; then
        selected_nodes=("${all_nodes[@]}")
    else
        for choice in $choices_str; do
            if [[ "$choice" =~ ^[1-9][0-9]*$ ]] && [ "$choice" -le ${#all_nodes[@]} ]; then
                selected_nodes+=("${all_nodes[$((choice-1))]}")
            else
                print_error "输入 '$choice' 无效, 已忽略。"
            fi
        done
    fi

    if [ ${#selected_nodes[@]} -eq 0 ]; then
        print_warning "未选择任何有效节点。"
        sleep 1
        return
    fi
    
    echo "将要对以下节点执行'${prompt_message}': ${selected_nodes[*]}"
    if confirm_action "确认执行吗?"; then
        for node_id in "${selected_nodes[@]}"; do
            "$action_callback" "$node_id"
            sleep 0.5
        done
        print_success "批量操作执行完毕。"
    else
        print_info "操作已取消。"
    fi
    read -n 1 -s -r -p "按任意键返回..."
}

menu_install_single() {
    read -rp "请输入要安装的 Node ID: " node_id
    if [ -n "$node_id" ]; then
        build_image
        run_container "$node_id"
    else
        print_warning "未输入 Node ID，操作取消。"
    fi
    read -n 1 -s -r -p "按任意键返回..."
}

menu_batch_install() {
    build_image
    print_info "请输入多个 Node ID，每行一个，输入空行结束:"
    local node_ids=()
    while IFS= read -r line; do
        line=$(echo "$line" | xargs)
        [ -z "$line" ] && break
        node_ids+=("$line")
    done
    
    if [ ${#node_ids[@]} -eq 0 ]; then
        print_warning "未输入任何 Node ID，操作取消。"
    else
        for node_id in "${node_ids[@]}"; do
            run_container "$node_id"
            sleep 1
        done
        print_success "批量安装任务完成。"
    fi
    read -n 1 -s -r -p "按任意键返回..."
}

menu_update() {
    while true; do
        clear
        print_info "=========== 系统维护与更新 ==========="
        echo "当前 nexus-cli 版本: ${NEXUS_CLI_VERSION}"
        echo "当前 Docker 镜像: ${IMAGE_NAME}"
        echo
        echo " 1. 强制重新构建镜像 (如需更新 nexus-cli 版本)"
        echo " 2. 一键更新所有正在运行的节点 (将使用最新镜像重建)"
        echo " 3. 完全卸载 (删除所有节点、镜像、日志)"
        echo " 0. 返回主菜单"
        echo
        read -rp "请输入选项: " choice
        
        case $choice in
            1) 
               if confirm_action "将强制重新构建 '$IMAGE_NAME' 镜像。确认吗?"; then
                   build_image "--force"
               else
                   print_info "操作已取消。"
               fi
               read -n 1 -s -r -p "按任意键返回..."
               ;;
            2)
               print_warning "此操作将使用最新镜像重新创建所有正在运行的节点。"
               print_warning "将先停止并删除旧容器，然后用相同Node ID启动新容器。"
               if confirm_action "确认更新所有运行中的节点吗?"; then
                   print_info "第1步: 强制构建最新镜像..."
                   build_image "--force"
                   print_info "第2步: 查找正在运行的节点并进行更新..."
                   local running_nodes
                   running_nodes=($(docker ps --filter "name=${BASE_CONTAINER_NAME}-" --filter "status=running" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"))
                   if [ ${#running_nodes[@]} -eq 0 ]; then
                       print_warning "没有正在运行的节点可供更新。"
                   else
                       for node_id in "${running_nodes[@]}"; do
                           print_info "--- 正在更新节点: $node_id ---"
                           uninstall_node "$node_id" >/dev/null
                           run_container "$node_id"
                           echo
                       done
                       print_success "所有正在运行的节点已更新完毕。"
                   fi
               else
                   print_info "操作已取消。"
               fi
               read -n 1 -s -r -p "按任意键返回..."
               ;;
            3)
               if confirm_action "警告: 这将删除所有节点容器和日志。确定吗?"; then
                   if confirm_action "再次确认: 真的要删除所有节点和日志吗?"; then
                        for node_id in $(get_all_node_ids); do uninstall_node "$node_id"; done
                        print_success "所有节点已卸载。"
                        if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                           if confirm_action "是否也删除 Docker 镜像 '$IMAGE_NAME'?"; then
                               docker rmi -f "$IMAGE_NAME"
                               print_success "镜像已删除。"
                           fi
                        fi
                        if [ -d "$LOG_DIR" ]; then
                           if confirm_action "是否也删除日志目录 '$LOG_DIR'?"; then
                               rm -rf "$LOG_DIR"
                               print_success "日志目录已删除。"
                           fi
                        fi
                   else
                       print_info "操作已取消。"
                   fi
               else
                   print_info "操作已取消。"
               fi
               read -n 1 -s -r -p "按任意键返回..."
               ;;
            0) break ;;
            *) print_error "无效选项。" && sleep 1;;
        esac
    done
}


# --- 主菜单循环 ---
main_menu() {
    if [ "$(id -u)" -ne 0 ]; then print_error "错误: 请使用 root 权限运行此脚本 (例如: sudo ./your_script.sh)。" >&2; exit 1; fi
    check_docker_daemon
    check_docker

    while true; do
        clear
        print_color "脚本由哈哈哈哈编写, 社区魔改, 推特 @ferdie_jhovie, 免费开源" "$COLOR_BLUE"
        print_color "============= Nexus 管理 (${SCRIPT_VERSION}) =============" "$COLOR_CYAN"
        list_nodes

        print_info "\n--- 节点管理 ---"
        echo " 1. 安装/启动单个节点        4. 停止指定节点"
        echo " 2. 查看指定节点日志         5. 启动已停止的节点"
        echo " 3. 卸载指定节点             6. 重启指定节点"

        print_info "\n--- 批量操作 ---"
        echo " 7. 批量安装/启动节点        10. 批量卸载节点"
        echo " 8. 批量停止节点             "
        echo " 9. 批量启动节点             "

        print_info "\n--- 系统维护 ---"
        echo " 11. 系统更新与维护"
        echo "  0. 退出脚本"
        
        # 【关键修复】使用更简单、更健壮的方式来显示带颜色的提示符
        read -rp "${COLOR_YELLOW}请输入选项: ${COLOR_RESET}" choice
        
        case $choice in
            1) menu_install_single ;;
            2) select_node_action "view_node_logs" "查看日志" ;;
            3) select_node_action "uninstall_node" "卸载" ;;
            4) select_node_action "stop_node" "停止" ;;
            5) select_node_action "start_node" "启动" ;;
            6) select_node_action "restart_node" "重启" ;;
            
            7) menu_batch_install ;;
            8) select_multiple_nodes_action "stop_node" "停止" ;;
            9) select_multiple_nodes_action "start_node" "启动" ;;
            10) select_multiple_nodes_action "uninstall_node" "卸载" ;;

            11) menu_update ;;
            0) echo "感谢使用，退出脚本。"; exit 0 ;;
            *) print_error "无效选项。"; sleep 1 ;;
        esac
    done
}

# --- 脚本执行入口 ---
main_menu
