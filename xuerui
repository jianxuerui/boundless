#!/bin/bash
# 作者: 哈哈哈哈 (推特 @ferdie_jhovie) | 本脚本免费开源，仅此唯一账号，谨防受骗
# 脚本目标: 管理 Nexus 节点，实现一键安装、启动、停止、日志查看、批量轮换等功能。
# 重要提示: 请确保您运行脚本的机器拥有足够的资源 (CPU/内存) 来运行节点。
#             对于单个节点，建议至少分配 2-4GB 内存。

set -e # 脚本遇到非零退出码时立即退出

BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs" # 宿主机上的 Nexus 日志存储目录

# !!! 定义默认的节点资源限制 !!!
# 根据您的服务器硬件配置和希望同时运行的节点数量来调整这些值。
# 如果服务器内存不足，应减小 MEMORY_LIMIT 或减少运行的节点数量。
DEFAULT_MEMORY_LIMIT="4g" # 每个节点最多可使用 4GB 内存
DEFAULT_CPUS_LIMIT="2"    # 每个节点最多使用 2 个 CPU 核心 (例如 2.0 表示 2个核心)

# --- 辅助函数 ---

# 检查 Docker 是否安装并运行
function check_docker() {
    if ! command -v docker &> /dev/null; then
        echo "错误：未检测到 Docker 命令。请先安装 Docker。"
        echo "正在尝试自动安装 Docker..."
        # ------------------ Docker 安装逻辑 ------------------
        # 判断是否是 root 用户，如果是，则直接执行，否则使用 sudo
        local SUDO=""
        if [[ "$EUID" -ne 0 ]]; then
            SUDO="sudo"
            echo "非 root 用户，将使用 sudo 执行 Docker 安装相关命令。"
        fi
        
        $SUDO apt update
        $SUDO apt install -y apt-transport-https ca-certificates curl software-properties-common
        # 使用 gpg-install 或 apt-key 来添加 GPG key，后者更旧但广泛支持
        # 如果有 apt-key 问题，可以尝试 $SUDO curl -fsSL https://download.docker.com/linux/ubuntu/gpg | $SUDO gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
        $SUDO apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 7EA0A30118C38AC4F0549DF5482F616D355B6C15 || \
        $SUDO apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 7EA0A30118C38AC4F0549DF5482F616D355B6C15
        
        # 使用新的方式添加 Docker apt 源，兼容性更好
        # $SUDO add-apt-repository "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        echo \
          "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
          $(lsb_release -cs) stable" | $SUDO tee /etc/apt/sources.list.d/docker.list > /dev/null
        
        $SUDO apt update
        $SUDO apt install -y docker-ce docker-ce-cli containerd.io
        
        # 启用并启动 Docker 服务
        $SUDO systemctl enable docker
        $SUDO systemctl start docker
        echo "Docker 安装完成并已启动服务。"
        
        # 检查 Docker 是否可以正常运行
        if ! docker info &> /dev/null; then
            echo "错误：Docker 服务未能成功启动，请检查 Docker 安装日志或手动排查。"
            exit 1
        fi
        echo "Docker 已成功安装并运行。"
        return 0 # 成功
    fi
    
    # 检查 Docker 服务是否在运行
    if ! systemctl is-active --quiet docker; then
        echo "错误：Docker 服务未运行。正在尝试启动..."
        local SUDO=""
        if [[ "$EUID" -ne 0 ]]; then SUDO="sudo"; fi
        $SUDO systemctl start docker
        if ! systemctl is-active --quiet docker; then
            echo "错误：未能成功启动 Docker 服务。请手动检查 'systemctl status docker'。"
            return 1 # 失败
        else
            echo "Docker 服务已启动。"
            return 0 # 成功
        fi
    fi
    # Docker 已安装且正在运行
    return 0 # 成功
}

# 检查 Node.js/npm/pm2 是否安装 (仅为批次轮换准备)
function check_pm2() {
    # 检查 Node.js 和 npm
    if ! command -v node &> /dev/null || ! command -v npm &> /dev/null; then
        echo "错误：未检测到 Node.js/npm。正在安装..."
        # 下载 NodeSource 的脚本来添加 Node.js 源
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
        apt-get install -y nodejs
        echo "Node.js 和 npm 安装完成。"
    fi
    
    # 检查 pm2
    if ! command -v pm2 &> /dev/null; then
        echo "错误：未检测到 pm2。正在安装..."
        npm install -g pm2
        echo "pm2 安装完成。"
    fi
}

# 构建 Docker 镜像函数
function build_image() {
    echo "======================================"
    echo " 开始构建 Docker 镜像 '$IMAGE_NAME'..."
    echo "======================================"
    
    # 创建一个临时目录用于构建
    WORKDIR=$(mktemp -d)
    if [ ! -d "$WORKDIR" ]; then
        echo "错误：无法创建临时目录用于 Docker 构建。"
        return 1
    fi
    cd "$WORKDIR"

    # 创建 Dockerfile
    cat > Dockerfile <<EOF
FROM ubuntu:24.04

LABEL maintainer="哈哈哈哈 <ferdie_jhovie@example.com>"
LABEL description="Nexus Node Image"

# 设置非交互模式，防止 apt 命令弹出确认对话框
ENV DEBIAN_FRONTEND=noninteractive
# !!! 修改这里：为 ENV 值加上双引号，避免 # 引发的 Syntax Error !!!
ENV NODE_ID="" # 节点ID由 Docker 运行时注入
ENV PROVER_ID_FILE="/root/.nexus/node-id"

# 安装基本工具和 Nexus 运行所需的环境
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    screen \
    bash \
    jq \ # 添加 jq，用于在脚本中解析 JSON 数据，如 docker inspect
    && rm -rf /var/lib/apt/lists/* \
    && echo "Base image updated and essentials installed."

# 自动下载并安装最新版 nexus-network
RUN echo "Downloading and installing the latest nexus-network..." && \
    curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh && \
    echo "nexus-network installation complete." && \
    ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network

# 复制启动脚本到容器内
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# 设置容器启动时执行的命令
ENTRYPOINT ["/entrypoint.sh"]
EOF

    # 创建 entrypoint.sh
    cat > entrypoint.sh <<EOF
#!/bin/bash
set -e # 脚本遇到非零退出码时立即退出

PROVER_ID_FILE="/root/.nexus/node-id"
NEXUS_LOG="/root/nexus.log"

# 检查NODE_ID环境变量是否已设置
if [ -z "\$NODE_ID" ]; then
    echo "错误：未设置 NODE_ID 环境变量。节点无法启动。"
    exit 1
fi

# 确保节点ID文件目录存在
mkdir -p "\$(dirname \$PROVER_ID_FILE)"
echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo "Nexus Node ID set to: \$NODE_ID"
echo "Prover ID file created at: \$PROVER_ID_FILE"

# 检查 nexus-network 是否已安装
if ! command -v nexus-network &> /dev/null; then
    echo "错误：nexus-network 未安装或无法在 PATH 中找到。请检查 Dockerfile 的安装步骤。"
    exit 1
fi

# 启动 Nexus Network
echo "Starting Nexus Network with Node ID: \$NODE_ID..."

# 使用 nohup 运行，输出重定向到日志文件，并将其放到后台
nohup nexus-network start --node-id "\$NODE_ID" &>> "\$NEXUS_LOG" &

# 轮询检查 nexus-network 是否在运行，并给其一定初始化时间
echo "Waiting for Nexus Network to initialize (up to 20 seconds)..."
INIT_COUNTER=0
MAX_INIT_TIME=20 # 增加等待时间以应对较慢的初始化
IS_RUNNING=false

while [ "\$INIT_COUNTER" -lt "\$MAX_INIT_TIME" ]; do
    # 检查 nexus-network 进程是否存在，以及日志文件是否开始有内容写入
    if pgrep nexus-network > /dev/null && [ -s "\$NEXUS_LOG" ]; then
        IS_RUNNING=true
        break
    fi
    sleep 1
    INIT_COUNTER=\$((INIT_COUNTER + 1))
done

if [ "\$IS_RUNNING" = "true" ]; then
    echo "Nexus Network started successfully."
    echo "Log file: \$NEXUS_LOG"
    # 使用 tail -f 保持容器运行，并将 nexus.log 的后续内容输出到 stdout (容器日志)
    tail -f "\$NEXUS_LOG"
else
    echo "错误：Nexus Network 未能成功启动。"
    echo "请检查日志文件 '\$NEXUS_LOG' 以获取详细信息："
    cat "\$NEXUS_LOG" # 输出部分或全部日志内容以帮助调试
    exit 1
fi
EOF

    # 执行 Docker 构建
    if ! docker build -t "$IMAGE_NAME" . --progress=plain; then # --progress=plain 使得构建过程日志更详细
        echo "错误：Docker 镜像构建失败。请检查 Dockerfile 和构建输出。"
        cd - > /dev/null
        rm -rf "$WORKDIR"
        return 1
    fi
    
    # 返回上一级目录并清理临时文件
    cd - > /dev/null
    rm -rf "$WORKDIR"
    echo "======================================"
    echo " Docker 镜像 '$IMAGE_NAME' 构建完成。"
    echo "======================================"
    return 0
}

# 启动单个 Nexus 容器函数
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo ""
    echo "--- 启动节点: $node_id ---"
    echo "    容器名: $container_name"
    echo "    日志文件: $log_file"
    echo "    内存限制: $DEFAULT_MEMORY_LIMIT"
    echo "    CPU 限制: $DEFAULT_CPUS_LIMIT"
    echo "----------------------------"

    # 检查是否已存在同名容器，如果有，先删除
    if docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        echo "发现同名容器 '$container_name'。正在尝试删除旧容器..."
        docker rm -f "${container_name}" > /dev/null 2>&1 || echo "警告: 删除旧容器 '$container_name' 失败。"
    fi

    # 确保日志目录存在
    mkdir -p "$LOG_DIR"
    if [ ! -d "$LOG_DIR" ]; then
        echo "错误：无法创建宿主机上的日志目录 '$LOG_DIR'。"
        return 1
    fi
    
    # 确保宿主机日志文件存在且可写
    if [ ! -f "$log_file" ]; then
        touch "$log_file"
        chmod 644 "$log_file" # 设置日志文件的读写权限
        echo "已创建日志文件: $log_file"
    fi
    # 确保日志文件所有者是你（如果你不是root执行脚本的话，这可能很重要）
    if [ "$EUID" -ne 0 ]; then
      chown $(whoami):$(whoami) "$log_file" # 明确指定用户和组
    fi

    echo "正在使用镜像 '$IMAGE_NAME' 启动新容器 '$container_name'..."
    
    # 启动容器，设置名称、内存限制、CPU限制、挂载日志文件、传递 NODE_ID
    if ! docker run -d \
            --name "${container_name}" \
            --memory "${DEFAULT_MEMORY_LIMIT}" \
            --cpus "${DEFAULT_CPUS_LIMIT}" \
            -v "${log_file}":"/root/nexus.log" \
            -e NODE_ID="${node_id}" \
            "${IMAGE_NAME}" > /dev/null; then
        echo "错误：启动容器 '$container_name' 失败！"
        echo "请检查以下信息:"
        echo "  - Docker 日志: 'docker logs $container_name'"
        echo "  - Nexus 节点日志: '$log_file'"
        echo "  - 服务器系统日志: 请查看 'journalctl -u docker'"
        return 1
    fi
    
    echo "容器 '$container_name' 已成功启动。"
    # 通过 docker inspect 获取启动后的 PID (如果有)
    local container_pid=$(docker inspect -f '{{.State.Pid}}' "$container_name" 2>/dev/null || echo "N/A")
    echo "    容器 PID: $container_pid"
    return 0
}

# 停止并卸载单个 Nexus 容器及相关资源
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo ""
    echo "--- 卸载节点: $node_id ---"
    
    # 停止并删除容器
    echo "    正在停止并删除容器 '$container_name'..."
    if docker ps -q -f name=${container_name} &> /dev/null; then
        # 如果容器正在运行，则先停止
        docker stop "${container_name}" > /dev/null 2>&1 || echo "    警告: 尝试停止容器 '$container_name' 但可能已停止或执行命令失败。"
    fi
    
    # 删除容器，即使不存在或已停止，执行命令也能安全处理
    docker rm "${container_name}" > /dev/null 2>&1 || echo "    警告: 尝试删除容器 '$container_name' 但可能不存在或已删除。"

    # 删除对应的日志文件
    if [ -f "$log_file" ]; then
        echo "    正在删除日志文件 '$log_file'..."
        rm -f "$log_file"
    else
        echo "    日志文件 '$log_file' 不存在，跳过删除。"
    fi
    echo "    节点 '$node_id' (容器 '$container_name') 卸载完成。"
    return 0
}

# 显示所有已部署 Nexus 节点的状态
function list_nodes() {
    echo ""
    echo "========================= Nexus 节点状态列表 =========================="
    # 表头：序号, 节点ID, CPU使用率, 内存使用, 内存限制, CPU限制, 状态, 创建时间
    printf "%-6s %-20s %-10s %-12s %-12s %-10s %-15s %-20s\n" "序号" "节点ID" "CPU%" "内存使用" "内存限制" "CPU核数" "状态" "创建时间"
    echo "--------------------------------------------------------------------------"
    
    # 获取所有匹配 BASE_CONTAINER_NAME 的容器ID，无论其状态如何
    local container_names=($(docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}"))
    
    if [ ${#container_names[@]} -eq 0 ]; then
        echo "当前系统中没有部署 Nexus 节点。"
    else
        local node_index=0
        for container_name in "${container_names[@]}"; do
            # 从容器名提取节点 ID
            local node_id="${container_name#${BASE_CONTAINER_NAME}-}"
            
            # 初始化显示变量为占位符
            local cpu_usage_display="-"
            local mem_usage_display="-"
            local mem_limit_display="-"
            local cpu_limit_display="-"
            local container_status="未知"
            local container_created_time="N/A"

            # 1. 获取容器基本信息: 状态, 创建时间
            local status_and_time=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}|{{.CreatedAt}}" 2>/dev/null)
            if [ -n "$status_and_time" ]; then
                container_status=$(echo "$status_and_time" | cut -d'|' -f1 | awk '{print $1}') # 只取状态的首个单词
                container_created_time=$(echo "$status_and_time" | cut -d'|' -f2)
            else
                container_status="不存在" # 理论上不会走到这里，因为是遍历 ps -a 的结果
            fi

            # 2. 获取容器资源限制信息 (来自 Docker Inspect)
            # 先尝试获取 docker inspect 的输出
            local inspect_data=$(docker inspect "${container_name}" 2>/dev/null)
            # 检查 inspect_data 是否有效且不是一个空的 JSON array `[]`
            if [ -n "$inspect_data" ] && [[ "$inspect_data" =~ ^\[.*\]$ ]] && [ "$inspect_data" != "[]" ]; then
                # 解析内存限制
                local mem_bytes_raw=$(echo "$inspect_data" | jq -r '.[0].HostConfig.Memory')
                # 安全地检查是否是数字，而不是 null 或空字符串
                if [[ "$mem_bytes_raw" =~ ^[0-9]+$ ]] && [ "$mem_bytes_raw" -gt 0 ]; then
                    mem_limit_display=$(awk -v bytes="$mem_bytes_raw" 'BEGIN {
                        suffixes="KMGTPEZY";
                        num = bytes;
                        unit = "B";
                        for (i=0; num >= 1024 && i<length(suffixes); ++i) {
                            num /= 1024;
                            unit = substr(suffixes, i+1, 1);
                        }
                        printf "%.1f%s", num, unit;
                    }')
                else
                    mem_limit_display="无限制" # 如果获取失败或为 0，显示无限制
                fi

                # 解析 CPU 限制 (NanoCPUs 转换为核心数)
                local nano_cpus_raw=$(echo "$inspect_data" | jq -r '.[0].HostConfig.NanoCPUs')
                if [[ "$nano_cpus_raw" =~ ^[0-9]+$ ]] && [ "$nano_cpus_raw" -gt 0 ]; then
                    cpu_limit_display=$(awk -v nano="$nano_cpus_raw" 'BEGIN { printf "%.2f", nano / 1e9 }')
                else
                    cpu_limit_display="无限制" # 如果获取失败或为 0，显示无限制
                fi
            else
                # 如果 inspect 命令失败或返回空/无效数据
                mem_limit_display="获取失败"
                cpu_limit_display="获取失败"
            fi

            # 3. 如果容器正在运行，则获取实时统计数据
            if [[ "$container_status" == "Up" ]]; then
                local stats_output=$(docker stats --no-stream --format "{{.CPUPerc}}|{{.MemUsage}}" "${container_name}" 2>/dev/null)
                if [ -n "$stats_output" ]; then
                    cpu_usage_display=$(echo "$stats_output" | cut -d'|' -f1 | sed 's/\%//g') # 移除 '%'
                    mem_usage_display=$(echo "$stats_output" | cut -d'|' -f2 | awk '{print $1}') # 取如 "1.5G/4.0G" 中的 "1.5G"
                fi
            fi
            
            # 打印该节点的详情
            node_index=$((node_index + 1))
            printf "%-6d %-20s %-10s %-12s %-12s %-10s %-15s %-20s\n" \
                "$node_index" \
                "$node_id" \
                "$cpu_usage_display" \
                "$mem_usage_display" \
                "$mem_limit_display" \
                "$cpu_limit_display" \
                "$container_status" \
                "$container_created_time"
        done
    fi
    echo "--------------------------------------------------------------------------"
    echo "提示:"
    echo "  - CPU%: 当前容器的 CPU 使用率百分比."
    echo "  - 内存使用: 当前容器正在使用的内存量 ('-' 表示已停止)."
    echo "  - 内存限制: 容器运行时设置的内存上限 (来自 '--memory' 参数)."
    echo "  - CPU核数: 容器运行时设置的 CPU 核心数 (来自 '--cpus' 参数)."
    echo "  - 状态: 容器的当前运行状态 (Up, Exited, Created)."
    echo "  - 创建时间: 容器被创建的时间."
    read -p "按任意键返回主菜单..."
}

# 获取所有已部署 Nexus 节点的 ID 列表
function get_all_node_ids() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 查看指定节点的日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    # 检查容器是否存在
    if ! docker ps -a --filter "name=${container_name}" --format "{{.Names}}" &> /dev/null; then
        echo ""
        echo "错误：节点 '$node_id' (容器 '$container_name') 在系统中未找到。"
        read -p "按任意键返回菜单..."
        return
    fi

    echo ""
    echo "正在查看节点 '$node_id' 的日志..."
    echo "按 Ctrl+C 退出日志实时跟踪。"
    echo ""
    echo "请选择日志显示模式:"
    echo "1. 原始日志 (包含颜色代码，最完整)"
    echo "2. 清理后的日志 (移除 ANSI 颜色代码)"
    
    read -rp "请输入选项 (1 或 2): " log_mode
    
    case "$log_mode" in
        1)
            docker logs -f "$container_name"
            ;;
        2)
            # 使用 sed 移除 ANSI 转义序列，使其更易读
            docker logs -f "$container_name" | sed -e 's/\x1b\[[0-9;]*m//g' -e 's/\x1b\[?25l//g' -e 's/\x1b\[?25h//g'
            ;;
        *)
            echo "无效选项。将使用原始日志模式。"
            docker logs -f "$container_name"
            ;;
    esac
    echo ""
    echo "已退出日志查看模式。"
}

# 批量启动多个节点
function batch_start_nodes() {
    echo ""
    echo "--- 批量启动 Nexus 节点 ---"
    echo "请输入您要启动的节点 IDs，每行一个，输入空行并按回车键结束输入："
    echo "例如:"
    echo "    node-001"
    echo "    node-002"
    echo "    ..."
    echo "输入完成后，按回车键，然后按 Ctrl+D (或 Ctrl+Z 在某些系统上) 结束输入。"
    
    local node_ids=()
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            node_ids+=("$line")
        fi
    done
    
    # 检查是否输入了节点 IDs
    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何节点 IDs。返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    # 提示：建议每次启动前都构建最新的镜像
    read -rp "是否每次启动节点前都构建最新的 Docker 镜像? (y/N): " build_image_choice
    if [[ "$build_image_choice" =~ ^[Yy]$ ]]; then
        if ! build_image; then
            echo "错误：镜像构建失败，无法启动节点。请检查上述错误信息。"
            read -p "按任意键继续..."
            return
        fi
    else
        echo "跳过镜像构建，将使用现有镜像（如果镜像不存在，启动将会失败）。"
    fi

    echo ""
    echo "开始启动以下 ${#node_ids[@]} 个节点："
    for node_id in "${node_ids[@]}"; do echo "    - $node_id"; done
    
    local launch_success_count=0
    local launch_fail_count=0
    
    for node_id in "${node_ids[@]}"; do
        echo "--- 尝试启动节点 '$node_id' ---"
        if run_container "$node_id"; then
            launch_success_count=$((launch_success_count + 1))
            sleep 5 # 在启动连续节点之间添加适当的延迟，以减少对系统的瞬时压力
        else
            launch_fail_count=$((launch_fail_count + 1))
            echo "!! 节点 '$node_id' 启动失败。"
        fi
    done

    echo ""
    echo "批量启动操作完成。"
    echo "成功启动 ${launch_success_count} 个节点，${launch_fail_count} 个节点启动失败。"
    read -p "按任意键返回主菜单..."
}

# 批量节点轮换启动管理
function batch_rotate_nodes() {
    echo ""
    echo "--- Nexus 节点轮换启动管理 ---"
    check_docker # 确保 Docker 已准备好
    check_pm2    # 确保 PM2 已安装

    echo "请输入您希望参与轮换的节点 IDs，每行一个，输入空行并按回车键结束输入："
    echo "示例:"
    echo "    rot-node-a"
    echo "    rot-node-b"
    echo "    ..."
    echo "输入完成后，按回车键，然后按 Ctrl+D 结束输入。"
    
    local node_ids=()
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            node_ids+=("$line")
        fi
    done
    
    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何节点 IDs。返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    local total_nodes=${#node_ids[@]}
    echo "共输入 ${total_nodes} 个节点 ID 进行轮换配置。"

    # 设定每批启动的节点数量
    read -rp "请输入每批要启动的节点数量（留空则按总节点数的 1/3 自动计算，建议 1-3 之间以控制压力）: " nodes_per_round
    if [[ -z "$nodes_per_round" ]]; then
        nodes_per_round=$(( (total_nodes + 2) / 3 )) # 至少 1 个节点
        [ "$nodes_per_round" -lt 1 ] && nodes_per_round=1
        echo "使用默认的每批启动节点数量: $nodes_per_round"
    fi

    # 输入验证
    if ! [[ "$nodes_per_round" =~ ^[1-9][0-9]*$ ]] || [ "$nodes_per_round" -gt "$total_nodes" ]; then
        echo "输入无效。请确保每批启动的节点数量是大于等于 1 的整数，并且不超过总节点数 (${total_nodes})。"
        read -p "按任意键返回..."
        return
    fi
    
    # 计算批次总数
    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    echo "节点将分 ${num_groups} 批次启动，每批次约启动 ${nodes_per_round} 个节点。"
    echo "每批启动间隔 2 小时。"
    
    # 停止并删除之前可能存在的 'nexus-rotate' PM2 进程
    echo "停止并移除可能存在的旧的 'nexus-rotate' PM2 进程..."
    pm2 delete nexus-rotate --silent || true # --silent 忽略错误，例如进程不存在

    # 构建最新镜像，轮换启动前务必保证镜像是最新的
    if ! build_image; then
        echo "错误：镜像构建失败，无法进行节点轮换启动。请检查上述错误信息。"
        read -p "按任意键继续..."
        return
    fi
    
    # --- 创建用于轮换启动的脚本 ---
    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir"
    rm -f "${script_dir}"/*.sh # 清理旧的轮换脚本，以防重复创建导致混乱

    echo "正在为节点轮换创建启动脚本..."

    # 为每批次生成一个独立的启动脚本
    for ((group=1; group<=num_groups; group++)); do
        local start_idx=$(( (group-1) * nodes_per_round ))
        local end_idx=$(( group * nodes_per_round ))
        [ "$end_idx" -gt "$total_nodes" ] && end_idx=$total_nodes # 防止越界
        
        local current_group_nodes_count=$(( end_idx - start_idx ))

        # 创建当前批次的启动脚本文件
        local group_script="${script_dir}/start_group${group}.sh"
        cat > "$group_script" <<EOF
#!/bin/bash
set -e

echo ""
echo "[$(date '+%Y-%m-%d %H:%M:%S')] ================================================"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===  开始执行第 ${group}/${num_groups} 批次节点启动指令  ==="
echo "[$(date '+%Y-%m-%d %H:%M:%S')] ================================================"

# !!! 重要步骤：在启动新一批节点前，先停止并删除所有现有的 nexus-node 容器。
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 正在停止并删除所有 Nexus Node 容器..."
docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f > /dev/null 2>&1
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 已清理完所有 Nexus Node 容器。"
echo ""

# 依次启动当前批次的节点
EOF

        # 向脚本添加启动每个节点的命令
        for ((i=$start_idx; i<$end_idx; i++)); do
            local node_id="${node_ids[$i]}"
            local container_name="${BASE_CONTAINER_NAME}-${node_id}"
            local log_file="${LOG_DIR}/nexus-${node_id}.log"
            
            # 确保日志目录和文件存在且可写
            mkdir -p "$LOG_DIR" && touch "$log_file" && chmod 644 "$log_file" && chown $(whoami):$(whoami) "$log_file"

            echo "echo \"[$(date '+%Y-%m-%d %H:%M:%S')]  ->  尝试启动节点 '$node_id' (容器: '$container_name')\"" >> "$group_script"
            echo "run_container \"$node_id\"" >> "$group_script"
            echo "if [ \$? -eq 0 ]; then" >> "$group_script"
            echo "  echo \"[$(date '+%Y-%m-%d %H:%M:%S')]      ->  节点 '$node_id' 启动命令执行成功（请通过 list_nodes 或 docker logs 确认实际状态）\"" >> "$group_script"
            echo "else" >> "$group_script"
            echo "  echo \"[$(date '+%Y-%m-%d %H:%M:%S')]      ->  !! 节点 '$node_id' 启动命令执行失败！\"" >> "$group_script"
            echo "fi" >> "$group_script"
            echo "sleep 10 # 每个节点启动间的小延迟" >> "$group_script"
        done
        
        echo "echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 第 ${group} 批节点启动指令集生成完毕。\"" >> "$group_script"
        chmod +x "$group_script" # 脚本必须有执行权限
    done

    # --- 创建主管理脚本，用于按批次轮换启动 ---
    local manager_script="${script_dir}/rotate_manager.sh"
    cat > "$manager_script" <<EOF
#!/bin/bash
set -e

echo "Nexus 节点轮换管理脚本启动..."
echo "总节点数: ${total_nodes}, 每批启动数: ${nodes_per_round}, 共 ${num_groups} 批。"

INTERVAL_HOURS=2
SLEEP_SECONDS=\$((INTERVAL_HOURS * 60 * 60)) # 2小时转换为秒

for ((group=1; group<=${num_groups}; group++)); do
    echo ""
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] >>>>>>  正在执行第 \${group}/${num_groups} 批次的节点启动  <<<<<<"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
    
    # 执行当前批次的启动脚本
    /root/nexus_scripts/start_group\${group}.sh
    
    # 如果不是最后一批，则等待指定间隔
    if [ "\$group" -lt "${num_groups}" ]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 完成第 \${group} 批次启动指令执行。等待 \${INTERVAL_HOURS} 小时进入下一批次..."
        sleep "\${SLEEP_SECONDS}"
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 所有批次的节点启动指令执行完毕。"
    fi
done

echo ""
echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===== Nexus 节点轮换启动周期完成！====="
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 如需再次轮换，请重新启动本 PM2 进程或再次运行本脚本。"

exit 0
EOF
    chmod +x "$manager_script"

    # 使用 PM2 启动管理脚本
    echo "使用 PM2 启动轮换管理进程..."
    # pm2 start <script> --name <name> --interpreter <interpreter>
    # --output /dev/null --error /dev/null 是为了不让 PM2 管理日志文件本身（轮换脚本自己有输出）
    pm2 start "${manager_script}" --name "nexus-rotate" --interpreter bash --output /dev/null --error /dev/null
    
    pm2 save # 保存 PM2 配置，这样 PM2 服务启动时会加载这个进程
    pm2 list # 显示 PM2 管理的进程列表

    echo "-------------------------------------------------------------"
    echo "Nexus 节点轮换启动配置完成！"
    echo "轮换流程已通过 PM2 启动。请使用以下命令进行监控和管理:"
    echo "  pm2 list             # 查看 PM2 管理的进程状态"
    echo "  pm2 logs nexus-rotate # 查看轮换管理脚本的日志"
    echo "  pm2 stop nexus-rotate # 停止轮换进程"
    echo "  pm2 restart nexus-rotate # 重启轮换进程"
    echo "  pm2 delete nexus-rotate # 删除轮换进程配置"
    echo "-------------------------------------------------------------"
    read -p "按任意键返回主菜单..."
}

# 设置定时任务以自动清理过期的 Nexus 日志文件
function setup_log_cleanup_cron() {
    # 每天凌晨 3 点执行一次清理任务
    # 查找 /root/nexus_logs/ 目录下的 nexus-*.log 文件，删除超过 2 天未修改的 (mtime +2)
    local cron_job="0 3 */2 * * find $LOG_DIR -type f -name 'nexus-*.log' -mtime +2 -delete"
    local CRON_FILE="/tmp/nexus_cron_jobs.$$" # 临时存储 cron 配置
    
    # 获取当前用户的 crontab 内容
    if ! crontab -l &> "$CRON_FILE"; then
        echo "当前用户的 crontab 文件不存在或无法读取。将创建新的 crontab 配置。"
        echo "" > "$CRON_FILE" # 创建一个空的临时文件
    fi

    # 检查任务是否已存在
    if grep -Fq "$cron_job" "$CRON_FILE"; then
        echo "定时日志清理任务已存在，无需重复添加。"
    else
        # 添加新任务到临时文件
        echo "$cron_job" >> "$CRON_FILE"
        # 将临时文件内容导入 crontab
        if crontab "$CRON_FILE"; then
            echo "成功添加定时日志清理任务。"
            echo "任务内容: \"$cron_job\""
        else
            echo "警告: 添加定时日志清理任务失败。请手动检查您的 crontab 配置 (crontab -e)。"
        fi
    fi
    
    # 清理临时文件
    rm -f "$CRON_FILE"
}

# --- 主菜单与逻辑 ---
function main_menu() {
    setup_log_cleanup_cron # 在脚本开始运行时，先确保日志清理任务已设置

    while true; do
        clear
        echo ""
        echo "========================= Nexus 多节点管理脚本 =========================="
        echo "   脚本作者: 哈哈哈哈 (推特 @ferdie_jhovie)"
        echo "   支持节点数量不限 (取决于您服务器的硬件资源)"
        echo "=========================================================================="
        echo " 1. 部署并启动单个新 Nexus 节点"
        echo " 2. 显示当前已部署所有 Nexus 节点的状态 (包括资源使用情况)"
        echo " 3. 批量停止并卸载指定的 Nexus 节点"
        echo " 4. 查看指定 Nexus 节点的实时运行日志"
        echo " 5. 配置并启动 Nexus 节点轮换计划 (按批次启动，每批间隔 2h)"
        echo " 6. 一键删除并清理所有已部署的 Nexus 节点及相关文件"
        echo " 7. 退出脚本"
        echo "=========================================================================="
        echo "当前节点资源限制设置: 内存=${DEFAULT_MEMORY_LIMIT}, CPU=${DEFAULT_CPUS_LIMIT}"
        echo ""
        read -rp "请选择您要执行的操作 (1-7): " choice

        case "$choice" in
            1) # 部署新节点
                if ! check_docker; then # 确保 Docker 可用
                    echo "Docker 检查失败，无法进行节点部署。"
                    read -p "按任意键继续..."
                    continue
                fi
                read -rp "请输入此新节点的 Node ID: " NODE_ID
                if [ -z "$NODE_ID" ]; then
                    echo "Node ID 不能为空。请重新选择操作。"
                else
                    run_container "$NODE_ID"
                fi
                read -p "按任意键返回主菜单..."
                ;;
            2) # 显示所有节点状态
                list_nodes
                ;;
            3) # 批量卸载节点
                # 此函数之前已经定义好了，在此调用即可
                batch_uninstall_nodes
                ;;
            4) # 查看日志
                local all_node_ids=$(get_all_node_ids)
                if [ -z "$all_node_ids" ]; then
                    echo "系统中尚无已部署的节点。无法查看日志。"
                else
                    echo ""
                    echo "可用的节点列表用于选择日志查看:"
                    local node_list=($all_node_ids)
                    local node_index=1
                    for id in "${!node_list[@]}"; do
                        local node_id=${node_list[$id]}
                        printf "  %d. %s\n" $((node_index)) "$node_id"
                        node_index=$((node_index + 1))
                    done
                    echo ""
                    read -rp "请输入要查看日志的节点的 Node ID: " node_to_view_id
                    if [ -z "$node_to_view_id" ]; then
                        echo "Node ID 为空，取消操作。"
                    elif echo "${node_list[*]}" | grep -qw "$node_to_view_id"; then
                        view_node_logs "$node_to_view_id"
                    else
                        echo "未找到您输入的 Node ID: '$node_to_view_id'。请检查输入是否正确，或选择 '2' 查看节点列表确认。"
                    fi
                fi
                read -p "按任意键返回主菜单..."
                ;;
            5) # 批量轮换启动
                batch_rotate_nodes
                ;;
            6) # 删除所有节点
                echo ""
                echo "======================== 警告: 删除所有节点 ========================="
                echo "此操作将永久删除系统中所有 Nexus Node 容器及其数据和日志。"
                echo "请务必确认您已备份所有重要信息。"
                local existing_nodes_count=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | wc -l)
                if [ "$existing_nodes_count" -eq 0 ]; then
                    echo "系统中没有找到 Nexus 节点需要删除。"
                else
                    echo "系统检测到 ${existing_nodes_count} 个 Nexus 节点。"
                    read -rp "您确定要删除所有节点吗？(输入 'yes' 确认): " confirm_delete_all
                    if [[ "$confirm_delete_all" == "yes" ]]; then
                        echo "开始删除所有 Nexus 节点..."
                        local all_nodes=($(get_all_node_ids))
                        for node_id in "${all_nodes[@]}"; do
                            echo "  正在卸载节点 '$node_id'..."
                            uninstall_node "$node_id"
                        done
                        echo "所有节点已删除。"
                    else
                        echo "取消了删除所有节点的操作。"
                    fi
                fi
                read -p "按任意键返回主菜单..."
                ;;
            7) # 退出
                echo ""
                echo "感谢使用 Nexus 节点管理脚本。祝您使用愉快！"
                exit 0
                ;;
            *) # 无效选项
                echo "无效的选项，请输入 1 到 7 之间的数字。"
                read -p "按任意键继续..."
                ;;
        esac
    done
}

# --- 主脚本执行入口 ---
main_menu
