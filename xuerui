#!/bin/bash
set -e

# === 全局配置 ===
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs" # 日志文件挂载到宿主机的目录

# === 辅助函数 ===

# 检查并安装 Node.js 和 pm2
function check_node_pm2() {
    echo "🔍 检查 Node.js 和 pm2 安装情况..."
    # 检查是否安装了 Node.js
    if ! command -v node >/dev/null 2>&1; then
        echo "✅ Node.js 未安装，正在安装..."
        curl -fsSL https://deb.nodesource.com/setup_20.x | bash - || { echo "🔴 错误：Node.js 安装脚本失败。"; exit 1; }
        apt-get update && apt-get install -y nodejs || { echo "🔴 错误：Node.js 包安装失败。"; exit 1; }
        echo "✅ Node.js 安装成功。"
    fi

    # 检查是否安装了 pm2
    if ! command -v pm2 >/dev/null 2>&1; then
        echo "✅ pm2 未安装，正在安装..."
        npm install -g pm2 || { echo "🔴 错误：pm2 安装失败。"; exit 1; }
        # 配置 npm prefix，确保 pm2 可执行文件在 PATH 中
        PM2_PATH=$(npm config get prefix)/bin
        if [[ ":$PATH:" != *":$PM2_PATH:"* ]]; then
            echo "🔧 将 npm bin 路径添加到 PATH 环境变量..."
            echo "export PATH=\"$PM2_PATH:\$PATH\"" >> ~/.profile # 确保重启后也有效
            source ~/.profile
            # For current session if it was root
            export PATH="$PM2_PATH:$PATH"
        fi
        echo "✅ pm2 安装成功。"
    fi
}

# 检查 Docker 是否安装
function check_docker() {
    echo "🔍 检查 Docker 安装情况..."
    if ! command -v docker >/dev/null 2>&1; then
        echo "✅ Docker 未安装，正在安装..."
        apt update || { echo "🔴 错误：apt update 失败。"; exit 1; }
        # 修正 gpg 命令以适配更新的 apt
        apt install -y ca-certificates curl gnupg lsb-release || { echo "🔴 错误：Docker 依赖安装失败。"; exit 1; }
        mkdir -m 0755 -p /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg || { echo "🔴 错误：Docker GPG 密钥下载失败。"; exit 1; }
        echo \
            "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
            $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null || { echo "🔴 错误：Docker APT 源添加失败。"; exit 1; }
        apt update || { echo "🔴 错误：apt update 失败。"; exit 1; }
        apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y || { echo "🔴 错误：Docker CE 安装失败。"; exit 1; }
        systemctl enable docker || { echo "🔴 错误：启用 Docker 失败。"; exit 1; }
        systemctl start docker || { echo "🔴 错误：启动 Docker 失败。"; exit 1; }
        # 增加当前用户到 docker 组，避免每次都用 sudo
        if ! getent group docker | grep -q "\b$(whoami)\b"; then
            echo "🔧 将当前用户添加到 docker 用户组..."
            usermod -aG docker "$(whoami)" || { echo "⚠️ 无法将用户添加到 docker 组。可能需要重新登录或使用 sudo。"; }
            echo "✅ 用户已添加到 docker 组。请退出当前 SSH 会话并重新登录以使更改生效。"
            sleep 3 # 等待用户阅读消息
        fi
        echo "✅ Docker 安装并启动成功。"
    fi
}

# 设置 pm2 启动脚本以便重启后恢复
function setup_pm2_startup() {
    echo "✅ 设置 PM2 启动脚本以确保服务持久化..."
    if command -v pm2 >/dev/null 2>&1; then
        # 尝试使用 systemd，如果失败则回退到其他类型
        pm2 startup systemd || pm2 startup || echo "⚠️ PM2 startup 命令可能失败，请手动设置：pm2 startup"
        pm2 save || echo "⚠️ PM2 save 命令失败，请手动执行：pm2 save"
        echo "✅ PM2 服务持久化设置完成。"
    else
        echo "🔴 错误：pm2 未安装，无法设置服务持久化。请尝试执行选项6先进行安装。"
    fi
}

# 构建 Docker 镜像函数
function build_image() {
    echo "⚙️ 正在构建 Docker 镜像: $IMAGE_NAME ..."
    WORKDIR=$(mktemp -d)
    # 确保在脚本退出时清理临时目录
    trap "cd - >/dev/null 2>&1; rm -rf \"$WORKDIR\"" EXIT HUP INT TERM

    cd "$WORKDIR"

    # Dockerfile
    cat > Dockerfile <<EOF
FROM ubuntu:24.04

ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id
# 容器内部日志路径，用于 tee
ENV NEXUS_LOG_FILE=/root/nexus.log 

# 更新包列表并安装所需工具
RUN apt-get update && apt-get install -y \
    curl \
    bash \
    procps \
    locales \
    gawk \
    && rm -rf /var/lib/apt/lists/*

# 设置 locales 以避免某些命令出现警告
RUN locale-gen en_US.UTF-8
ENV LANG en_US.UTF-8
ENV LANGUAGE en_US:en
ENV LC_ALL en_US.UTF-8

# 自动下载安装最新版 nexus-network
# 使用 NONINTERACTIVE=1 避免交互式安装
RUN curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh \
    && ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network \
    && rm -rf ~/.npm ~/.config

# Docker HEALTHCHECK 用于检查容器内服务是否运行
# 检查 nexus-network 进程是否存在，如果不存在则容器不健康
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 CMD pgrep -f nexus-network >/dev/null || exit 1

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
EOF

    # entrypoint.sh (已修复，更健壮且符合Docker最佳实践)
    cat > entrypoint.sh <<EOF
#!/bin/bash
set -e

PROVER_ID_FILE="/root/.nexus/node-id"
NEXUS_LOG_FILE="/root/nexus.log" # 容器内部日志路径，与宿主机挂载点一致

# 确保日志目录存在 (对于 Dockerfile COPY 后可能不完全适用，但仍是好习惯)
mkdir -p "\$(dirname "\$NEXUS_LOG_FILE")" || true

# 检查 NODE_ID 环境变量
if [ -z "\$NODE_ID" ]; then
    echo "错误：未设置 NODE_ID 环境变量"
    exit 1
fi

# 将 NODE_ID 写入指定文件
echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo "✅ 正在使用 node-id: \$NODE_ID"

# 检查 nexus-network 命令是否可用
if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 未安装或不可用。请检查 Dockerfile。"
    exit 1
fi

# 使用 trap 捕获 SIGTERM (Docker stop 信号) 以实现优雅关闭
# 由于 nexus-network 现在是主要进程，Docker 的 SIGTERM 会直接发送给它
# 如果 nexus-network 自身不支持 SIGTERM 优雅关闭，则需要在它停止前发送特殊信号或进行特定操作
# 对于通常的进程，系统会自动处理 SIGTERM。这里可以移除具体的 graceful_shutdown 函数
# 如果 nexus-network 需要特别的处理，需要查看其文档
function graceful_shutdown() {
    echo "🛑 收到停止信号 (SIGTERM)。尝试等待 nexus-network 优雅退出..."
    # 可以发送 SIGINT (Ctrl+C) 或 SIGTERM 给 PID 1 进程
    # 这里如果 nexus-network 是 PID 1，Docker 会直接处理它。
    # 如果您需要额外步骤（例如清理），可以添加在此处。
    # 示例: 可以简单地等待，让 Docker 自己处理 PID 1 收到 SIGTERM 后的默认行为
    wait \$(pgrep -f nexus-network) 2>/dev/null || true # 等待进程结束，不报错
    echo "✅ nexus-network 进程已退出。"
    exit 0
}

# Trap SIGTERM 仅作为后备，Docker 会直接发送 SIGTERM 到 exec 启动的进程
# 这在 exec 后就没有太多作用了，因为 trap 是针对当前 shell 的。
# 通常，让容器的 PID 1 进程直接接收 Docker 的信号即可。
# 如果 nexus-network 优雅关闭不工作，可能是它自身不处理信号。
# 更好的做法是确保 nexus-network 能够处理 TERM 信号。
# 这里将 trap 设置为 exec *之前*，这样它会处理退出，
# 但是 exec 后，这个 trap 仅存在于替换的进程中。
trap 'graceful_shutdown' SIGTERM

echo "🚀 启动 nexus-network 节点..."
# 将 nexus-network 的标准输出和标准错误重定向到 NEXUS_LOG_FILE，
# 同时通过 tee 命令将它们也发送到容器的标准输出（PID 1 的输出），
# 这样 Docker logs 命令可以实时显示日志。
# 如果 nexus-network 进程退出，由于 exec 命令，整个容器也会退出，
# 这才是 Docker 容器应该有的行为。
# tee -a 表示追加到日志文件，如果文件不存在则创建。
exec nexus-network start --node-id "\$NODE_ID" 2>&1 | tee -a "\$NEXUS_LOG_FILE"
EOF

    docker build -t "$IMAGE_NAME" . || { echo "🔴 错误：Docker 镜像构建失败。"; exit 1; }
    echo "✅ Docker 镜像构建完成: $IMAGE_NAME"

    # The trap will handle cleaning up workdir and cd back to previous directory
}

# 启动容器（挂载宿主机日志文件，并添加资源限制）
# 增加 --restart unless-stopped 策略
function run_container() {
    local node_id=$1
    local memory_limit=$2 # 例如: 2g
    local cpu_limit=$3    # 例如: 0.5 或 1.0
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log" # 宿主机上的日志文件路径

    echo "⚙️ 准备启动容器 $container_name (内存: ${memory_limit}, CPU: ${cpu_limit})..."

    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "🔍 检测到旧容器 $container_name，正在尝试停止并删除..."
        docker stop -t 30 "$container_name" >/dev/null 2>&1 || true # 尝试优雅停止
        docker rm -f "$container_name" >/dev/null 2>&1 || echo "⚠️ 无法删除旧容器 $container_name，可能已经停止或不存在。"
    fi

    # 确保宿主机日志目录存在
    mkdir -p "$LOG_DIR" || { echo "🔴 错误：无法创建日志目录 $LOG_DIR。"; exit 1; }
    
    # 确保宿主机日志文件存在并有写权限，且不是一个目录
    if [ -d "$log_file" ]; then
        echo "⚠️ 检测到日志路径 $log_file 为目录，正在删除并重新创建文件..."
        rm -rf "$log_file" || { echo "🔴 错误：无法删除目录 $log_file。"; exit 1; }
    fi
    # 重新检查日志文件是否为常规文件或已创建
    if [ ! -f "$log_file" ]; then
        touch "$log_file" || { echo "🔴 错误：无法创建日志文件 $log_file。"; exit 1; }
        chmod 644 "$log_file" || { echo "🔴 错误：无法设置日志文件权限 $log_file。"; exit 1; }
    fi


    echo "🚀 启动容器 $container_name ..."
    # 将宿主机日志文件挂载到容器内部的 /root/nexus.log，与 entrypoint.sh 保持一致
    docker run -d --name "$container_name" \
        --restart unless-stopped \
        --memory "${memory_limit}" \
        --cpus "${cpu_limit}" \
        -v "$log_file":/root/nexus.log \
        -e NODE_ID="$node_id" \
        "$IMAGE_NAME" || { echo "🔴 错误：容器 $container_name 启动失败。"; exit 1; }
    echo "✅ 容器 $container_name 已成功启动！"
    echo "💡 可以使用 'docker logs -f $container_name' 查看实时日志。"
}

# 停止并卸载容器和镜像、删除日志
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "⚙️ 正在停止并删除容器 $container_name..."
    # 使用 docker stop 尝试优雅关闭，如果超时则强制删除
    docker stop -t 30 "$container_name" >/dev/null 2>&1 || true
    docker rm -f "$container_name" >/dev/null 2>&1 || echo "⚠️ 容器 $container_name 不存在或已停止，跳过删除。"

    if [ -f "$log_file" ]; then
        echo "🗑️ 正在删除日志文件 $log_file ..."
        rm -f "$log_file" || echo "⚠️ 无法删除日志文件 $log_file。"
    elif [ -d "$log_file" ]; then # 检查是否是目录
        echo "🗑️ 发现 $log_file 是一个目录，正在删除它..."
        rm -rf "$log_file" || echo "⚠️ 无法删除目录 $log_file。"
    else
        echo "ℹ️ 日志文件不存在：$log_file"
    fi

    echo "✅ 节点 $node_id 已卸载完成。"
}

# 修复后的显示所有运行中的节点
function list_nodes() {
    echo "📜 当前节点状态："
    echo "------------------------------------------------------------------------------------------------------------------------"
    printf "%-4s %-20s %-12s %-15s %-15s %-15s %-20s\n" "序号" "节点ID" "CPU" "内存使用" "内存限制" "状态" "启动时间"
    echo "------------------------------------------------------------------------------------------------------------------------"
    
    # 统一获取所有符合命名规则的容器ID、名称、状态、创建时间
    local all_container_data=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format '{{.ID}}|{{.Names}}|{{.Status}}|{{.CreatedAt}}' 2>/dev/null)

    if [ -z "$all_container_data" ]; then
        echo "                      没有发现任何 Nexus 节点容器。                  "
        echo "------------------------------------------------------------------------------------------------------------------------"
        read -rp "按任意键返回菜单"
        return
    fi

    local count=0
    # 使用 Here String 解析多行数据
    while IFS= read -r line; do
        local container_id=$(echo "$line" | cut -d'|' -f1)
        local container_name=$(echo "$line" | cut -d'|' -f2)
        local status=$(echo "$line" | cut -d'|' -f3)
        local created_time_raw=$(echo "$line" | cut -d'|' -f4)

        # 提取 node_id
        local node_id=$(echo "$container_name" | sed "s/^${BASE_CONTAINER_NAME}-//")

        local cpu_usage="N/A"
        local current_mem="N/A"
        local limit_mem="N/A"

        # 首先尝试获取容器的内存限制，即使是停止的容器也可以获取
        local inspect_mem_limit_bytes=$(docker inspect -f '{{.HostConfig.Memory}}' "$container_id" 2>/dev/null)
        if [ -n "$inspect_mem_limit_bytes" ] && [ "$inspect_mem_limit_bytes" -gt 0 ]; then
            # 转换为可读性更好的内存单位
            if (( inspect_mem_limit_bytes >= 1099511627776 )); then # TB
                limit_mem=$(awk "BEGIN {printf \"%.1fT\", $inspect_mem_limit_bytes/1099511627776}")
            elif (( inspect_mem_limit_bytes >= 1073741824 )); then # GB
                limit_mem=$(awk "BEGIN {printf \"%.1fG\", $inspect_mem_limit_bytes/1073741824}")
            elif (( inspect_mem_limit_bytes >= 1048576 )); then # MB
                limit_mem=$(awk "BEGIN {printf \"%.1fM\", $inspect_mem_limit_bytes/1048576}")
            elif (( inspect_mem_limit_bytes >= 1024 )); then # KB
                limit_mem=$(awk "BEGIN {printf \"%.1fK\", $inspect_mem_limit_bytes/1024}")
            else
                limit_mem="${inspect_mem_limit_bytes}B"
            fi
        else
             limit_mem="不限"
        fi

        # 仅当容器状态为 'Up' (运行中) 时，才尝试获取实时 CPU 和内存使用率
        if [[ "$status" == Up* ]]; then
            # 注意: docker stats 在 --no-stream 模式下可以立即返回当前快照
            # 正确重定向错误输出到 /dev/null
            local container_stats=$(docker stats --no-stream --format "{{.CPUPerc}}|{{.MemUsage}}" "$container_id" 2>/dev/null)
            
            if [ -n "$container_stats" ]; then
                cpu_usage=$(echo "$container_stats" | cut -d'|' -f1)
                # MemUsage 格式是 "current_usage / limit_usage"，这里只需要 current_usage
                current_mem=$(echo "$container_stats" | cut -d'|' -f2 | cut -d'/' -f1 | xargs)
            fi
        fi

        # 格式化创建时间
        local formatted_created_time=$(date -d "$created_time_raw" +'%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "N/A")

        count=$((count+1))
        printf "%-4d %-20s %-12s %-15s %-15s %-15s %-20s\n" \
            "$count" \
            "$node_id" \
            "$cpu_usage" \
            "$current_mem" \
            "${limit_mem}" \
            "$(echo "$status" | cut -d' ' -f1)" \
            "$formatted_created_time"
    done <<< "$all_container_data"

    echo "------------------------------------------------------------------------------------------------------------------------"
    echo "提示："
    echo "- CPU: 显示容器CPU使用百分比 (仅对运行中容器)"
    echo "- 内存使用: 显示容器当前使用的内存 (仅对运行中容器)"
    echo "- 内存限制: 显示容器创建时设置的内存限制 (即使容器已停止, \"不限\" 表示未设置限制)"
    echo "- 状态: 显示容器的运行状态 (Up/Exited)"
    echo "- 启动时间: 显示容器的创建时间"
    read -rp "按任意键返回菜单"
}

# 获取所有节点ID（包括已停止的）
function get_all_nodes() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 查看节点日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "🔴 错误：容器 $container_name 不存在或已停止。请确认 Node ID 或尝试安装/启动。"
        read -rp "按任意键返回菜单"
        return
    fi

    echo "请选择日志查看模式："
    echo "1. 原始日志（可能包含颜色代码）"
    echo "2. 清理后的日志（移除颜色代码）"
    read -rp "请选择(1-2): " log_mode

    echo "ℹ️ 正在查看日志，按 Ctrl+C 退出日志查看..."
    if [ "$log_mode" = "2" ]; then
        # 移除ANSI转义序列和光标控制序列
        docker logs -f "$container_name" 2>&1 | sed 's/\x1b\[[0-9;]*m//g' | sed 's/\x1b\[?25[hl]//g'
    else
        docker logs -f "$container_name"
    fi
}

# 批量停止并卸载节点
function batch_uninstall_nodes() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "⚠️ 当前没有 Nexus 节点容器。"
        read -rp "按任意键返回菜单"
        return
    fi

    echo "📜 当前节点列表："
    echo "----------------------------------------"
    printf "%-4s %-20s %s\n" "序号" "节点ID" "状态"
    echo "----------------------------------------"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}" 2>/dev/null)
        if [[ $status == Up* ]]; then
            printf "%-4d %-20s [运行中]\n" $((i+1)) "$node_id"
        else
            printf "%-4d %-20s [已停止]\n" $((i+1)) "$node_id"
        fi
    done
    echo "----------------------------------------"

    echo "🗑️ 请选择要删除的节点（可多选，输入数字，用空格分隔）："
    echo "0. 返回主菜单"
    
    read -rp "请输入选项(0 或 数字，用空格分隔): " choices

    if [ "$choices" = "0" ]; then
        echo "❌ 操作已取消。"
        return
    fi

    # 将输入的选项转换为数组
    read -ra selected_choices <<< "$choices"
    
    # 验证输入并执行卸载
    for choice in "${selected_choices[@]}"; do
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
            local selected_node=${all_nodes[$((choice-1))]}
            echo "➡️ 正在卸载节点 $selected_node ..."
            uninstall_node "$selected_node"
        else
            echo "⚠️ 跳过无效选项: $choice"
        fi
    done

    echo "✅ 批量卸载完成！"
    read -rp "按任意键返回菜单"
}

# 选择要查看的节点
function select_node_to_view() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "⚠️ 当前没有 Nexus 节点容器。"
        read -rp "按任意键返回菜单"
        return
    fi

    echo "请选择要查看日志的节点："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}" 2>/dev/null)
        if [[ $status == Up* ]]; then
            echo "$((i+1)). 节点 $node_id [运行中]"
        else
            echo "$((i+1)). 节点 $node_id [已停止]"
        fi
    done

    read -rp "请输入选项(0-${#all_nodes[@]}): " choice

    if [ "$choice" = "0" ]; then
        return
    fi

    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
        local selected_node=${all_nodes[$((choice-1))]}
        view_node_logs "$selected_node"
    else
        echo "🔴 无效的选项。"
        read -rp "按任意键继续"
    fi
}


# 删除全部节点
function uninstall_all_nodes() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "⚠️ 当前没有 Nexus 节点容器。"
        read -rp "按任意键返回菜单"
        return
    fi

    echo "‼️ 警告：此操作将删除所有 Nexus 节点容器及其相关日志！"
    echo "当前共有 ${#all_nodes[@]} 个节点待删除："
    for node_id in "${all_nodes[@]}"; do
        echo "- $node_id"
    done
    
    read -rp "确定要删除所有节点吗？此操作不可逆！(y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "❌ 操作已取消。"
        read -rp "按任意键返回菜单"
        return
    fi

    echo "🗑️ 开始删除所有节点..."
    for node_id in "${all_nodes[@]}"; do
        echo "➡️ 正在卸载节点 $node_id ..."
        uninstall_node "$node_id"
    done

    echo "✅ 所有节点已删除完成！"
    read -rp "按任意键返回菜单"
}

# 设置默认的自动清理任务（PM2 管理）
function setup_default_auto_cleanup() {
    local days=7 # 默认保留7天的日志
    
    read -rp "请输入日志保留天数（默认 ${days} 天，输入 0 不保留）：" user_days
    if [[ -n "$user_days" && "$user_days" =~ ^[0-9]+$ && "$user_days" -ge 0 ]]; then
        days="$user_days"
    elif [[ -n "$user_days" ]]; then
        echo "⚠️ 无效输入，使用默认 $days 天。"
    fi

    echo "⚙️ 正在设置自动日志清理（保留最近 $days 天的日志）..."
    
    # 确保 pm2 已安装
    check_node_pm2
    
    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir" 2>/dev/null || true # 允许目录已存在

    local cleanup_script_path="$script_dir/cleanup_logs.sh"
    cat > "$cleanup_script_path" <<EOF
#!/bin/bash
set -e

LOG_DIR="$LOG_DIR"
DAYS_TO_KEEP=$days

if [ -d "\$LOG_DIR" ]; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 运行 Nexus 日志清理程序 (保留 \$DAYS_TO_KEEP 天日志)..."
    # 查找并删除超过指定天数的日志文件
    # -print-delete 是 GNU find 的扩展，它会在找到后立即删除，并打印被删除文件的路径
    find "\$LOG_DIR" -name "nexus-*.log" -type f -mtime +\$DAYS_TO_KEEP -print -delete || true # 允许找不到文件不报错
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Nexus 日志清理完成。"
else
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 日志目录 \$LOG_DIR 不存在，跳过清理。"
fi
EOF
    chmod +x "$cleanup_script_path"
    
    # 停止旧的清理任务
    pm2 delete nexus-cleanup 2>/dev/null || true
    
    # 使用 pm2 启动定时清理任务
    # 使用 -- start -- 的语法确保在执行脚本前停止旧进程
    pm2 start --name "nexus-cleanup" --no-autorestart --cron-restart "0 0 * * *" "$cleanup_script_path"
    pm2 save
    
    echo "✅ 自动日志清理任务已成功设置！将每天清理超过 $days 天的日志。"
    echo "   使用 'pm2 status' 查看清理任务状态。"
    echo "   使用 'pm2 logs nexus-cleanup' 查看清理日志。"
}


# 批量节点轮换启动 (通过 PM2 调度，确保稳定性)
function batch_rotate_nodes() {
    echo "🔄 启动批量节点轮换模式"
    echo "ℹ️ 请输入所有要参与轮换的 node-id，每行一个，输入空行后按 Ctrl+D 结束输入："
    
    local node_ids=()
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            node_ids+=("$line")
        fi
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "⚠️ 未输入任何 node-id，返回主菜单。"
        read -rp "按任意键继续"
        return
    fi

    # 获取内存和CPU限制
    local mem_per_node=""
    while true; do
        read -rp "请输入每个节点容器允许的最大内存 (例如: 2g, 4g, 支持m/g后缀): " mem_per_node
        if [[ "$mem_per_node" =~ ^[0-9]+[mgMG]$ ]]; then
            break
        else
            echo "🔴 无效的内存格式。请输入例如 '2g' 或 '512m'。"
        fi
    done

    local cpu_per_node=""
    while true; do
        read -rp "请输入每个节点容器允许的最大CPU核心数 (例如: 0.5, 1, 2): " cpu_per_node
        if [[ "$cpu_per_node" =~ ^[0-9]+(\.[0-9]+)?$ ]] && (( $(echo "$cpu_per_node > 0" | bc -l) )); then
            break
        else
            echo "🔴 无效的CPU格式。请输入大于0的数字，例如 '0.5' 或 '1'。"
        fi
    done

    local default_nodes_per_round=$(( (${#node_ids[@]} < 5) ? ${#node_ids[@]} : 5 )) # 默认每轮启动最多5个，如果总数小于5，则启动总数
    read -rp "请输入每批次要同时运行的节点数量（默认：${default_nodes_per_round}）: " nodes_per_round_input
    if [ -z "$nodes_per_round_input" ]; then
        nodes_per_round="$default_nodes_per_round"
    elif [[ "$nodes_per_round_input" =~ ^[0-9]+$ ]] && [ "$nodes_per_round_input" -ge 1 ]; then
        nodes_per_round="$nodes_per_round_input"
    else
        echo "🔴 无效的节点数量，请输入正整数，将使用默认值。"
        nodes_per_round="$default_nodes_per_round"
    fi

    # 验证输入
    if [ "$nodes_per_round" -gt ${#node_ids[@]} ]; then
        echo "⚠️ 警告：设定的每批次启动数量 ($nodes_per_round) 超过了总节点数 (${#node_ids[@]})。所有节点将同时运行。"
        nodes_per_round=${#node_ids[@]}
    fi

    local total_nodes=${#node_ids[@]}
    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    
    echo "✅ 节点总数: $total_nodes 个，将分为 $num_groups 组进行轮换。"
    echo "   每批次将运行 $nodes_per_round 个节点（最后一组可能不足）。"

    read -rp "请输入每批次轮换周期（小时，建议 2-24 小时，例如 2): " rotation_interval_hours
    if ! [[ "$rotation_interval_hours" =~ ^[0-9]+$ ]] || [ "$rotation_interval_hours" -lt 1 ]; then
        echo "🔴 无效的轮换周期，请输入正整数。"
        read -rp "按任意键返回菜单"
        return
    fi
    local rotation_interval_seconds=$(( rotation_interval_hours * 3600 ))

    # 检查并安装 Node.js 和 pm2
    check_node_pm2
    # 确保 pm2 持久化设置
    setup_pm2_startup

    echo "⚙️ 开始构建 Docker 镜像 (如果尚未构建)..."
    build_image

    # 创建启动脚本目录
    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir" 2>/dev/null || true

    # 清理旧的组启动脚本
    echo "清理旧的批次启动脚本..."
    rm -f "$script_dir/start_batch_group_*.sh"

    # 将节点分组并创建各自的启动脚本
    for ((i=0; i<num_groups; i++)); do
        local group_num=$((i+1))
        local start_script="$script_dir/start_batch_group_${group_num}.sh"
        
        cat > "$start_script" <<EOF
#!/bin/bash
set -e
# 该脚本由 nexus_manager.sh 生成，用于启动特定批次的 Nexus 容器。
# 请勿手动修改。

MEMORY_LIMIT="$mem_per_node"
CPU_LIMIT="$cpu_per_node"
BASE_CONTAINER_NAME="$BASE_CONTAINER_NAME"
IMAGE_NAME="$IMAGE_NAME"
LOG_DIR="$LOG_DIR"

echo "[$(date '+%Y-%m-%d %H:%M:%S')] 🚀 正在处理第${group_num}组节点..."

# --- 在本组内循环，为每个节点执行启动/更新逻辑 ---
EOF
        chmod +x "$start_script"
    done

    # 填充各个组的脚本
    for i in "${!node_ids[@]}"; do
        local node_id=${node_ids[$i]}
        local group_idx=$(( i / nodes_per_round )) # 0-indexed group
        local group_num=$((group_idx + 1))       # 1-indexed group for script name
        local start_script="$script_dir/start_batch_group_${group_num}.sh"

        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local node_log_file="${LOG_DIR}/nexus-${node_id}.log"

        # 添加每个节点的启动逻辑到对应的组脚本
        cat >> "$start_script" <<EOF

echo "[$(date '+%Y-%m-%d %H:%M:%S')]   ➡️ 检查/启动节点 $node_id (内存: \$MEMORY_LIMIT, CPU: \$CPU_LIMIT)"
# 确保宿主机日志目录和文件存在
mkdir -p "\$LOG_DIR" 2>/dev/null || true
if [ -d "$node_log_file" ]; then
    echo "⚠️ 日志路径 $node_log_file 是目录，尝试删除并重新创建。"
    rm -rf "$node_log_file" || echo "🔴 错误：无法删除目录 $node_log_file。"
fi
# 重新检查日志文件是否为常规文件或已创建
if [ ! -f "$node_log_file" ]; then
    touch "$node_log_file" || echo "🔴 错误：无法创建日志文件 $node_log_file。"
    chmod 644 "$node_log_file" || echo "🔴 错误：无法设置日志文件权限 $node_log_file。"
fi

# 如果容器已存在，停止并删除，以便重新创建新的（包含资源限制或更新）
# 使用 filter 更精确匹配，确保是 exact name 而不是 prefix match
if docker ps -a --format '{{.Names}}' | grep -Eq "^${container_name}$"; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')]   🔍 发现旧容器 ${container_name}，停止并删除..."
    docker stop -t 30 "${container_name}" >/dev/null 2>&1 || true
    docker rm -f "${container_name}" >/dev/null 2>&1 || true
fi

# 启动带有资源限制的新容器
docker run -d --name "${container_name}" \
    --restart unless-stopped \
    --memory "\$MEMORY_LIMIT" \
    --cpus "\$CPU_LIMIT" \
    -v "$node_log_file":/root/nexus.log \
    -e NODE_ID="$node_id" \
    "\$IMAGE_NAME" || { echo "🔴 错误：节点 $node_id 容器启动失败！"; }

sleep 5 # 启动之间稍作等待，防止 Docker 命令堆积
EOF
    done

    # 创建轮换主调度脚本
    local rotate_scheduler_path="$script_dir/rotate_scheduler.sh"
    cat > "$rotate_scheduler_path" <<EOF
#!/bin/bash
set -e

GROUPS_COUNT=$num_groups
CURRENT_GROUP=0 # 从第0组开始，加1后是1-indexed
ROTATION_INTERVAL_SECONDS=$rotation_interval_seconds # 轮换周期

# 所有参与轮换的节点ID列表，用于确保每次只激活当前组的节点
# 使用 readarray 确保 ALL_NODE_IDS 是一个实际的 bash 数组
# 通过 heredoc 和 printf 构建，避免任何 IFS 问题
readarray -t ALL_NODE_IDS <<<"$(printf "%s\\n" "${node_ids[@]}")"

BASE_CONTAINER_NAME="$BASE_CONTAINER_NAME"
SCRIPT_DIR="$script_dir"
NODES_PER_ROUND=$nodes_per_round

# 在每次轮换开始前，停止并清理所有非当前组的节点
function stop_inactive_groups() {
    local active_group_num=\$1
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 🧹 清理非当前组节点..."

    # 获取所有 BASE_CONTAINER_NAME- 前缀的容器（不论状态）
    local all_known_containers_raw=\$(docker ps -a --filter "name=\${BASE_CONTAINER_NAME}-" --format '{{.Names}}' 2>/dev/null)
    # readarray 用于将多行字符串转换为数组，确保每个容器名作为一个元素
    readarray -t ALL_KNOWN_CONTAINERS_ARRAY <<< "\$all_known_containers_raw"

    for container_name in "\${ALL_KNOWN_CONTAINERS_ARRAY[@]}"; do
        local current_node_id="\$(echo "\$container_name" | sed "s/^\\${BASE_CONTAINER_NAME}-//")"
        
        # 查找 current_node_id 在 ALL_NODE_IDS 数组中的索引
        local node_index=-1
        for idx in "\${!ALL_NODE_IDS[@]}"; do
            if [ "\${ALL_NODE_IDS[\$idx]}" == "\$current_node_id" ]; then
                node_index=\$idx
                break
            fi
        done

        if [ "\$node_index" -ne -1 ]; then # 确保这个node_id确实在我们管理的列表里
            local node_group_num=\$(( (node_index / \$NODES_PER_ROUND) + 1 )) # 计算当前节点所属组 (1-indexed)

            if [ "\$node_group_num" -ne "\$active_group_num" ]; then
                # 如果容器存在且状态不是Exited (已停止), 停止并删除
                # 获取容器ID以便更精确操作
                local target_container_id=\$(docker ps -a -q -f "name=\$container_name" 2>/dev/null)
                if [ -n "\$target_container_id" ]; then
                    local status=\$(docker inspect -f '{{.State.Status}}' "\$target_container_id" 2>/dev/null || echo "N/A")
                    if [ "\$status" != "exited" ]; then
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')]   - 停止/删除旧组的节点: \${container_name} (组: \$node_group_num, 状态: \$status)"
                        docker stop -t 10 "\$target_container_id" >/dev/null 2>&1 || true
                        docker rm -f "\$target_container_id" >/dev/null 2>&1 || true
                    else
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')]   - 节点 \${container_name} 已停止且已退出，无需操作。(组: \$node_group_num, 状态: \$status)"
                    fi
                fi
            fi
        else
            # 处理命名匹配但不在白名单内的容器，可能是旧的或手动创建的，不建议删除
            echo "[$(date '+%Y-%m-%d %H:%M:%S')]   - 发现非轮换批次管理的容器: \$container_name (不执行停止操作)"
        fi
    done
}


while true; do
    # 计算下一组索引 (循环轮转 1 -> N -> 1)
    CURRENT_GROUP=\$(( (CURRENT_GROUP % GROUPS_COUNT) + 1 ))

    # 停止并清理当前要激活组之外的所有节点
    stop_inactive_groups "\$CURRENT_GROUP"

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 🚀 正在轮换至第\$CURRENT_GROUP组 (共 \$GROUPS_COUNT 组)..."
    bash "\$SCRIPT_DIR/start_batch_group_\${CURRENT_GROUP}.sh"

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ✅ 第\$CURRENT_GROUP组节点启动/更新完成。下一次轮换将在 ${rotation_interval_hours} 小时后进行。"
    sleep \$ROTATION_INTERVAL_SECONDS
done
EOF
    chmod +x "$rotate_scheduler_path"

    # 删除旧的轮换进程
    echo "🔄 停止旧的轮换进程（如果有）..."
    pm2 delete nexus-rotate 2>/dev/null || true

    # 使用 pm2 启动轮换脚本
    echo "🚀 使用 PM2 启动节点轮换调度程序..."
    pm2 start --name "nexus-rotate" "$rotate_scheduler_path"
    pm2 save

    echo "✅ 节点轮换调度程序已启动！"
    echo "   总共 $total_nodes 个节点，分为 $num_groups 组"
    echo "   每批次同时运行 $nodes_per_round 个节点（最后一组可能不足）。"
    echo "   轮换将每 $rotation_interval_hours 小时进行一次，激活下一个批次的节点并关闭旧的。"
    echo "   💡 每个节点容器被限制为内存: $mem_per_node, CPU: $cpu_per_node。"
    echo "   💡 使用 'pm2 status' 查看轮换调度程序运行状态。"
    echo "   💡 使用 'pm2 logs nexus-rotate' 查看轮换日志。"
    echo "   💡 使用 'pm2 stop nexus-rotate' 停止轮换调度程序。"

    # 添加或更新自动清理任务
    setup_default_auto_cleanup
    
    read -rp "按任意键返回菜单"
}

# === 主菜单 ===
function main_menu() {
    while true; do
        clear
        echo "=========================================================="
        echo "               由 哈哈哈哈 编写 - @ferdie_jhovie          "
        echo "                  免费开源，谨防收费欺诈！                 "
        echo "=========================================================="
        echo "                 ✨ Nexus 多节点管理工具 ✨              "
        echo "----------------------------------------------------------"
        echo " 1. 🚀 批量节点轮换启动 (通过PM2周期性启动批次，建议)"
        echo " 2. 📊 显示所有节点状态 (CPU/内存/状态等)"
        echo " 3. 🗑️ 批量停止并卸载指定节点"
        echo " 4. 📄 查看指定节点日志"
        echo " 5. 🚨 删除全部节点 (危险操作，不可逆)"
        echo " 6. 🧹 配置/检查自动日志清理"
        echo " 7. 🚪 退出脚本"
        echo "----------------------------------------------------------"

        read -rp "请输入选项(1-7): " choice

        case $choice in
            1)
                check_docker
                batch_rotate_nodes
                ;;
            2)
                list_nodes
                ;;
            3)
                batch_uninstall_nodes
                ;;
            4)
                select_node_to_view
                ;;
            5)
                uninstall_all_nodes
                ;;
            6)
                setup_default_auto_cleanup
                read -rp "按任意键返回菜单"
                ;;
            7)
                echo "感谢使用！再见 👋。"
                exit 0
                ;;
            *)
                echo "🔴 无效选项，请重新输入。"
                read -rp "按任意键继续"
                ;;
        esac
    done
}

# 运行主菜单
main_menu
