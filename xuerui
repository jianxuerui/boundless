#!/bin/bash
set -e

# ================================================================================================
# Nexus 多节点管理脚本 (ARM64 Docker) - v4.1.14 终极 Binfmt 修复版
#
# 改版者: AI & 社区智慧
#
# 【V4.1.14 更新】:
#   - 【终极 Binfmt 修复】: 引入多层修复策略。当 Docker 无法激活 binfmt 时，
#     脚本会优先尝试在【宿主机】上安装 `qemu-user-static` 并重启 `systemd-binfmt.service`
#     来解决问题。这是一种更原生、更可靠的方法，可以绕过 AppArmor 等安全策略的限制。
#   - 【容器回退】: 只有在宿主机级别的修复失败后，才会回退到使用 Docker 容器进行安装，
#     作为最后的尝试。
#   - 【更精准的诊断】: 如果所有方法都失败，会给出明确的 AppArmor/SELinux 问题提示。
#
# ... (保留之前的版本更新说明) ...
# ================================================================================================

# --- 配置项 (可在此处自定义) ---
SCRIPT_VERSION="v4.1.14 终极 Binfmt 修复版"
# --- 此处已更新 nexus-cli 版本 ---
NEXUS_CLI_VERSION="v0.10.7"
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest-arm64"
LOG_DIR="/root/nexus_logs"
BUILDER_NAME="nexus_builder"

# --- 颜色定义 ---
COLOR_RESET='\033[0m'
COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[0;33m'
COLOR_BLUE='\033[0;34m'
COLOR_CYAN='\033[0;36m'
COLOR_BOLD='\033[1m'

# --- 辅助函数 ---
print_color() { echo -e "${2}${1}${COLOR_RESET}"; }
print_success() { print_color "$1" "$COLOR_GREEN"; }
print_error() { print_color "$1" "$COLOR_RED"; }
print_warning() { print_color "$1" "$COLOR_YELLOW"; }
print_info() { print_color "$1" "$COLOR_CYAN"; }
print_bold() { print_color "$1" "${COLOR_BOLD}${COLOR_CYAN}"; }

confirm_action() {
    local prompt_message="$1"
    read -rp "${COLOR_YELLOW}>>> ${prompt_message} (y/N): ${COLOR_RESET}" confirm
    [[ "$confirm" =~ ^[yY]([eE][sS])?$ ]]
}

# Initialize TMP_WORKDIR
TMP_WORKDIR=""
trap 'EXITCODE=$?; printf "\n"; print_info "Executing cleanup operations..."; if [ -n "$TMP_WORKDIR" ] && [ -d "$TMP_WORKDIR" ]; then rm -rf "$TMP_WORKDIR"; fi; exit $EXITCODE' EXIT HUP INT QUIT TERM

# --- Core Functions ---
check_docker_daemon() {
    if ! docker info >/dev/null 2>&1; then
        print_error "!! 致命错误: Docker 服务未运行或当前用户无权访问。"
        exit 1
    fi
}

check_docker() {
    # This function is kept from the previous version, it's already robust.
    # It ensures docker, docker-buildx-plugin are installed.
    if ! command -v docker >/dev/null 2>&1; then
        print_warning "未检测到 Docker, 正在尝试自动安装..."
        apt-get update -qq && apt-get install -y --no-install-recommends \
        apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release
        mkdir -p /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
        apt-get update -qq
        apt-get install -y --no-install-recommends docker-ce docker-ce-cli containerd.io docker-buildx-plugin
        systemctl start docker && systemctl enable docker
    fi
    if ! docker buildx version >/dev/null 2>&1; then
        print_error "!! Docker buildx 插件缺失或无法使用，脚本无法继续。!!"
        exit 1
    fi
}

# Helper to get builder status
get_builder_info() {
    local builder_name="$1"
    local builder_line
    builder_line=$(docker buildx ls | grep -w "^${builder_name}" || true)
    if [ -z "$builder_line" ]; then
        echo "NOT_FOUND"
        return
    fi
    local status="stopped"
    if echo "$builder_line" | grep -q "running"; then
        status="running"
    fi
    local is_default="false"
    if echo "$builder_line" | grep -q "^\s*${builder_name}\s\+\*\s"; then
        is_default="true"
    fi
    echo "$status $is_default"
}

check_binfmt_prerequisites() {
    print_info "   -> 正在执行 binfmt_misc 支持的宿主机预检..."
    if ! lsmod | grep -q binfmt_misc; then
        print_warning "   -> 内核模块 'binfmt_misc' 未加载。正在尝试自动加载..."
        if modprobe binfmt_misc; then
            print_success "   -> 成功加载 'binfmt_misc' 模块。"
        else
            print_error "   -> 加载 'binfmt_misc' 模块失败。这可能是致命问题。"
            return 1
        fi
    fi
    return 0
}

# NEW Host-level binfmt setup function
install_host_qemu_and_setup_binfmt() {
    print_info "   -> 尝试在宿主机上安装 qemu-user-static 以提供 binfmt 支持..."
    if ! apt-get install -y --no-install-recommends qemu-user-static >/dev/null 2>&1; then
        print_error "   -> 错误: 'apt-get install qemu-user-static' 失败。无法在宿主机上设置 binfmt。"
        return 1
    fi
    print_success "   -> 'qemu-user-static' 已成功安装。"
    
    if systemctl list-units --type=service | grep -q 'systemd-binfmt.service'; then
        print_info "   -> 正在重启 systemd-binfmt.service 以应用配置..."
        if ! systemctl restart systemd-binfmt.service; then
            print_warning "   -> 'systemd-binfmt.service' 重启失败，但可能不影响功能。"
        fi
    else
         print_warning "   -> 未找到 'systemd-binfmt.service'。'qemu-user-static' 可能需要手动配置。"
    fi
    return 0
}

# --- SETUP BUILDX - FINAL ROBUST VERSION ---
setup_buildx() {
    print_info "正在检查和配置 Buildx builder '$BUILDER_NAME'..."

    # 1. BINFMT SUPPORT: Multi-layered approach
    print_info "正在检查和配置多架构构建所需的 binfmt 支持..."
    
    # 1.1 Pull image first
    if ! docker image inspect tonistiigi/binfmt:latest >/dev/null 2>&1; then
        print_info "正在拉取 'tonistiigi/binfmt:latest' 镜像..."
        docker pull tonistiigi/binfmt:latest >/dev/null
    fi

    # 1.2 First check
    if docker run --rm --privileged tonistiigi/binfmt:latest --print 2>/dev/null | grep -q "supported"; then
        print_success "Binfmt 支持已正确配置。"
    else
        print_warning "Binfmt 支持未激活。将尝试修复..."
        
        # 1.3 Pre-flight check on host
        check_binfmt_prerequisites

        # 1.4 Primary Strategy: Install QEMU on host
        local fixed_on_host=false
        if install_host_qemu_and_setup_binfmt; then
            print_info "   -> 宿主机 QEMU 安装完成。等待 3 秒后重新验证..."
            sleep 3
            if docker run --rm --privileged tonistiigi/binfmt:latest --print 2>/dev/null | grep -q "supported"; then
                print_success "通过宿主机配置，Binfmt 支持已成功激活。"
                fixed_on_host=true
            else
                print_warning "   -> 宿主机配置后，验证仍然失败。将尝试容器回退方案。"
            fi
        else
             print_warning "   -> 宿主机配置失败。将尝试容器回退方案。"
        fi

        # 1.5 Fallback Strategy: Use container to install, if host strategy failed
        if ! $fixed_on_host; then
            print_info "   -> 正在尝试使用容器回退方案来安装 binfmt..."
            local install_output
            if ! install_output=$(docker run --rm --privileged tonistiigi/binfmt:latest --install all 2>&1); then
                print_error "!! 致命错误: 容器回退方案也失败了 ('binfmt --install all' 命令执行失败)。!!"
                print_error "--- Docker 的输出是: ---"
                print_error "$install_output"
                print_error "--------------------------"
                print_error "   这极有可能是由 AppArmor 或 SELinux 等安全策略阻止了容器的特权操作。"
                print_error "   请检查 'sudo dmesg | grep -i apparmor' 或 'sudo audit2why < /var/log/audit/audit.log' 获取线索。"
                exit 1
            fi
            
            print_info "   -> 容器安装命令已执行。等待 3 秒后进行最后验证..."
            sleep 3
            if ! docker run --rm --privileged tonistiigi/binfmt:latest --print 2>/dev/null | grep -q "supported"; then
                 print_error "!! 致命错误: 所有修复方案均已失败。无法激活 binfmt 支持。!!"
                 print_error "   请检查系统日志和 AppArmor/SELinux 配置。"
                 exit 1
            fi
            print_success "通过容器回退方案，Binfmt 支持已成功激活。"
        fi
    fi

    # 2. Builder cleanup and creation (remains the same)
    IFS=' ' read -r current_status current_is_default <<< "$(get_builder_info "$BUILDER_NAME")"
    if [ "$current_status" != "NOT_FOUND" ]; then
        print_info "检测到旧的 Buildx builder '$BUILDER_NAME'，正在清理..."
        if [ "$current_status" == "running" ]; then
            docker buildx stop "$BUILDER_NAME" >/dev/null 2>&1 || true
        fi
        docker buildx rm --force "$BUILDER_NAME" >/dev/null 2>&1 || true
        sleep 1
        print_success "旧的 builder 已清理。"
    fi
    
    print_info "正在创建新的 Buildx builder '$BUILDER_NAME'..."
    if ! docker buildx create --name "$BUILDER_NAME" --driver docker-container --bootstrap --use >/dev/null 2>&1; then
        print_error "!! Buildx builder '$BUILDER_NAME' 创建失败！!!"
        exit 1
    fi
    
    IFS=' ' read -r created_status created_is_default <<< "$(get_builder_info "$BUILDER_NAME")"
    if [ "$created_status" == "running" ] && [ "$created_is_default" == "true" ]; then
        print_success "Buildx builder '$BUILDER_NAME' 已成功创建并设置为默认。"
    else
        print_error "!! Buildx builder 创建后状态异常 ($created_status, is_default=$created_is_default)！!!"
        exit 1
    fi
}

build_image() {
    local force_build=${1:-""}
    if [[ -z "$force_build" ]] && docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        print_info "镜像 '$IMAGE_NAME' 已存在，跳过构建。"
        return
    fi
    setup_buildx
    TMP_WORKDIR=$(mktemp -d)
    cd "$TMP_WORKDIR"
    local cli_url="https://github.com/nexus-xyz/nexus-cli/releases/download/${NEXUS_CLI_VERSION}/nexus-network-linux-arm64"
    print_info "正在生成 Dockerfile..."
    cat > Dockerfile <<EOF
ARG TARGETPLATFORM=linux/arm64
FROM --platform=\$TARGETPLATFORM ubuntu:24.04
ENV DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y --no-install-recommends curl screen netcat-openbsd ca-certificates && rm -rf /var/lib/apt/lists/*
RUN curl -L -o /usr/local/bin/nexus-network ${cli_url} && chmod +x /usr/local/bin/nexus-network
COPY entrypoint.sh /
RUN chmod +x /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
VOLUME /root/.nexus
EXPOSE 8080
EOF
    cat > entrypoint.sh <<'EOF'
#!/bin/bash
set -e
echo "准备 Nexus 节点 (NODE_ID: $NODE_ID)..."
mkdir -p /root/.nexus && echo "$NODE_ID" > /root/.nexus/node-id
LOG_FILE="/root/nexus.log"
SCREEN_SESSION="nexus_$NODE_ID"
if screen -ls | grep -q "$SCREEN_SESSION"; then
  screen -S "$SCREEN_SESSION" -X quit
fi
echo "正在后台启动 Nexus 节点..."
screen -dmS "$SCREEN_SESSION" bash -c "nexus-network start --node-id \$NODE_ID | tee -a \$LOG_FILE"
sleep 2
if ! screen -ls | grep -q "$SCREEN_SESSION"; then
  echo "!! Nexus 节点启动失败, 请检查日志: \$LOG_FILE" >&2
  cat \$LOG_FILE >&2
  exit 1
fi
echo "Nexus 节点 \${NODE_ID} 启动成功。"
tail -f /dev/null
EOF
    print_info "正在构建镜像 '$IMAGE_NAME'..."
    if ! docker buildx build --builder "$BUILDER_NAME" -t "$IMAGE_NAME" . --load >/dev/null 2>&1; then
        print_error "!! Docker buildx build 失败。!!"
        exit 1
    fi
    print_success "镜像 '$IMAGE_NAME' 构建完成。"
}

run_container() {
    local node_id="$1"
    if [ -z "$node_id" ]; then print_error "错误: 未提供 Node ID"; return 1; fi
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if docker ps -a -q -f name="^${container_name}$" | grep -q .; then
        print_info "容器 '$container_name' 已存在，正在停止并移除..."
        docker stop "$container_name" >/dev/null 2>&1 || true
        docker rm "$container_name" >/dev/null 2>&1 || true
    fi
    mkdir -p "$LOG_DIR"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"
    touch "$log_file"
    print_info "正在启动节点 ${node_id} (容器: ${container_name})..."
    if ! docker run -d --name "$container_name" -v "${log_file}:/root/nexus.log" -e NODE_ID="$node_id" --restart unless-stopped "$IMAGE_NAME" >/dev/null 2>&1; then
        print_error "!! 容器 '${container_name}' 启动失败。"
        return 1
    fi
    sleep 3
    if docker ps -q -f name="^${container_name}$" | grep -q .; then
        print_success "节点 $node_id 启动成功。日志: $log_file"
    else
        print_error "节点 $node_id 启动后未在运行！请检查日志。"
        cat "$log_file"
    fi
}

stop_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if docker ps -q -f name="^${container_name}$" | grep -q .; then
        print_info "正在停止节点 $node_id..."
        docker stop "$container_name" >/dev/null
        print_success "节点 $node_id 已停止。"
    elif docker ps -a -q -f name="^${container_name}$" | grep -q .; then
        print_info "节点 $node_id 已是停止状态。"
    else
        print_error "未找到容器 '$container_name'。"
    fi
}

start_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if docker ps -a -q -f name="^${container_name}$" | grep -q .; then
        print_info "正在启动节点 $node_id..."
        docker start "$container_name" >/dev/null
        sleep 2
        if docker ps -q -f name="^${container_name}$" | grep -q .; then
             print_success "节点 $node_id 已启动。"
        else
             print_error "节点 $node_id 启动失败，请检查日志。"
        fi
    else
        print_error "未找到容器 '$container_name'。请先安装。"
    fi
}

restart_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if docker ps -a -q -f name="^${container_name}$" | grep -q .; then
        print_info "正在重启节点 $node_id..."
        docker restart "$container_name" >/dev/null
        sleep 2
        print_success "节点 $node_id 已重启。"
    else
        print_error "未找到容器 '$container_name'。"
    fi
}

uninstall_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if docker ps -a -q -f name="^${container_name}$" | grep -q .; then
        print_info "正在卸载节点 $node_id..."
        docker stop "$container_name" >/dev/null 2>&1 || true
        docker rm "$container_name" >/dev/null
        local log_file="${LOG_DIR}/nexus-${node_id}.log"
        rm -f "$log_file"
        print_success "节点 $node_id 已卸载。"
    else
        print_warning "未找到节点 $node_id 进行卸载。"
    fi
}

get_all_node_ids() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//" | sort -u
}

view_node_logs() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if ! docker ps -a -q -f name="^${container_name}$" | grep -q .; then
        print_error "未找到容器 '$container_name'。"
        return
    fi
    print_info "正在查看节点 ${node_id} 的日志 (按 Ctrl+C 退出)..."
    docker logs -f "$container_name"
}

list_nodes() {
    print_color "============================== 当前 Nexus 节点状态 ===============================" "$COLOR_BLUE"
    printf "%-40s %-28s %-12s %-18s\n" \
        "$(print_bold "节点 ID (容器名)")" "$(print_bold "状态")" "$(print_bold "CPU %")" "$(print_bold "内存使用")"
    print_color "----------------------------------------------------------------------------------" "$COLOR_BLUE"
    
    local nodes=$(get_all_node_ids)
    if [ -z "$nodes" ]; then
        print_warning "未找到任何 Nexus 节点容器。"
    else
        local running_containers=$(docker ps -q -f name="${BASE_CONTAINER_NAME}-")
        declare -A stats_map
        if [ -n "$running_containers" ]; then
            local stats_output=$(docker stats --no-stream --format "{{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}")
            while IFS=$'\t' read -r name cpu mem; do
                stats_map["$name"]="$cpu\t$mem"
            done <<< "$stats_output"
        fi

        for node_id in $nodes; do
            local container_name="${BASE_CONTAINER_NAME}-${node_id}"
            local status_raw=$(docker ps -a --filter "name=^${container_name}$" --format "{{.Status}}")
            local formatted_status
            local cpu_perc="N/A"
            local mem_usage="N/A"
            
            if [[ "$status_raw" == *"Up"* ]]; then
                formatted_status=$(print_color "$status_raw" "$COLOR_GREEN")
                if [[ -v stats_map["$container_name"] ]]; then
                    IFS=$'\t' read -r cpu_perc mem_usage <<< "${stats_map[$container_name]}"
                fi
            elif [[ "$status_raw" == *"Exited"* ]]; then
                formatted_status=$(print_color "$status_raw" "$COLOR_YELLOW")
            else
                formatted_status=$(print_color "${status_raw:-Not Found}" "$COLOR_RED")
            fi
            
            printf "%-40s %-28s %-12s %-18s\n" "$node_id ($container_name)" "$formatted_status" "$cpu_perc" "$mem_usage"
        done
    fi
    print_color "==================================================================================" "$COLOR_BLUE"
}

select_node_action() {
    local action_callback="$1"
    local prompt_message="$2"
    local nodes=($(get_all_node_ids))
    if [ ${#nodes[@]} -eq 0 ]; then
        print_warning "当前无任何节点可操作。"; read -n 1 -s -r -p "按任意键返回..."; return
    fi
    echo "请选择要'${prompt_message}'的节点:"
    for i in "${!nodes[@]}"; do
        printf "  ${COLOR_CYAN}%2d.${COLOR_RESET} %s\n" "$((i+1))" "${nodes[$i]}"
    done
    echo "   0. 返回主菜单"
    read -rp "${COLOR_YELLOW}请输入选项: ${COLOR_RESET}" choice
    if [[ "$choice" =~ ^[1-9][0-9]*$ ]] && [ "$choice" -le ${#nodes[@]} ]; then
        "$action_callback" "${nodes[$((choice-1))]}"
    elif [ "$choice" != "0" ]; then
        print_error "无效输入。"
    fi
    read -n 1 -s -r -p "按任意键返回..."
}

select_multiple_nodes_action() {
    local action_callback="$1"
    local prompt_message="$2"
    local nodes=($(get_all_node_ids))
    if [ ${#nodes[@]} -eq 0 ]; then
        print_warning "当前无任何节点可操作。"; read -n 1 -s -r -p "按任意键返回..."; return
    fi
    echo "请选择要'${prompt_message}'的节点 (可多选，用空格隔开; 'all' 全选):"
    for i in "${!nodes[@]}"; do
        printf "  ${COLOR_CYAN}%2d.${COLOR_RESET} %s\n" "$((i+1))" "${nodes[$i]}"
    done
    echo "   0. 返回主菜单"
    read -rp "${COLOR_YELLOW}请输入选项: ${COLOR_RESET}" choices_str
    if [ "$choices_str" = "0" ] || [ -z "$choices_str" ]; then return; fi
    local selected_nodes=()
    if [ "$choices_str" = "all" ]; then
        selected_nodes=("${nodes[@]}")
    else
        for choice in $choices_str; do
            if [[ "$choice" =~ ^[1-9][0-9]*$ ]] && [ "$choice" -le ${#nodes[@]} ]; then
                selected_nodes+=("${nodes[$((choice-1))]}")
            else
                print_warning "输入 '$choice' 无效, 已忽略。"
            fi
        done
    fi
    if [ ${#selected_nodes[@]} -gt 0 ] && confirm_action "确认对选定节点执行 '${prompt_message}'?"; then
        for node_id in "${selected_nodes[@]}"; do
            print_info "--- 操作节点: $node_id ---"
            "$action_callback" "$node_id"
        done
        print_success "批量操作完成。"
    else
        print_info "操作已取消。"
    fi
    read -n 1 -s -r -p "按任意键返回..."
}

menu_install_single() {
    read -rp "${COLOR_YELLOW}请输入要安装的 Node ID: ${COLOR_RESET}" node_id
    node_id=$(echo "$node_id" | xargs | sed 's/[^a-zA-Z0-9_-]//g')
    if [ -z "$node_id" ]; then
        print_warning "未输入有效 Node ID。"
    else
        if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
            print_warning "镜像 '$IMAGE_NAME' 未构建。将首先构建镜像。"
            build_image "--force"
        fi
        run_container "$node_id"
    fi
    read -n 1 -s -r -p "按任意键返回..."
}

menu_batch_install() {
    if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        print_warning "镜像 '$IMAGE_NAME' 未构建。将首先构建镜像。"
        build_image "--force"
    fi
    print_info "请输入多个 Node ID，每行一个，空行结束:"
    local node_ids=()
    while read -r line && [ -n "$line" ]; do
        node_ids+=($(echo "$line" | xargs | sed 's/[^a-zA-Z0-9_-]//g'))
    done
    if [ ${#node_ids[@]} -gt 0 ] && confirm_action "确认安装 ${#node_ids[@]} 个新节点?"; then
        for node_id in "${node_ids[@]}"; do
            print_info "--- 安装节点: $node_id ---"
            run_container "$node_id"
        done
        print_success "批量安装完成。"
    else
        print_info "操作已取消。"
    fi
    read -n 1 -s -r -p "按任意键返回..."
}

menu_update() {
    while true; do
        clear
        print_color "============================ 系统维护与更新 ============================" "$COLOR_BLUE"
        echo "  ${COLOR_CYAN}1${COLOR_RESET}. 强制重新构建 Docker 镜像 (更新 nexus-cli)"
        echo "  ${COLOR_CYAN}2${COLOR_RESET}. 更新所有正在运行的节点 (滚动更新)"
        echo "  ${COLOR_CYAN}3${COLOR_RESET}. 清理所有节点、镜像和数据"
        echo "  ${COLOR_CYAN}0${COLOR_RESET}. 返回主菜单"
        echo
        read -rp "${COLOR_YELLOW}请输入选项: ${COLOR_RESET}" choice
        case $choice in
            1) build_image "--force";;
            2) 
               if confirm_action "此操作将重建镜像并重启所有【运行中】的节点，确定吗?"; then
                   build_image "--force"
                   local running_nodes=$(docker ps --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//")
                   if [ -n "$running_nodes" ]; then
                       for node_id in $running_nodes; do
                           print_info "--- 更新节点: $node_id ---"
                           run_container "$node_id"
                       done
                       print_success "所有运行中节点已更新。"
                   else
                       print_warning "没有正在运行的节点需要更新。"
                   fi
               else
                   print_info "操作取消。"
               fi
               ;;
            3)
               if confirm_action "【【警告】】此操作将删除所有节点容器、日志、镜像和 builder，数据将丢失！确定吗?"; then
                    local all_nodes=($(get_all_node_ids))
                    if [ ${#all_nodes[@]} -gt 0 ]; then
                        for node_id in "${all_nodes[@]}"; do uninstall_node "$node_id"; done
                    fi
                    if docker image inspect "$IMAGE_NAME" &>/dev/null; then
                        print_info "正在移除镜像 '$IMAGE_NAME'..."
                        docker rmi -f "$IMAGE_NAME" &>/dev/null
                    fi
                    if docker buildx ls | grep -q "$BUILDER_NAME"; then
                        print_info "正在移除 builder '$BUILDER_NAME'..."
                        docker buildx rm "$BUILDER_NAME" &>/dev/null
                    fi
                    print_success "清理完成。"
               else
                    print_info "操作取消。"
               fi
               ;;
            0) break;;
            *) print_error "无效选项。";;
        esac
        read -n 1 -s -r -p "按任意键返回..."
    done
}

main_menu() {
    if [ "$(id -u)" -ne 0 ]; then 
        print_error "错误: 此脚本需要 root 权限运行。"
        exit 1 
    fi
    check_docker_daemon
    check_docker

    while true; do
        clear
        print_color "==================================================================================" "$COLOR_BLUE"
        print_color "           Nexus 管理脚本 (ARM64 Docker) - ${SCRIPT_VERSION}" "$COLOR_CYAN"
        list_nodes

        print_info "\n--- 节点管理 ---"
        echo "  ${COLOR_CYAN}1${COLOR_RESET}. 安装/启动单个节点        ${COLOR_CYAN}4${COLOR_RESET}. 停止指定节点"
        echo "  ${COLOR_CYAN}2${COLOR_RESET}. 查看指定节点日志         ${COLOR_CYAN}5${COLOR_RESET}. 启动已停止的节点"
        echo "  ${COLOR_CYAN}3${COLOR_RESET}. 卸载指定节点             ${COLOR_CYAN}6${COLOR_RESET}. 重启指定节点"
        print_info "\n--- 批量操作 ---"
        echo "  ${COLOR_CYAN}7${COLOR_RESET}. 批量安装/启动新节点      ${COLOR_CYAN}10${COLOR_RESET}. 批量卸载节点"
        echo "  ${COLOR_CYAN}8${COLOR_RESET}. 批量停止节点             ${COLOR_CYAN}9${COLOR_RESET}. 批量启动/重启节点"
        print_info "\n--- 系统维护 ---"
        echo "  ${COLOR_CYAN}11${COLOR_RESET}. 系统更新与维护"
        echo "   ${COLOR_CYAN}0${COLOR_RESET}. 退出脚本"
        echo
        
        read -rp "${COLOR_YELLOW}请输入选项: ${COLOR_RESET}" choice
        case $choice in
            1) menu_install_single ;;
            2) select_node_action view_node_logs "查看日志" ;;
            3) select_node_action uninstall_node "卸载" ;;
            4) select_node_action stop_node "停止" ;;
            5) select_node_action start_node "启动" ;;
            6) select_node_action restart_node "重启" ;;
            7) menu_batch_install ;;
            8) select_multiple_nodes_action stop_node "停止" ;;
            9) select_multiple_nodes_action start_node "启动" ;;
            10) select_multiple_nodes_action uninstall_node "卸载" ;;
            11) menu_update ;;
            0) print_info "感谢使用！"; exit 0 ;;
            *) print_error "无效选项。" && sleep 1 ;;
        esac
    done
}

main_menu
