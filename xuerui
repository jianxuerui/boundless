#!/bin/bash
set -e

# ================================================================================================
# Nexus 多节点管理脚本 (ARM64 Docker) - v5.9.2 依赖修复版
#
# 改版者: AI & 社区智慧
#
# 【V5.9.2 - 依赖修复版】:
#   - 【修复】: 解决了容器启动后因缺少运行时依赖库而立即崩溃（Restarting (1)）的问题。
#     在 Dockerfile 中明确安装了 libc6, libssl3, wget, net-tools, iproute2 等核心
#     依赖包，确保 nexus-network 程序能在干净的 Ubuntu 22.04 环境中正常运行。
#
# 【V5.9.1 - 命令修复版】:
#   - 【修复】: 修正了 entrypoint.sh 中 nexus-network 的启动命令，移除了错误的 --node-id 参数。
#
# 【V5.9 - 稳定性与健壮性重构】:
#   - 【根治掉线】: 废除 'screen' 反模式，使 nexus-network 作为容器主进程 (PID 1) 运行。
#   - 【智能重启】: 利用 Docker 的 '--restart unless-stopped' 策略实现服务自愈。
#   - 【原生日志】: 使用 'docker logs' 统一收集日志，弃用主机挂载。
#   - 【主动健康检查】: 新增 HEALTHCHECK 指令，提供更精准的节点健康状态。
#   - 【资源隔离】: 增加 CPU 和 内存限制配置。
#
# ================================================================================================

# --- 配置项 ---
SCRIPT_VERSION="v5.9.2 依赖修复版"
NEXUS_CLI_VERSION="v0.10.8"
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:stable-arm64" # 镜像名更新以反映其稳定性
BUILDER_NAME="nexus_builder"

# 【新增】资源限制配置 (可根据服务器情况调整, '0' 表示不限制)
# 例如: 限制为 0.5 个 CPU 核心 和 512MB 内存
NODE_CPU_LIMIT="0"  # '0.5', '1', '2' 等
NODE_MEM_LIMIT="0"  # '512m', '1g' 等

# --- 颜色定义 ---
COLOR_RESET='\033[0m'; COLOR_RED='\033[0;31m'; COLOR_GREEN='\033[0;32m'; COLOR_YELLOW='\033[0;33m';
COLOR_BLUE='\033[0;34m'; COLOR_CYAN='\033[0;36m'; COLOR_BOLD='\033[1m'

# --- 全局变量和退出陷阱 ---
TMP_WORKDIR="";
cleanup() {
    EXITCODE=$?
    printf "\n"; print_info "正在执行清理程序..."
    docker buildx use default &>/dev/null || true # 恢复默认builder
    docker buildx rm "$BUILDER_NAME" &>/dev/null || true
    [ -n "$TMP_WORKDIR" ] && [ -d "$TMP_WORKDIR" ] && rm -rf "$TMP_WORKDIR"
    exit $EXITCODE
}
trap cleanup EXIT HUP INT QUIT TERM

# --- 辅助函数 ---
print_color() { echo -e "${2}${1}${COLOR_RESET}"; }; print_success() { print_color "$1" "$COLOR_GREEN"; }
print_error() { print_color "$1" "$COLOR_RED"; }; print_warning() { print_color "$1" "$COLOR_YELLOW"; }
print_info() { print_color "$1" "$COLOR_CYAN"; }; print_bold() { print_color "$1" "${COLOR_BOLD}${COLOR_CYAN}"; }
safe_sleep() { read -t "$1" < /dev/null 2>/dev/null || true; }
confirm_action() { read -rp "${COLOR_YELLOW}>>> ${1} (y/N): ${COLOR_RESET}" c; [[ "$c" =~ ^[yY]([eE][sS])?$ ]]; }


# --- 环境准备核心函数 --- (保持不变)
fix_centos_repos() { if [ -f /etc/os-release ]; then . /etc/os-release; if [[ "$ID" == "centos" && "$VERSION_ID" == "8" ]]; then print_warning "检测到 CentOS 8，正在自动修复软件源..."; local repo_dir="/etc/yum.repos.d"; if [ ! -d "${repo_dir}.bak" ]; then cp -r ${repo_dir} ${repo_dir}.bak; fi; sed -i 's/mirrorlist/#mirrorlist/g' ${repo_dir}/CentOS-*.repo; sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' ${repo_dir}/CentOS-*.repo; yum clean all >/dev/null; yum makecache; print_success "CentOS 8 软件源修复成功！"; fi; fi; }
prepare_system() { print_bold "第一阶段: 系统环境准备"; print_info "检查网络..."; if ! ping -c 1 -W 3 8.8.8.8 &>/dev/null; then print_error "!! 致命网络错误: 无法 PING 通 8.8.8.8。"; exit 1; fi; print_success "网络连通性正常。"; fix_centos_repos; print_info "检查核心工具..."; local packages_to_install=(); if command -v apt-get &>/dev/null; then ! command -v gpg &>/dev/null && packages_to_install+=("gnupg"); ! command -v lsb_release &>/dev/null && packages_to_install+=("lsb-release"); elif command -v yum &>/dev/null || command -v dnf &>/dev/null; then ! command -v yum-config-manager &>/dev/null && packages_to_install+=("yum-utils"); fi; if [ ${#packages_to_install[@]} -gt 0 ]; then print_warning "即将安装缺失工具包: ${packages_to_install[@]}"; if command -v apt-get &>/dev/null; then apt-get update -qq >/dev/null && apt-get install -y ${packages_to_install[@]} >/dev/null; else $(command -v dnf || command -v yum) install -y ${packages_to_install[@]} >/dev/null; fi; print_success "核心工具安装完成。"; else print_success "核心工具均已存在。"; fi; }

# --- Docker及构建环境函数 --- (保持不变)
ensure_docker_ready() { print_bold "第二阶段: Docker环境部署"; if docker info >/dev/null 2>&1; then print_success "Docker已安装并正在运行。"; return 0; fi; if ! command -v docker &> /dev/null; then print_warning "Docker未安装，正在自动安装..."; if [ -f /etc/os-release ]; then . /etc/os-release; OS_ID=$ID; else print_error "!! 无法检测操作系统类型。"; exit 1; fi; case "$OS_ID" in ubuntu|debian) print_info "正在为 Debian/Ubuntu 安装 Docker..."; apt-get update -qq >/dev/null; apt-get install -y --no-install-recommends ca-certificates curl gnupg lsb-release >/dev/null; mkdir -p /etc/apt/keyrings; curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg; echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null; apt-get update -qq >/dev/null; apt-get install -y --no-install-recommends docker-ce docker-ce-cli containerd.io docker-buildx-plugin >/dev/null;; centos|rhel|fedora|rocky|almalinux) print_info "正在为 RHEL/CentOS 安装 Docker..."; yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo >/dev/null; yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin;; *) print_error "!! 不支持的操作系统: $OS_ID。"; exit 1;; esac; print_info "启动并设置Docker开机自启..."; systemctl start docker && systemctl enable docker; safe_sleep 3; fi; if ! docker info >/dev/null 2>&1; then print_warning "Docker 服务未运行，正在启动..."; systemctl start docker; safe_sleep 3; if ! docker info >/dev/null 2>&1; then print_error "!! 启动 Docker 服务失败。"; exit 1; fi; fi; print_success "Docker 环境准备就绪。"; }
setup_buildx() { print_bold "第三阶段: Docker Buildx 多架构构建环境配置"; print_info "配置多架构支持..."; if ! docker image inspect tonistiigi/binfmt:latest &>/dev/null; then docker pull tonistiigi/binfmt:latest; fi; if ! docker run --rm --privileged tonistiigi/binfmt:latest --install all >/dev/null 2>&1; then print_error "!!!!!!!!!!!!!!! 致命错误 !!!!!!!!!!!!!!!!!"; print_error " 无法通过特权容器与内核交互。这通常由 AppArmor 或 SELinux 导致。"; if command -v apt-get &>/dev/null; then print_error "   【修复】Ubuntu/Debian: ${COLOR_CYAN}sudo apt-get install apparmor-utils -y && sudo aa-complain /etc/apparmor.d/docker${COLOR_RESET}"; else print_error "   【修复】CentOS/RHEL: ${COLOR_CYAN}sudo setenforce 0 && sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config${COLOR_RESET}"; fi; exit 1; fi; print_success "Binfmt 支持已配置。"; print_info "设置 Buildx builder '$BUILDER_NAME'..."; if ! (docker buildx ls | grep -q "^${BUILDER_NAME}"); then docker buildx create --name "$BUILDER_NAME" --driver docker-container --bootstrap >/dev/null 2>&1; fi; docker buildx use "$BUILDER_NAME"; print_success "Buildx builder '$BUILDER_NAME' 已就绪。"; }

# ---【核心函数 - 构建镜像与运行容器】---
build_image() {
    if [[ "$1" != "--force" ]] && docker image inspect "$IMAGE_NAME" &>/dev/null; then 
        print_info "镜像 '$IMAGE_NAME' 已存在，跳过构建。"
        return 0;
    fi
    
    print_bold "第四阶段: 构建健壮的Nexus节点镜像"
    setup_buildx;
    
    TMP_WORKDIR=$(mktemp -d); cd "$TMP_WORKDIR"
    cli_url="https://github.com/nexus-xyz/nexus-cli/releases/download/${NEXUS_CLI_VERSION}/nexus-network-linux-arm64"
    print_info "正在生成 Dockerfile (v5.9.2)...";
    
    # 【魔改核心】重写 Dockerfile 和 entrypoint
    cat > Dockerfile <<EOF
# 使用更稳定的 Ubuntu 22.04 LTS 作为基础镜像
FROM --platform=linux/arm64 ubuntu:22.04

ENV DEBIAN_FRONTEND=noninteractive

# 【最终修复】安装核心运行时依赖，解决 "Restarting (1)" 问题
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    ca-certificates \
    curl \
    procps \
    libc6 \
    libssl3 \
    wget \
    net-tools \
    iproute2 && \
    rm -rf /var/lib/apt/lists/*

# 下载CLI工具并赋予执行权限
ADD ${cli_url} /usr/local/bin/nexus-network
RUN chmod +x /usr/local/bin/nexus-network

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# nexus-cli 将数据写入 /root/.nexus
VOLUME /root/.nexus
ENTRYPOINT ["/entrypoint.sh"]

# 健康检查：每分钟检查一次 nexus-network 进程是否存在
HEALTHCHECK --interval=1m --timeout=10s --retries=3 \
  CMD pgrep -x nexus-network >/dev/null || exit 1
EOF

    cat > entrypoint.sh <<'EOF'
#!/bin/bash
set -e

# 检查环境变量
if [ -z "$NODE_ID" ]; then
    echo "错误: 未设置NODE_ID环境变量!" >&2
    exit 1
fi

# 初始化节点ID文件 (如果不存在)
if [ ! -f /root/.nexus/node-id ]; then
    echo "正在为节点 $NODE_ID 初始化配置..."
    mkdir -p /root/.nexus
    echo "$NODE_ID" > /root/.nexus/node-id
fi

echo ">>> 即将启动 Nexus 节点 $NODE_ID... 日志将由 Docker 捕获 <<<"

# 【核心命令】使用 exec，让 nexus-network 成为容器主进程 (PID 1)
exec nexus-network start
EOF

    print_info "正在构建镜像 '$IMAGE_NAME'..."; if ! docker buildx build --builder "$BUILDER_NAME" -t "$IMAGE_NAME" . --load; then print_error "!! Docker 镜像构建失败。"; exit 1; fi
    print_success "镜像 '$IMAGE_NAME' 构建成功。"
}

run_container() {
    local node_id="$1";
    [ -z "$node_id" ] && { print_error "Node ID不能为空。"; return 1; };
    local cname="${BASE_CONTAINER_NAME}-${node_id}";
    if [ -n "$(docker ps -a -q -f name="^${cname}$")" ]; then
        docker stop "$cname" &>/dev/null || true
        docker rm "$cname" &>/dev/null || true
    fi
    
    local run_opts=""
    if [[ "$NODE_MEM_LIMIT" != "0" && -n "$NODE_MEM_LIMIT" ]]; then run_opts+=" --memory=${NODE_MEM_LIMIT}"; fi
    if [[ "$NODE_CPU_LIMIT" != "0" && -n "$NODE_CPU_LIMIT" ]]; then run_opts+=" --cpus=${NODE_CPU_LIMIT}"; fi

    print_info "正在启动节点 ${node_id} (CPU: ${NODE_CPU_LIMIT:-无}, 内存: ${NODE_MEM_LIMIT:-无})..."
    
    if ! docker run -d --name "$cname" -e NODE_ID="$node_id" $run_opts --restart unless-stopped "$IMAGE_NAME" &>/dev/null; then
        print_error "!! 容器 '${cname}' 启动失败。"; return 1
    fi
    
    print_info "等待容器稳定 (5秒)..."
    safe_sleep 5
    
    if [ -n "$(docker ps -q -f name="^${cname}$")" ]; then
        print_success "节点 $node_id 启动成功。使用菜单选项 '2' 查看实时日志。"
    else
        print_error "!! 节点 $node_id 启动后未能保持运行！"
        print_warning "请立即查看容器启动日志以排查问题:"
        docker logs "$cname"
    fi
}

# --- 其他管理函数 ---
stop_node() { local cname="${BASE_CONTAINER_NAME}-${1}"; if [ -n "$(docker ps -q -f name="^${cname}$")" ]; then docker stop "$cname" &>/dev/null && print_success "节点 ${1} 已停止。"; else print_info "节点 ${1} 已是停止状态。"; fi; }
start_node() { local cname="${BASE_CONTAINER_NAME}-${1}"; if [ -n "$(docker ps -a -q -f name="^${cname}$")" ]; then docker start "$cname" &>/dev/null; safe_sleep 2; if [ -n "$(docker ps -q -f name="^${cname}$")" ]; then print_success "节点 ${1} 已启动。"; fi; else print_error "未找到节点 ${1}。"; fi; }
restart_node() { local cname="${BASE_CONTAINER_NAME}-${1}"; if [ -n "$(docker ps -a -q -f name="^${cname}$")" ]; then docker restart "$cname" &>/dev/null; safe_sleep 2; print_success "节点 ${1} 已重启。"; else print_error "未找到节点 ${1}。"; fi; }
uninstall_node() { local cname="${BASE_CONTAINER_NAME}-${1}"; print_info "正在卸载节点 ${1}..."; if [ -n "$(docker ps -a -q -f name="^${cname}$")" ]; then docker stop "$cname" &>/dev/null || true; docker rm "$cname" &>/dev/null || true; fi; print_success "节点 ${1} 已卸载。"; }
get_all_node_ids() { docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//" | sort -u; }
view_node_logs() { print_info "按 Ctrl+C 退出日志查看。"; docker logs -f "${BASE_CONTAINER_NAME}-${1}"; }
list_nodes() {
    print_color "======================================= 当前 Nexus 节点状态 =======================================" "$COLOR_BLUE";
    printf "%-38s %-32s %-12s %-18s\n" "$(print_bold "节点ID(容器名)")" "$(print_bold "状态")" "$(print_bold "CPU")" "$(print_bold "内存")";
    print_color "---------------------------------------------------------------------------------------------------" "$COLOR_BLUE";
    local nodes=$(get_all_node_ids);
    if [ -z "$nodes" ]; then print_warning "未找到任何 Nexus 节点。";
    else
        declare -A stats_map;
        if [ -n "$(docker ps -q -f name="${BASE_CONTAINER_NAME}-")" ]; then local stats_output=$(docker stats --no-stream --format "{{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"); while IFS=$'\t' read -r name cpu mem; do stats_map["$name"]="$cpu\t$mem"; done <<< "$stats_output"; fi;
        for id in $nodes; do
            local cname="${BASE_CONTAINER_NAME}-${id}";
            local raw_status=$(docker ps -a -f name="^${cname}$" --format "{{.Status}}")
            local status_text=""; local s_color="$COLOR_RED"; local cpu="N/A"; local mem="N/A"
            if [[ "$raw_status" == *"Up"* ]]; then
                if [[ "$raw_status" == *"(healthy)"* ]]; then s_color="$COLOR_GREEN"; status_text="运行中 (健康)"; elif [[ "$raw_status" == *"(unhealthy)"* ]]; then s_color="$COLOR_RED"; status_text="运行中 (不健康!)"; elif [[ "$raw_status" == *"(health: starting)"* ]]; then s_color="$COLOR_YELLOW"; status_text="启动中 (健康检查..)"; else s_color="$COLOR_GREEN"; status_text="运行中"; fi
                if [[ -v stats_map["$cname"] ]]; then IFS=$'\t' read -r cpu mem <<< "${stats_map[$cname]}"; fi;
            elif [[ "$raw_status" == *"Exited"* ]]; then s_color="$COLOR_YELLOW"; status_text="已退出"; elif [[ "$raw_status" == *"Created"* ]]; then s_color="$COLOR_CYAN"; status_text="已创建"; else status_text="$raw_status"; fi;
            printf "%-38s %-32s %-12s %-18s\n" "$id ($cname)" "$(print_color "$status_text" "$s_color")" "$cpu" "$mem"
        done;
    fi;
    print_color "===================================================================================================" "$COLOR_BLUE";
}

# --- 菜单交互函数 ---
select_node_action() { local action_callback="$1"; local prompt_message="$2"; local nodes=($(get_all_node_ids)); if [ ${#nodes[@]} -eq 0 ]; then print_warning "无节点可操作。"; read -n 1 -s -r -p "按任意键返回..."; return; fi; echo "选择要'${prompt_message}'的节点:"; for i in "${!nodes[@]}"; do printf "  ${COLOR_CYAN}%d.${COLOR_RESET} %s\n" "$((i+1))" "${nodes[$i]}"; done; read -rp "请输入选项 (0 返回): " choice; if [[ "$choice" =~ ^[1-9][0-9]*$ ]] && [ "$choice" -le ${#nodes[@]} ]; then "$action_callback" "${nodes[$((choice-1))]}"; fi; read -n 1 -s -r -p "按任意键返回..."; }
select_multiple_nodes_action() { local action_callback="$1"; local prompt_message="$2"; local nodes=($(get_all_node_ids)); if [ ${#nodes[@]} -eq 0 ]; then print_warning "无节点可操作。"; read -n 1 -s -r -p "按任意键返回..."; return; fi; echo "选择要'${prompt_message}'的节点(多选用空格; 'all'全选):"; for i in "${!nodes[@]}"; do printf "  ${COLOR_CYAN}%d.${COLOR_RESET} %s\n" "$((i+1))" "${nodes[$i]}"; done; read -rp "请输入选项 (0 返回): " choices_str; if [ "$choices_str" = "0" ] || [ -z "$choices_str" ]; then return; fi; local selected=(); if [ "$choices_str" = "all" ]; then selected=("${nodes[@]}"); else for c in $choices_str; do if [[ "$c" =~ ^[1-9][0-9]*$ ]] && [ "$c" -le ${#nodes[@]} ]; then selected+=("${nodes[$((c-1))]}"); fi; done; fi; if [ ${#selected[@]} -gt 0 ] && confirm_action "确认'${prompt_message}'选中的 ${#selected[@]} 个节点?"; then for id in "${selected[@]}"; do "$action_callback" "$id"; done; print_success "批量操作完成。"; fi; read -n 1 -s -r -p "按任意键返回..."; }
menu_install_single() { read -rp "请输入要安装的 Node ID: " id; id=$(echo "$id"|xargs); if [ -n "$id" ]; then build_image; run_container "$id"; else print_warning "ID 无效。"; fi; read -n 1 -s -r -p "按任意键返回..."; }
menu_batch_install() { build_image; print_info "请输入多个Node ID(每行一个,空行结束):"; local ids=(); while read -r line && [ -n "$line" ]; do ids+=("$(echo "$line"|xargs)"); done; if [ ${#ids[@]} -gt 0 ] && confirm_action "确认安装 ${#ids[@]} 个新节点?"; then for id in "${ids[@]}"; do run_container "$id"; done; fi; read -n 1 -s -r -p "按任意键返回..."; }
menu_update() { while true; do clear; print_color "===== 系统维护与更新 =====" "$COLOR_BLUE"; echo " 1. 强制重构镜像"; echo " 2. 更新所有运行中节点 (重建镜像并重启)"; echo " 3. 清理所有数据"; echo " 0. 返回"; read -rp "请输入选项: " choice; case $choice in 1) build_image "--force";; 2) if confirm_action "这将强制重建镜像，并用新镜像重启所有正在运行的节点。确定吗?"; then print_info "步骤1: 强制重构镜像..."; if ! build_image --force; then print_error "镜像构建失败，更新中止。"; break; fi; print_success "镜像构建成功。"; local running_nodes=(); while IFS= read -r line; do running_nodes+=("$line"); done < <(docker ps --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//"); if [ ${#running_nodes[@]} -gt 0 ]; then print_info "步骤2: 正在逐个更新 ${#running_nodes[@]} 个运行中的节点..."; for id in "${running_nodes[@]}"; do run_container "$id"; done; print_success "所有运行中节点更新完成。"; else print_warning "没有正在运行的节点需要更新。"; fi; fi;; 3) if confirm_action "【警告】将删除所有节点容器、镜像和builder！确定吗?"; then docker rm -f $(docker ps -a -q --filter "name=${BASE_CONTAINER_NAME}-") >/dev/null 2>&1 || true; if docker image inspect "$IMAGE_NAME" &>/dev/null; then docker rmi -f "$IMAGE_NAME"; fi; if docker buildx ls | grep -q "$BUILDER_NAME"; then docker buildx rm -f "$BUILDER_NAME"; fi; print_success "清理完成。"; fi;; 0) break;; *) print_error "无效选项。";; esac; read -n 1 -s -r -p "按任意键返回..."; done; }

main_menu() {
    if [ "$(id -u)" -ne 0 ]; then print_error "错误: 脚本需要root权限运行。"; exit 1; fi
    prepare_system
    ensure_docker_ready
    while true; do
        clear; print_color "===== Nexus 管理脚本 ${SCRIPT_VERSION} =====" "$COLOR_BLUE"; list_nodes; echo;
        print_info "--- 节点管理 ---";
        echo " 1. 安装/启动单节点     4. 停止节点";
        echo " 2. 查看节点日志       5. 启动节点";
        echo " 3. 卸载节点           6. 重启节点";
        print_info "--- 批量操作 ---";
        echo " 7. 批量安装新节点     10. 批量卸载";
        echo " 8. 批量停止节点       9. 批量启动";
        print_info "--- 系统维护 ---";
        echo " 11. 更新与维护";
        echo "  0. 退出脚本";
        echo
        read -rp "请输入选项: " choice
        case $choice in
            1) menu_install_single ;; 2) select_node_action view_node_logs "查看日志" ;; 3) select_node_action uninstall_node "卸载" ;;
            4) select_node_action stop_node "停止" ;; 5) select_node_action start_node "启动" ;; 6) select_node_action restart_node "重启" ;;
            7) menu_batch_install ;; 8) select_multiple_nodes_action stop_node "停止" ;; 9) select_multiple_nodes_action start_node "启动" ;;
            10) select_multiple_nodes_action uninstall_node "卸载" ;; 11) menu_update ;; 0) break ;; *) print_error "无效选项。" && safe_sleep 1 ;;
        esac
    done
}

# 脚本主入口
main_menu
