#!/bin/bash
set -e

# ==============================================================================
# Nexus 多节点管理脚本 (ARM64专用Docker版) - 终极防错版 v3.6
# 作者: 哈哈哈哈 (推特 @ferdie_jhovie)
#
# 【V3.6 更新】:
#   - 针对 "unexpected end of file" 错误，将大部分函数体压缩为单行，
#     以最大限度地防止因复制粘贴或格式问题导致的语法错误。
#   - 保持核心功能和所有修复不变。
# ==============================================================================

# --- 配置项 ---
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest-arm64"
LOG_DIR="/root/nexus_logs"
BUILDER_NAME="nexus_builder"

# --- 核心功能函数 ---
check_docker_daemon() { if ! docker info >/dev/null 2>&1; then echo "!! 致命错误: Docker 服务未运行或无权访问 !!"; exit 1; fi; }
check_docker() { if ! command -v docker >/dev/null 2>&1; then echo "正在安装 Docker..."; apt-get update >/dev/null; apt-get install -y apt-transport-https ca-certificates curl software-properties-common >/dev/null; curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -; add-apt-repository "deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"; apt-get update >/dev/null; apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin >/dev/null; systemctl enable --now docker; fi; if ! docker buildx version >/dev/null 2>&1; then echo "错误：未找到 Docker buildx 插件。"; exit 1; fi; }
setup_buildx() { if docker buildx ls | grep -q "^${BUILDER_NAME}.*running"; then docker buildx use $BUILDER_NAME; return; fi; echo "正在设置 Buildx 环境..."; if docker buildx ls | grep -q "$BUILDER_NAME"; then docker buildx inspect $BUILDER_NAME --bootstrap; else docker buildx create --name $BUILDER_NAME --driver docker-container --use; fi; if ! docker run --rm --privileged tonistiigi/binfmt | grep -q "setting up"; then docker run --rm --privileged tonistiigi/binfmt --install all; fi; }
build_image() { if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then return; fi; setup_buildx; WORKDIR=$(mktemp -d); cd "$WORKDIR"; cat > Dockerfile <<'EOF';
ARG TARGETPLATFORM=linux/arm64
FROM --platform=$TARGETPLATFORM ubuntu:24.04
ENV DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y curl screen bash && rm -rf /var/lib/apt/lists/*
RUN curl -L -o /usr/local/bin/nexus-network https://github.com/nexus-xyz/nexus-cli/releases/download/v0.10.1/nexus-network-linux-arm64 && chmod +x /usr/local/bin/nexus-network
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
EOF
cat > entrypoint.sh <<'EOF';
#!/bin/bash
set -e
if [ -z "$NODE_ID" ]; then exit 1; fi
mkdir -p /root/.nexus && echo "$NODE_ID" > /root/.nexus/node-id
if ! command -v nexus-network >/dev/null 2>&1; then exit 1; fi
screen -S nexus -X quit >/dev/null 2>&1 || true
screen -dmS nexus bash -c "nexus-network start --node-id $NODE_ID | tee /root/nexus.log"
sleep 3
if ! screen -list | grep -q "nexus"; then cat /root/nexus.log; exit 1; fi
tail -f /root/nexus.log
EOF
docker buildx build --builder "$BUILDER_NAME" --platform linux/arm64 -t "$IMAGE_NAME" . --load >/dev/null; cd - >/dev/null; rm -rf "$WORKDIR"; }
run_container() { local node_id="$1"; if [ -z "$node_id" ]; then echo "错误: 无 Node ID"; return 1; fi; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; docker rm -f "$container_name" >/dev/null 2>&1; mkdir -p "$LOG_DIR"; local log_file="${LOG_DIR}/nexus-${node_id}.log"; touch "$log_file" && chmod 644 "$log_file"; docker run -d --name "$container_name" -v "$log_file:/root/nexus.log" -e NODE_ID="$node_id" --restart unless-stopped "$IMAGE_NAME"; echo "节点 $node_id 已启动。日志: $log_file"; }
uninstall_node() { local node_id="$1"; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; docker rm -f "$container_name" >/dev/null 2>&1; rm -f "${LOG_DIR}/nexus-${node_id}.log"; echo "节点 $node_id 已卸载。"; }
get_all_node_ids() { docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort -u; }
view_node_logs() { local node_id="$1"; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then return 1; fi; docker logs -f "$container_name"; }
list_nodes() { echo "--------------------------------- 当前 Nexus 节点状态 ---------------------------------"; printf "%-30s %-12s %-15s %-20s\n" "节点 ID (容器名)" "状态" "CPU %" "内存使用"; echo "-------------------------------------------------------------------------------------"; all_containers_list=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}"); if [ -z "$all_containers_list" ]; then echo "未找到任何 Nexus 节点容器。"; else running_containers_list=$(docker ps --filter "name=${BASE_CONTAINER_NAME}-" --filter "status=running" --format "{{.Names}}"); stats_output=""; if [ -n "$running_containers_list" ]; then stats_output=$(docker stats --no-stream $(echo "$running_containers_list" | tr '\n' ' ') --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"); fi; echo "$all_containers_list" | while IFS= read -r name || [ -n "$name" ]; do [ -z "$name" ] && continue; local node_id=$(echo "$name" | sed "s/${BASE_CONTAINER_NAME}-//"); local stats_line=$(echo "$stats_output" | grep -w "$name"); if [ -n "$stats_line" ]; then local cpu_perc=$(echo "$stats_line" | awk '{print $2}'); local mem_usage=$(echo "$stats_line" | awk -F '\t' '{print $3}'); printf "%-30s %-12s %-15s %-20s\n" "$node_id ($name)" "Running" "$cpu_perc" "$mem_usage"; else local status=$(docker ps -a --filter "name=$name" --format "{{.Status}}"); printf "%-30s %-12s %-15s %-20s\n" "$node_id ($name)" "$status" "N/A" "N/A"; fi; done; fi; echo "-------------------------------------------------------------------------------------";}
batch_start_nodes() { build_image; echo "请输入多个 Node ID，每行一个, 空行结束:"; local node_ids=(); while IFS= read -r line; do line=$(echo "$line" | xargs); [ -z "$line" ] && break; node_ids+=("$line"); done; if [ ${#node_ids[@]} -eq 0 ]; then return; fi; for node_id in "${node_ids[@]}"; do run_container "$node_id"; sleep 1; done; }
select_node_for_action() { local action_callback="$1" prompt_message="$2"; local all_nodes=($(get_all_node_ids)); if [ ${#all_nodes[@]} -eq 0 ]; then read -p "无节点可操作，按回车返回..."; return; fi; echo "请选择要'${prompt_message}'的节点:"; echo "0. 返回"; for i in "${!all_nodes[@]}"; do local node_id="${all_nodes[$i]}" status=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-${node_id}" --format "{{.Status}}"); printf "%2d. 节点 %-25s [%s]\n" "$((i+1))" "$node_id" "$status"; done; read -rp "请输入选项(0-${#all_nodes[@]}): " choice; if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt ${#all_nodes[@]} ]; then return; fi; [ "$choice" -eq 0 ] && return; local selected_node_id="${all_nodes[$((choice-1))]}"; "$action_callback" "$selected_node_id"; }
batch_uninstall_nodes() { read -rp "确定要卸载所有节点? (y/N): " confirm; if [[ ! "$confirm" =~ ^[yY] ]]; then return; fi; for node_id in $(get_all_node_ids); do uninstall_node "$node_id"; done; echo "所有节点已卸载。"; }
uninstall_all_nodes_and_image() { read -rp "警告: 将删除所有节点和镜像！输入 'yes' 确认: " confirm; if [ "$confirm" != "yes" ]; then return; fi; batch_uninstall_nodes; if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then docker rmi -f "$IMAGE_NAME"; fi; read -rp "是否删除日志目录 '$LOG_DIR'? (y/N): " del_log; if [[ "$del_log" =~ ^[yY] ]]; then rm -rf "$LOG_DIR"; fi; }

# --- 主菜单循环 ---
main_menu() {
    if [ "$(id -u)" -ne 0 ]; then echo "错误: 请使用 root 权限运行 (sudo)。" >&2; exit 1; fi
    check_docker_daemon
    check_docker

    while true; do
        clear
        echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
        echo "================ Nexus 管理 (ARM64 Docker版) v3.6 ==================="
        echo "1. 安装/启动单个节点        5. 批量卸载所有节点"
        echo "2. 批量安装/启动多个节点    6. 完全卸载 (删除所有节点和镜像)"
        echo "3. 查看指定节点日志         7. 退出脚本"
        echo "4. 卸载指定节点"
        list_nodes
        read -rp "请输入选项(1-7): " choice
        case $choice in
            1) read -rp "请输入 Node ID: " NODE_ID; if [ -n "$NODE_ID" ]; then build_image; run_container "$NODE_ID"; fi; read -p "按任意键返回...";;
            2) batch_start_nodes; read -p "按任意键返回...";;
            3) select_node_for_action "view_node_logs" "查看日志";;
            4) select_node_for_action "uninstall_node" "卸载"; read -p "按任意键返回...";;
            5) batch_uninstall_nodes; read -p "按任意键返回...";;
            6) uninstall_all_nodes_and_image; read -p "按任意键返回...";;
            7) echo "退出脚本。"; exit 0;;
            *) echo "无效选项。"; sleep 1;;
        esac
    done
}

# --- 脚本执行入口 ---
main_menu
