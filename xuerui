#!/bin/bash

# ==============================================================================
# Nexus 多节点管理脚本 (增强版)
#
# 作者: 哈哈哈哈 (推特 @ferdie_jhovie)
# 增强: AI Assistant
#
# 特性:
# - 自动检查并安装 Docker 和 PM2
# - 支持批量启动、停止、查看和删除节点
# - 支持节点自动轮换启动 (通过 PM2)
# - 标准化日志记录，使用 `docker logs`
# - 增强的稳定性和错误处理
# ==============================================================================

# 脚本设置:
# -e: 如果命令失败，立即退出
# -u: 将未设置的变量视为错误
# -o pipefail: 如果管道中的任何命令失败，则整个管道失败
set -euo pipefail

# 全局常量
readonly BASE_CONTAINER_NAME="nexus-node"
readonly IMAGE_NAME="nexus-node:latest"
readonly LOG_DIR="/root/nexus_logs" # 注意：此目录不再用于容器日志，仅作备用
readonly SCRIPT_DIR="/root/nexus_scripts" # 轮换脚本存放目录

# 颜色定义
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[1;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_RED='\033[0;31m'
readonly COLOR_NC='\033[0m' # No Color

# 主程序入口
main() {
    check_root
    
    # 以前的日志清理任务不再必要，因为我们使用 `docker logs`
    # setup_log_cleanup_cron

    while true; do
        clear
        echo -e "${COLOR_GREEN}脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费${COLOR_NC}"
        echo -e "${COLOR_GREEN}如有问题，可联系推特，仅此只有一个号${COLOR_NC}"
        echo -e "${COLOR_BLUE}================== Nexus 多节点管理 (增强版) ==================${COLOR_NC}"
        echo -e "${COLOR_YELLOW}1.${COLOR_NC} 启动单个新节点"
        echo -e "${COLOR_YELLOW}2.${COLOR_NC} 显示所有节点状态"
        echo -e "${COLOR_YELLOW}3.${COLOR_NC} 批量停止并卸载指定节点"
        echo -e "${COLOR_YELLOW}4.${COLOR_NC} 查看指定节点日志 (使用 docker logs)"
        echo -e "${COLOR_YELLOW}5.${COLOR_NC} 设置节点定时轮换启动"
        echo -e "${COLOR_YELLOW}6.${COLOR_NC} 卸载所有节点"
        echo -e "${COLOR_RED}7.${COLOR_NC} 退出"
        echo -e "${COLOR_BLUE}==============================================================${COLOR_NC}"

        read -rp "请输入选项(1-7): " choice

        case "$choice" in
            1)
                check_docker
                read -rp "请输入您的 node-id: " NODE_ID
                if [ -z "$NODE_ID" ]; then
                    echo -e "${COLOR_RED}node-id 不能为空，请重新选择。${COLOR_NC}"
                    read -p "按任意键继续"
                    continue
                fi
                echo "开始构建镜像并启动容器..."
                build_image
                run_container "$NODE_ID"
                read -p "按任意键返回菜单"
                ;;
            2) list_nodes ;;
            3) batch_uninstall_nodes ;;
            4) select_node_to_view ;;
            5)
                check_docker
                check_pm2
                batch_rotate_nodes
                ;;
            6) uninstall_all_nodes ;;
            7)
                echo "退出脚本。"
                exit 0
                ;;
            *)
                echo -e "${COLOR_RED}无效选项，请重新输入。${COLOR_NC}"
                read -p "按任意键继续"
                ;;
        esac
    done
}

# 检查是否以 root 用户身份运行
function check_root() {
    if [ "$EUID" -ne 0 ]; then
        echo -e "${COLOR_RED}错误: 此脚本需要 root 权限来安装依赖项和管理 Docker。${COLOR_NC}"
        echo "请使用 'sudo bash $0' 运行。"
        exit 1
    fi
}

# 检查并安装 Docker
function check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "检测到未安装 Docker，正在安装..."
        apt-get update
        apt-get install -y apt-transport-https ca-certificates curl software-properties-common
        
        # 使用新的 GPG 密钥添加方法
        install -m 0755 -d /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
        chmod a+r /etc/apt/keyrings/docker.asc

        echo \
          "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
          $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
          tee /etc/apt/sources.list.d/docker.list > /dev/null
        
        apt-get update
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        systemctl enable docker
        systemctl start docker
        echo -e "${COLOR_GREEN}Docker 安装并启动成功！${COLOR_NC}"
    fi
}

# 检查并安装 Node.js/npm/pm2
function check_pm2() {
    if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
        echo "检测到未安装 Node.js/npm，正在安装..."
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
        apt-get install -y nodejs
    fi
    if ! command -v pm2 >/dev/null 2>&1; then
        echo "检测到未安装 pm2，正在安装..."
        npm install -g pm2
        pm2 startup
    fi
}

# 构建 Docker 镜像
function build_image() {
    # 如果镜像已存在，则跳过构建
    if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        echo "镜像 $IMAGE_NAME 已存在，跳过构建。"
        return
    fi
    
    echo "正在构建 Docker 镜像 $IMAGE_NAME..."
    local WORKDIR
    WORKDIR=$(mktemp -d)
    cd "$WORKDIR"

    # Dockerfile: 使用更简洁的启动方式
    cat > Dockerfile <<EOF
FROM ubuntu:24.04

ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id

# 安装依赖
RUN apt-get update && apt-get install -y curl bash && rm -rf /var/lib/apt/lists/*

# 自动下载并安装最新版 nexus-network
RUN curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh \
    && ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# 容器的入口点是 entrypoint.sh 脚本
ENTRYPOINT ["/entrypoint.sh"]
EOF

    # entrypoint.sh: 直接运行 nexus-network，让 Docker 管理日志
    cat > entrypoint.sh <<EOF
#!/bin/bash
set -euo pipefail

PROVER_ID_FILE="/root/.nexus/node-id"

if [ -z "\${NODE_ID:-}" ]; then
    echo "错误：未设置 NODE_ID 环境变量" >&2
    exit 1
fi

echo "使用的 node-id: \$NODE_ID"
# 创建并写入 ID 文件
mkdir -p /root/.nexus
echo "\$NODE_ID" > "\$PROVER_ID_FILE"

# 检查命令是否存在
if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 未安装或不可用" >&2
    exit 1
fi

echo "启动 nexus-network 节点..."
# 使用 exec 来让 nexus-network 进程替换 shell 进程
# 这使得 nexus-network 成为容器的 PID 1，Docker 可以直接管理它
# 它的所有标准输出和错误都将被 Docker 日志系统捕获
exec nexus-network start --node-id "\$NODE_ID"
EOF

    docker build -t "$IMAGE_NAME" .

    cd - >/dev/null
    rm -rf "$WORKDIR"
    echo -e "${COLOR_GREEN}镜像构建成功！${COLOR_NC}"
}

# 启动容器
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"

    if docker ps -a --format '{{.Names}}' | grep -Eq "^${container_name}$"; then
        echo -e "${COLOR_YELLOW}检测到旧容器 $container_name，正在删除...${COLOR_NC}"
        docker rm -f "$container_name"
    fi

    # --restart unless-stopped 保证容器在 Docker 守护进程启动或容器退出时自动重启
    docker run -d --restart unless-stopped --name "$container_name" -e NODE_ID="$node_id" "$IMAGE_NAME"
    echo -e "${COLOR_GREEN}容器 $container_name 已启动！${COLOR_NC}"
    echo "使用 'docker logs -f $container_name' 查看实时日志。"
}

# 卸载指定节点
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"

    echo "正在停止并删除容器 $container_name..."
    if docker ps -a --format '{{.Names}}' | grep -Eq "^${container_name}$"; then
        docker rm -f "$container_name"
    else
        echo "容器 $container_name 不存在，跳过。"
    fi

    echo -e "${COLOR_GREEN}节点 $node_id 已卸载完成。${COLOR_NC}"
}

# 列出所有节点
function list_nodes() {
    local nodes
    nodes=($(get_all_nodes))

    if [ ${#nodes[@]} -eq 0 ]; then
        echo "当前没有已部署的 Nexus 节点。"
        read -p "按任意键返回菜单"
        return
    fi
    
    echo "当前节点状态："
    echo "----------------------------------------------------------------------------------------------------"
    printf "%-25s %-20s %-12s %-20s %-10s\n" "容器名称" "状态" "启动时间" "CPU / 内存" "内存百分比"
    echo "----------------------------------------------------------------------------------------------------"
    
    # 获取所有相关容器的信息，而不是循环查询
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "table {{.Names}}\t{{.Status}}\t{{.CreatedAt}}" | tail -n +2 |
    while IFS= read -r line; do
        local container_name status created_at
        container_name=$(echo "$line" | awk '{print $1}')
        status=$(echo "$line" | awk '{for(i=2;i<=NF-3;i++) printf "%s ", $i; printf "\n"}')
        created_at=$(echo "$line" | awk '{print $NF, $(NF-1), $(NF-2)}')
        
        # 仅为运行中的容器获取统计信息
        local stats_info="N/A"
        local mem_perc="N/A"
        if [[ "$status" == Up* ]]; then
            stats_info=$(docker stats --no-stream --format "{{.CPUPerc}} / {{.MemUsage}}" "$container_name")
            mem_perc=$(docker stats --no-stream --format "{{.MemPerc}}" "$container_name")
        fi

        printf "%-25s %-20s %-12s %-20s %-10s\n" "$container_name" "$status" "$created_at" "$stats_info" "$mem_perc"
    done
    
    echo "----------------------------------------------------------------------------------------------------"
    read -p "按任意键返回菜单"
}


# 获取所有已创建的节点ID
function get_all_nodes() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 选择并查看节点日志
function select_node_to_view() {
    local all_nodes
    all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有节点。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "请选择要查看日志的节点："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        printf "%-4s 节点 %s\n" "$((i+1))." "${all_nodes[$i]}"
    done

    read -rp "请输入选项(0-${#all_nodes[@]}): " choice

    if [[ ! "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -gt ${#all_nodes[@]} ]; then
        echo -e "${COLOR_RED}无效的选项。${COLOR_NC}"
        read -p "按任意键继续"
        return
    fi
    
    if [ "$choice" -eq 0 ]; then
        return
    fi

    local selected_node_id=${all_nodes[$((choice-1))]}
    local container_name="${BASE_CONTAINER_NAME}-${selected_node_id}"

    echo "请选择日志查看模式："
    echo "1. 原始日志 (可能包含颜色代码)"
    echo "2. 清理后的日志 (移除ANSI颜色代码)"
    read -rp "请选择(1-2) [默认 1]: " log_mode

    echo "正在显示 '${container_name}' 的日志... 按 Ctrl+C 退出。"
    sleep 2
    if [ "$log_mode" = "2" ]; then
        # 移除ANSI转义序列
        docker logs -f "$container_name" | sed 's/\x1b\[[0-9;]*m//g'
    else
        docker logs -f "$container_name"
    fi
}


# 批量选择并卸载节点
function batch_uninstall_nodes() {
    local all_nodes
    all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有可卸载的节点。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "请选择要删除的节点（可多选，用空格分隔，或输入 'all' 删除全部）："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        printf "%-4s 节点 %s\n" "$((i+1))." "${all_nodes[$i]}"
    done

    read -rp "请输入选项: " choices

    if [[ "$choices" == "0" ]]; then
        return
    fi
    
    if [[ "$choices" =~ ^[Aa][Ll][Ll]$ ]]; then
        selected_choices=($(seq 1 ${#all_nodes[@]}))
    else
        read -ra selected_choices <<< "$choices"
    fi

    for choice in "${selected_choices[@]}"; do
        if [[ "$choice" -ge 1 ]] && [[ "$choice" -le ${#all_nodes[@]} ]]; then
            local selected_node=${all_nodes[$((choice-1))]}
            uninstall_node "$selected_node"
        else
            echo "跳过无效选项: $choice"
        fi
    done

    echo -e "${COLOR_GREEN}批量卸载完成！${COLOR_NC}"
    read -p "按任意键返回菜单"
}

# 卸载所有节点
function uninstall_all_nodes() {
    local all_nodes
    all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有节点可以删除。"
        read -p "按任意键返回菜单"
        return
    fi

    echo -e "${COLOR_RED}警告：此操作将停止并删除所有 ${#all_nodes[@]} 个节点容器！${COLOR_NC}"
    read -rp "确定要继续吗？(y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "操作已取消。"
        return
    fi

    echo "开始删除所有节点容器..."
    local containers_to_remove
    containers_to_remove=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}")
    if [ -n "$containers_to_remove" ]; then
        # shellcheck disable=SC2046
        docker rm -f $(echo "$containers_to_remove")
    fi
    echo "所有节点容器已删除。"
    
    read -rp "是否要删除 Docker 镜像 '$IMAGE_NAME' 以释放空间? (y/N): " confirm_image
    if [[ "$confirm_image" =~ ^[Yy]$ ]]; then
        if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
            docker rmi "$IMAGE_NAME"
            echo "镜像 '$IMAGE_NAME' 已删除。"
        else
            echo "镜像 '$IMAGE_NAME' 不存在。"
        fi
    fi

    echo -e "${COLOR_GREEN}所有节点卸载完成！${COLOR_NC}"
    read -p "按任意键返回菜单"
}

# 设置批量节点轮换
function batch_rotate_nodes() {
    echo "请输入多个 node-id，每行一个。输入一个空行或按 Ctrl+D 结束。"
    
    local node_ids_str
    node_ids_str=$(</dev/stdin)
    read -ra node_ids <<< "$node_ids_str"

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 node-id，操作取消。"
        read -p "按任意键继续"
        return
    fi

    local nodes_per_round_default=$(( (${#node_ids[@]} + 1) / 2 ))
    read -rp "请输入每2小时轮换启动的节点数量 [默认: ${nodes_per_round_default}]: " nodes_per_round
    nodes_per_round=${nodes_per_round:-$nodes_per_round_default}
    
    if ! [[ "$nodes_per_round" =~ ^[0-9]+$ ]] || [ "$nodes_per_round" -lt 1 ]; then
        echo -e "${COLOR_RED}错误: 输入必须是正整数。${COLOR_NC}"
        return
    fi
    
    echo "正在停止并移除旧的轮换任务..."
    pm2 delete "nexus-rotate" 2>/dev/null || true

    echo "正在构建或确认 Docker 镜像..."
    build_image

    mkdir -p "$SCRIPT_DIR"
    local rotate_script_path="$SCRIPT_DIR/rotate.sh"

    # 生成一个单一的、自包含的轮换脚本
    cat > "$rotate_script_path" <<EOF
#!/bin/bash
set -eu

# === 轮换配置 ===
readonly NODES=(${node_ids[*]})
readonly NODES_PER_ROUND=$nodes_per_round
readonly IMAGE_NAME="$IMAGE_NAME"
readonly BASE_CONTAINER_NAME="$BASE_CONTAINER_NAME"
# === 配置结束 ===

# 无限循环执行轮换
while true; do
    for (( i=0; i < \${#NODES[@]}; i+=NODES_PER_ROUND )); do
        
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] === 开始新一轮轮换 ==="
        
        # 1. 停止并删除所有现有节点容器
        echo "[INFO] 正在清理旧容器..."
        docker ps -a --filter "name=\${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | xargs -r docker rm -f

        # 2. 选择当前批次的节点
        current_batch=(" \${NODES[@]:i:NODES_PER_ROUND} ")

        echo "[INFO] 准备启动 \${#current_batch[@]} 个节点..."
        for node_id in \${current_batch[*]}; do
            container_name="\${BASE_CONTAINER_NAME}-\${node_id}"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] 启动节点: \${node_id} (容器名: \${container_name})"
            
            # 使用 --restart unless-stopped 保证容器稳定性
            docker run -d --restart unless-stopped \\
                --name "\${container_name}" \\
                -e NODE_ID="\${node_id}" \\
                "\${IMAGE_NAME}"
            
            # 短暂休眠，避免同时启动太多容器造成瞬时高负载
            sleep 5 
        done
        
        echo "[INFO] 本轮启动完成，等待2小时..."
        sleep 7200 # 2小时 = 7200秒
    done
done
EOF

    chmod +x "$rotate_script_path"
    
    echo "使用 PM2 启动轮换脚本..."
    pm2 start "$rotate_script_path" --name "nexus-rotate"
    pm2 save
    
    echo -e "${COLOR_GREEN}节点轮换任务已成功设置并启动！${COLOR_NC}"
    echo "总共 ${#node_ids[@]} 个节点，每2小时轮换启动 ${nodes_per_round} 个。"
    echo "使用 'pm2 status' 查看运行状态。"
    echo "使用 'pm2 logs nexus-rotate' 查看轮换日志。"
    echo "使用 'pm2 stop nexus-rotate' 停止轮换。"
    read -p "按任意键返回菜单"
}

# 运行主函数
main
