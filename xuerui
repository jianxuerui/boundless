#!/bin/bash
set -e

# ================================================================================================
# Nexus 多节点管理脚本 - v9.0.0 TTY-Kill Ultimate Edition
#
# 改版者: AI & 社区智慧
#
# 【V9.0.0 - TTY-Kill Ultimate Edition】:
#   - 【最终根本性修复】: 经过 exhaustive debugging, 确认 Nexus 程序会强制启动TUI
#     只要它能探测到任何伪终端(TTY)的可能性。
#   - 【终极解决方案】: 在'docker run'命令中添加'-T'标志。此标志直接命令Docker Daemon
#     在创建容器时不分配任何伪终端。这从容器的底层环境根除了程序启动TUI的可能性，
#     从而彻底解决了在QEMU模拟中因TTY不兼容而导致的持续崩溃问题。
#   - 【缓存粉碎】: 再次更换镜像Tag，强制Docker放弃所有陈旧缓存，确保应用此终极修复。
#
# ================================================================================================

# --- 配置项 ---
SCRIPT_VERSION="v9.0.0 TTY-Kill Ultimate Edition"
NEXUS_CLI_VERSION="v0.10.8"
BASE_CONTAINER_NAME="nexus-node"
# 【核心修复】更换全新的镜像名，粉碎旧缓存！
IMAGE_NAME="nexus-node:v9-ultimate-fix"
BUILDER_NAME="nexus_builder"
HOST_CONFIG_DIR="/root/nexus_config"
WALLET_ADDRESS="0x62250580AeC82545bD5c3133c4e293780391813c"

# ---【单节点极限性能模式】---
NODE_CPU_LIMIT="0"
NODE_MEM_LIMIT="0"

# --- 其他配置 ---
COLOR_RESET='\033[0m'; COLOR_RED='\033[0;31m'; COLOR_GREEN='\033[0;32m'; COLOR_YELLOW='\033[0;33m';
COLOR_BLUE='\033[0;34m'; COLOR_CYAN='\033[0;36m'; COLOR_BOLD='\033[1m'
TMP_WORKDIR="";
cleanup() { EXITCODE=$?; printf "\n"; print_info "清理..."; docker buildx use default &>/dev/null || true; docker buildx rm "$BUILDER_NAME" &>/dev/null || true; [ -n "$TMP_WORKDIR" ] && [ -d "$TMP_WORKDIR" ] && rm -rf "$TMP_WORKDIR"; exit $EXITCODE; }; trap cleanup EXIT HUP INT QUIT TERM
print_color() { echo -e "${2}${1}${COLOR_RESET}"; }; print_success() { print_color "$1" "$COLOR_GREEN"; }; print_error() { print_color "$1" "$COLOR_RED"; }; print_warning() { print_color "$1" "$COLOR_YELLOW"; }; print_info() { print_color "$1" "$COLOR_CYAN"; }; print_bold() { print_color "$1" "${COLOR_BOLD}${COLOR_CYAN}"; }; safe_sleep() { read -t "$1" < /dev/null 2>/dev/null || true; };
press_any_key() { read -n 1 -s -r -p "按任意键返回..."; }
prepare_system() { print_bold "第一阶段: 系统环境准备"; if ! ping -c 1 -W 3 8.8.8.8 &>/dev/null; then print_error "!! 致命网络错误。"; exit 1; fi; print_success "网络正常。"; };
ensure_docker_ready() { print_bold "第二阶段: Docker环境部署"; if docker info >/dev/null 2>&1; then print_success "Docker已在运行。"; return 0; fi; print_error "!! Docker 未运行。"; exit 1; };

# --- 核心功能函数 ---
setup_cross_platform_env() {
    print_bold "第三阶段: 配置跨平台模拟环境"; print_info "正在安装/刷新 QEMU 模拟器支持 (binfmt)..."
    docker run --rm --privileged tonistiigi/binfmt --install all &>/dev/null; print_success "跨平台模拟环境已就绪。"
    print_info "设置 Buildx builder '$BUILDER_NAME'..."; docker buildx create --name "$BUILDER_NAME" --driver docker-container --bootstrap >/dev/null 2>&1 || true
    docker buildx use "$BUILDER_NAME"; print_success "Buildx builder 已就绪。"
}

build_image() {
    if [[ "$1" != "--force" ]] && docker image inspect "$IMAGE_NAME" &>/dev/null; then print_info "镜像 '$IMAGE_NAME' 已存在，跳过。"; return 0; fi
    print_bold "第四阶段: 构建 arm64 节点镜像"; setup_cross_platform_env
    TMP_WORKDIR=$(mktemp -d); cd "$TMP_WORKDIR"
    cli_url="https://github.com/nexus-xyz/nexus-cli/releases/download/${NEXUS_CLI_VERSION}/nexus-network-linux-arm64"
    print_info "正在生成 Dockerfile (v9.0.0 - 终极修复)...";
    
    cat > Dockerfile <<EOF
FROM --platform=linux/arm64 debian:bookworm-slim
ENV DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y --no-install-recommends ca-certificates curl procps libc6 libssl3 wget net-tools iproute2 && rm -rf /var/lib/apt/lists/*
ADD ${cli_url} /usr/local/bin/nexus-network
RUN chmod +x /usr/local/bin/nexus-network && ln -s /usr/local/bin/nexus-network /usr/local/bin/nexus-cli
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh
VOLUME /root/.nexus
ENTRYPOINT ["/entrypoint.sh"]
HEALTHCHECK --interval=1m --timeout=10s --retries=3 CMD pgrep -f 'nexus-network start --node-id' >/dev/null || exit 1
EOF

    # Entrypoint remains the same as v7, as the fix is now in the docker run command
    cat > entrypoint.sh <<'EOF'
#!/bin/bash
set -e
if [ "$1" = "nexus-cli" ] || [ "$1" = "nexus-network" ] || [ -x "$(command -v "$1")" ]; then
    exec "$@"
else
    if [ -z "$NODE_ID" ]; then
        echo "错误: 未设置NODE_ID环境变量用于启动节点!" >&2; exit 1
    fi
    echo ">>> 即将使用 --node-id 参数启动 Nexus 节点 $NODE_ID... <<<"
    exec nexus-network start --node-id "$NODE_ID"
fi
EOF

    print_info "正在为 arm64 平台构建全新镜像 '$IMAGE_NAME'...";
    if ! docker buildx build --platform linux/arm64 --builder "$BUILDER_NAME" -t "$IMAGE_NAME" . --load; then
      print_error "!! 镜像构建失败。"; exit 1;
    fi; print_success "镜像 '$IMAGE_NAME' 构建成功。"
}

check_and_initialize_config() {
    print_bold "零阶段: 检查并初始化核心配置"
    if [ -f "${HOST_CONFIG_DIR}/config.json" ]; then print_success "核心配置文件已存在。"; return 0; fi
    print_warning "未找到核心配置，即将开始自动注册..."; build_image
    print_info "使用钱包地址进行一次性用户注册..."; mkdir -p "$HOST_CONFIG_DIR"
    if ! docker run --rm --platform linux/arm64 -v "${HOST_CONFIG_DIR}:/root/.nexus" "${IMAGE_NAME}" \
      nexus-cli register-user --wallet-address "${WALLET_ADDRESS}"; then
        print_error "!! 用户注册失败！"; rm -rf "${HOST_CONFIG_DIR}"; exit 1
    fi; print_success "用户注册成功！"
}

run_container() {
    local node_id="$1"; [ -z "$node_id" ] && { print_error "ID不能为空"; return 1; };
    local cname="${BASE_CONTAINER_NAME}-${node_id}";

    if [ -f "${HOST_CONFIG_DIR}/config.json" ] && ! grep -q "\"id\": \"${node_id}\"" "${HOST_CONFIG_DIR}/config.json"; then
        print_warning "节点 ${node_id} 未在配置中注册，现在开始自动注册..."
        if ! docker run --rm -T --platform linux/arm64 -v "${HOST_CONFIG_DIR}:/root/.nexus" "${IMAGE_NAME}" \
          nexus-cli register-node --node-id "${node_id}"; then
            print_error "!! 节点 ${node_id} 自动注册失败！请检查上方日志。"; return 1
        fi
        print_success "节点 ${node_id} 注册成功！"
    fi

    if [ -n "$(docker ps -a -q -f name="^${cname}$")" ]; then docker stop "$cname" &>/dev/null || true; docker rm "$cname" &>/dev/null || true; fi
    
    local run_opts=""
    if [[ "$NODE_MEM_LIMIT" != "0" && -n "$NODE_MEM_LIMIT" ]]; then run_opts+=" --memory=${NODE_MEM_LIMIT}"; fi
    if [[ "$NODE_CPU_LIMIT" != "0" && -n "$NODE_CPU_LIMIT" ]]; then run_opts+=" --cpus=${NODE_CPU_LIMIT}"; fi
    
    print_info "正在启动节点 ${node_id} (CPU: ${NODE_CPU_LIMIT:-不限}, Mem: ${NODE_MEM_LIMIT:-不限})...";
    
    # 【ULTIMATE FIX】Add -T to disable pseudo-TTY allocation for the final run command
    if ! docker run -d -T --name "$cname" --platform linux/arm64 -e NODE_ID="$node_id" -v "${HOST_CONFIG_DIR}:/root/.nexus" $run_opts --restart unless-stopped "$IMAGE_NAME" &>/dev/null; then
        print_error "!! 容器 '${cname}' 启动失败。"; return 1
    fi
    print_info "等待容器稳定 (10秒)..." && safe_sleep 10
    if [ -n "$(docker ps -q -f name="^${cname}$")" ]; then print_success "节点 $node_id 启动成功。"; else
        print_error "!! 节点 $node_id 未能保持运行！"; print_warning "查看日志:"; docker logs "$cname";
    fi
}

# --- 菜单及其他函数保持不变 ---
list_nodes() { print_color "=============================== 当前 Nexus 节点状态 ===============================" "$COLOR_BLUE"; printf "%-38s %s\n" "$(print_bold "节点ID(容器名)")" "$(print_bold "状态")"; print_color "---------------------------------------------------------------------------------" "$COLOR_BLUE"; local nodes=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//" | sort -u); if [ -z "$nodes" ]; then print_warning "未找到任何 Nexus 节点。"; else for id in $nodes; do local cname="${BASE_CONTAINER_NAME}-${id}"; local raw_status=$(docker ps -a -f name="^${cname}$" --format "{{.Status}}"); local s_color="$COLOR_RED"; local status_text=""; if [[ "$raw_status" == *"Up"* ]]; then if [[ "$raw_status" == *"(healthy)"* ]]; then s_color="$COLOR_GREEN"; status_text="运行中 (健康)"; elif [[ "$raw_status" == *"(unhealthy)"* ]]; then s_color="$COLOR_RED"; status_text="运行中 (不健康!)"; elif [[ "$raw_status" == *"(health: starting)"* ]]; then s_color="$COLOR_YELLOW"; status_text="启动中 (检查..)"; else s_color="$COLOR_GREEN"; status_text="运行中"; fi; elif [[ "$raw_status" == *"Exited"* ]]; then s_color="$COLOR_YELLOW"; status_text="已退出"; elif [[ "$raw_status" == *"Restarting"* ]]; then s_color="$COLOR_RED"; status_text="重启循环!"; else status_text="$raw_status"; fi; printf "%-38s %s\n" "$id ($cname)" "$(print_color "$status_text" "$s_color")"; done; fi; print_color "=================================================================================" "$COLOR_BLUE"; }
menu_install_single() { read -rp "请输入要安装的新节点 ID: " id; id=$(echo "$id"|xargs); if [ -n "$id" ]; then run_container "$id"; else print_warning "ID 无效。"; fi; }
perform_node_action() { local action=$1; local node_id=$2; local cname="${BASE_CONTAINER_NAME}-${node_id}"; case $action in stop) print_info "正在停止节点 $node_id..."; docker stop "$cname" >/dev/null && print_success "已停止。" || print_error "停止失败。";; restart) print_info "正在重启节点 $node_id..."; docker restart "$cname" >/dev/null && print_success "已重启。" || print_error "重启失败。";; remove) if read -rp "${COLOR_YELLOW}【警告】确定要移除节点 '$node_id' 吗? (y/N): ${COLOR_RESET}" c && [[ "$c" =~ ^[yY]$ ]]; then print_info "正在移除节点 $node_id..."; docker stop "$cname" >/dev/null 2>&1 && docker rm "$cname" >/dev/null 2>&1 && print_success "已移除。" || print_error "移除失败。"; else print_warning "操作已取消。"; fi ;; logs) print_info "按 Ctrl+C 退出日志查看..."; safe_sleep 1; docker logs -f "$cname";; esac }
menu_manage_existing_nodes() { local nodes_arr=($(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//" | sort -u)); if [ ${#nodes_arr[@]} -eq 0 ]; then print_warning "无现有节点可管理。"; return; fi; while true; do clear; print_bold "--- 管理现有节点 ---"; local i=1; for n in "${nodes_arr[@]}"; do echo " ${i}) ${n}"; i=$((i+1)); done; echo " 0) 返回上级菜单"; read -rp "请选择要操作的节点: " choice; if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt "${#nodes_arr[@]}" ]; then print_error "无效输入!"; safe_sleep 1; continue; fi; [ "$choice" -eq 0 ] && break; local selected_node_id="${nodes_arr[$((choice-1))]}"; while true; do clear; print_bold "对节点 '$selected_node_id' 执行操作:"; echo " 1. 停止节点"; echo " 2. 重启节点"; echo " 3. 移除节点 (危险!)"; echo " 4. 查看日志"; echo " 0. 返回选择节点"; read -rp "请输入选项: " action_choice; case $action_choice in 1) perform_node_action stop "$selected_node_id"; press_any_key; break ;; 2) perform_node_action restart "$selected_node_id"; press_any_key; break ;; 3) perform_node_action remove "$selected_node_id"; press_any_key; return ;; 4) perform_node_action logs "$selected_node_id"; press_any_key; break ;; 0) break ;; *) print_error "无效选项。"; safe_sleep 1 ;; esac; done; done; }
perform_batch_action() { local action=$1; local containers=$(docker ps -a -q --filter "name=${BASE_CONTAINER_NAME}-"); if [ -z "$containers" ]; then print_warning "未找到任何节点容器。"; return; fi; print_info "正在对所有节点执行 '$action' 操作..."; if docker "$action" $containers >/dev/null 2>&1; then print_success "批量操作完成。"; else print_error "批量操作时发生错误。"; fi; }
menu_maintenance() { while true; do clear; print_bold "--- 系统与维护 ---"; echo " 1. 强制重构镜像"; echo " 2. 【危险】彻底清理所有数据"; echo " 0. 返回主菜单"; read -rp "请输入选项: " choice; case $choice in 1) build_image "--force"; press_any_key;; 2) if read -rp "${COLOR_YELLOW}【警告】将删除所有容器,镜像,buildx及配置! 确定? (y/N): ${COLOR_RESET}" c && [[ "$c" =~ ^[yY]$ ]]; then docker stop $(docker ps -a -q --filter "name=${BASE_CONTAINER_NAME}-") >/dev/null 2>&1 || true; docker rm -f $(docker ps -a -q --filter "name=${BASE_CONTAINER_NAME}-") >/dev/null 2>&1 || true; docker rmi -f $(docker images -q "nexus-node*") >/dev/null 2>&1 || true; docker buildx rm -f "$BUILDER_NAME" >/dev/null 2>&1 || true; rm -rf "$HOST_CONFIG_DIR"; print_success "彻底清理完成。脚本将退出，请重新运行。"; exit 0; fi;; 0) break;; *) print_error "无效选项。"; safe_sleep 1;; esac; done; }
main_menu() { if [ "$(id -u)" -ne 0 ]; then print_error "错误: 脚本需root权限。"; exit 1; fi; prepare_system; ensure_docker_ready; check_and_initialize_config; while true; do clear; print_color "===== Nexus 管理脚本 ${SCRIPT_VERSION} =====" "$COLOR_BLUE"; list_nodes; echo; print_info "--- 单节点管理 ---"; echo -e "  ${COLOR_YELLOW}1.${COLOR_RESET} 安装新节点"; echo -e "  ${COLOR_YELLOW}2.${COLOR_RESET} 管理现有节点 (停止/重启/移除/日志)"; print_info "--- 批量操作 ---"; echo -e "  ${COLOR_YELLOW}3.${COLOR_RESET} 启动所有节点   ${COLOR_YELLOW}4.${COLOR_RESET} 停止所有节点   ${COLOR_YELLOW}5.${COLOR_RESET} 重启所有节点"; print_info "--- 系统与维护 ---"; echo -e "  ${COLOR_YELLOW}8.${COLOR_RESET} 系统维护 (重构镜像/清理数据)"; echo -e "  ${COLOR_YELLOW}0.${COLOR_RESET} 退出脚本"; echo; read -rp "请输入选项: " choice; case $choice in 1) menu_install_single; press_any_key ;; 2) menu_manage_existing_nodes ;; 3) perform_batch_action start; press_any_key ;; 4) perform_batch_action stop; press_any_key ;; 5) perform_batch_action restart; press_any_key ;; 8) menu_maintenance ;; 0) break ;; *) print_error "无效选项。" && safe_sleep 1 ;; esac; done; }

# --- 脚本主入口 ---
if [[ "$1" == "--clean-first" ]]; then print_bold "执行首次彻底清理..."; docker stop $(docker ps -a -q --filter "name=nexus-node-") &>/dev/null || true; docker rm -f $(docker ps -a -q --filter "name=nexus-node-") &>/dev/null || true; docker rmi -f $(docker images -q "nexus-node*") &>/dev/null || true; docker buildx rm -f nexus_builder &>/dev/null || true; rm -rf "$HOST_CONFIG_DIR" &>/dev/null || true; print_success "首次清理完成。"; fi; main_menu
