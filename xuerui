#!/bin/bash
set -e

BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs"

# 定义默认的资源限制，可以在这里调整
DEFAULT_MEMORY_LIMIT="4g" # 每个节点默认使用 4GB 内存
DEFAULT_CPUS_LIMIT="2"    # 每个节点默认使用 2个 CPU 核心

# 检查 Docker 是否安装
function check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "检测到未安装 Docker，正在安装..."
        apt update
        apt install -y apt-transport-https ca-certificates curl software-properties-common
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
        add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
        apt update
        apt install -y docker-ce
        systemctl enable docker
        systemctl start docker
    fi
}

# 检查 Node.js/npm/pm2 是否安装
function check_pm2() {
    if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
        echo "检测到未安装 Node.js/npm，正在安装..."
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
        apt-get install -y nodejs
    fi
    if ! command -v pm2 >/dev/null 2>&1; then
        echo "检测到未安装 pm2，正在安装..."
        npm install -g pm2
    fi
}

# 构建docker镜像函数
function build_image() {
    WORKDIR=$(mktemp -d)
    cd "$WORKDIR"

    cat > Dockerfile <<EOF
FROM ubuntu:24.04

ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id

RUN apt-get update && apt-get install -y \
    curl \
    screen \
    bash \
    && rm -rf /var/lib/apt/lists/*

# 自动下载安装最新版 nexus-network
RUN curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh \
    && ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
EOF

    cat > entrypoint.sh <<EOF
#!/bin/bash
set -e

PROVER_ID_FILE="/root/.nexus/node-id"

if [ -z "\$NODE_ID" ]; then
    echo "错误：未设置 NODE_ID 环境变量"
    exit 1
fi

# 确保节点ID文件目录存在
mkdir -p "\$(dirname \$PROVER_ID_FILE)"

echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo "使用的 node-id: \$NODE_ID"

if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 未安装或不可用"
    exit 1
fi

screen -S nexus -X quit >/dev/null 2>&1 || true

echo "启动 nexus-network 节点..."
# 使用 exec 替换 shell 进程为 nexus-network，使其成为 PID 1
# 并使用 nohup 防止启动脚本结束时中断 nexus-network
# 同时设置 logger 以更好地管理日志（尽管此处直接输出到文件）
nohup nexus-network start --node-id "\$NODE_ID" &>> /root/nexus.log &

# 直接输出 tail 之前的命令，这样当容器启动后，用户就能看到启动信息
# 然后 tail 会接管标准输出
# 为了更好地处理 SIGTERM 等信号，可以在此处使用一个轻量级的 init 系统如 dumb-init
# 或者确保 nexus-network 的启动方式不会阻塞 ENTRYPOINT 退出。
# 目前直接 nohup & 是为了让 entrypoint 脚本可以立即结束，而 nexus-network 在后台运行
# 如果 Nexus 节点接收不到停止信号，这可能会导致容器僵尸
# 为了稳定性，我们暂且保持 nohup &，并观察其表现。

sleep 5 # 给予节点一些时间启动

# 检查 nexus-network 是否在运行，以及其状态
if pgrep nexus-network > /dev/null; then
    echo "节点已在后台启动。"
    echo "日志文件：/root/nexus.log"
    echo "可以使用 docker logs \$CONTAINER_NAME 查看日志"
else
    echo "节点启动失败，请检查 /root/nexus.log 文件。"
    cat /root/nexus.log
    exit 1
fi

# 使用 tail -f 保持容器运行，并输出日志
# 注意：tail -f 也可以作为容器的 ENTRYPOINT 主要命令
# 但为了打印启动信息，先让 entrypoint 执行，再由 tail -f 承接
tail -f /root/nexus.log
EOF

    echo "正在构建 Docker 镜像 '$IMAGE_NAME'..."
    docker build -t "$IMAGE_NAME" .

    cd -
    rm -rf "$WORKDIR"
    echo "Docker 镜像 '$IMAGE_NAME' 构建完成。"
}

# 启动容器（挂载宿主机日志文件）
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "--------------------------------------------------"
    echo "准备启动节点 $node_id (容器名: $container_name)"
    echo "日志文件将写入: $log_file"
    echo "内存限制: $DEFAULT_MEMORY_LIMIT"
    echo "CPU 限制: $DEFAULT_CPUS_LIMIT"
    echo "--------------------------------------------------"

    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "检测到旧容器 $container_name，先删除..."
        docker rm -f "$container_name"
    fi

    # 确保日志目录存在
    mkdir -p "$LOG_DIR"
    
    # 确保宿主机日志文件存在并有写权限
    if [ ! -f "$log_file" ]; then
        touch "$log_file"
        chmod 644 "$log_file"
        echo "已创建日志文件: $log_file"
    fi

    echo "启动容器 $container_name..."
    # 添加 --memory 和 --cpus 参数
    docker run -d --name "$container_name" \
        --memory "$DEFAULT_MEMORY_LIMIT" \
        --cpus "$DEFAULT_CPUS_LIMIT" \
        -v "$log_file":/root/nexus.log \
        -e NODE_ID="$node_id" \
        "$IMAGE_NAME"
        
    echo "容器 '$container_name' 已启动。"
}

# 停止并卸载容器和镜像、删除日志
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "正在停止并删除容器 '$container_name'..."
    # 即使容器不存在或已停止，也尝试删除以避免报错
    docker rm -f "$container_name" 2>/dev/null || echo "容器 '$container_name' 不存在或已停止."

    if [ -f "$log_file" ]; then
        echo "正在删除日志文件 '$log_file'..."
        rm -f "$log_file"
    else
        echo "日志文件 '$log_file' 不存在。"
    fi

    echo "节点 '$node_id' 已卸载完成。"
}

# 显示所有运行中的节点
function list_nodes() {
    echo "当前节点状态："
    echo "============================================================================================================================="
    # 修改了表头以包含内存限制和 CPU 限制
    printf "%-6s %-20s %-10s %-10s %-10s %-10s %-20s %-20s\n" "序号" "节点ID" "CPU使用率" "内存使用" "内存限制" "CPU限制" "状态" "启动时间"
    echo "============================================================================================================================="
    
    local all_nodes=($(get_all_nodes))
    local has_nodes=false # 标记是否有节点

    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前系统中没有运行 Nexus 节点。"
    else
        has_nodes=true
        for i in "${!all_nodes[@]}"; do
            local node_id=${all_nodes[$i]}
            local container_name="${BASE_CONTAINER_NAME}-${node_id}"
            
            # 默认值
            local cpu_usage_display="N/A"
            local mem_usage_display="N/A"
            local mem_limit_display="N/A"
            local cpu_limit_display="N/A"
            local container_status="未找到"
            local container_created_time="N/A"

            # 获取容器的状态和创建时间
            local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}")
            local created_time=$(docker ps -a --filter "name=$container_name" --format "{{.CreatedAt}}")
            if [ -n "$status" ]; then
                container_status="${status:-"未获取"}"
                container_created_time="${created_time:-"N/A"}"
            fi
            
            # 只处理已存在的容器 (无论是运行中还是已停止)
            if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
                # 获取容器的配置限制信息
                local container_inspect_data=$(docker inspect "$container_name" 2>/dev/null)
                
                if [ -n "$container_inspect_data" ]; then
                    # 解析内存限制
                    local mem_bytes=$(echo "$container_inspect_data" | jq '.[0].HostConfig.Memory')
                    if [ "$mem_bytes" -gt 0 ]; then
                        mem_limit_display=$(awk -v bytes="$mem_bytes" 'BEGIN{unit="B"; suffixes="KMGTPEZY"; printf "%.1f", bytes; for (i=0; bytes>=1024 && i<7; ++i) {bytes/=1024; printf "%.1f", bytes; suffix=substr(suffixes, i+1, 1); print suffix}; print ""}')
                    else
                        mem_limit_display="无限制"
                    fi

                    # 解析 CPU 限制 (NanoCPUs)
                    local nano_cpus=$(echo "$container_inspect_data" | jq '.[0].HostConfig.NanoCPUs')
                    if [ "$nano_cpus" -gt 0 ]; then
                        cpu_limit_display=$(awk -v nano="$nano_cpus" 'BEGIN { printf "%.2f", nano / 1e9 }')
                    else
                        cpu_limit_display="无限制"
                    fi
                fi
            
                # 如果容器是运行状态，获取实时的统计信息
                if [[ "$container_status" == Up* ]]; then
                    local docker_stats_output=$(docker stats --no-stream --format "{{.CPUPerc}},{{.MemUsage}}" "$container_name" 2>/dev/null)
                    if [ -n "$docker_stats_output" ]; then
                        IFS=',' read -r cpu_usage_display mem_usage_display <<< "$docker_stats_output"
                        mem_usage_display=$(echo "$mem_usage_display" | awk '{print $1}') # 取前缀部分，如 512.5M
                    else
                        mem_usage_display="未获取"
                    fi
                else # 如果容器已停止，则使用占位符
                    cpu_usage_display="-"
                    mem_usage_display="-"
                fi
            else # 容器可能已删除
                cpu_usage_display="-"
                mem_usage_display="-"
                container_status="不存在"
                container_created_time="N/A"
            fi
            
            # 显示节点信息
            printf "%-6d %-20s %-10s %-10s %-10s %-10s %-20s %-20s\n" \
                $((i+1)) \
                "$node_id" \
                "$cpu_usage_display" \
                "$mem_usage_display" \
                "$mem_limit_display" \
                "$cpu_limit_display" \
                "$(echo "$container_status" | cut -d' ' -f1)" \
                "$container_created_time"
        done
    fi
    
    echo "============================================================================================================================="
    echo "提示："
    echo "- CPU使用率：显示容器当前CPU使用百分比"
    echo "- 内存使用：显示容器当前使用的内存 (若已停止则为 '-')"
    echo "- 内存限制：为容器设置的内存上限 (来自docker run --memory)"
    echo "- CPU限制：为容器设置的CPU使用上限 (来自docker run --cpus)"
    echo "- 状态：显示容器的运行状态"
    echo "- 启动时间：显示容器的创建时间"
    read -p "按任意键返回菜单"
}

# 获取所有运行中的节点ID
function get_running_nodes() {
    docker ps --filter "name=${BASE_CONTAINER_NAME}" --filter "status=running" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 获取所有节点ID（包括已停止的）
function get_all_nodes() {
    # 获取所有包含BASE_CONTAINER_NAME名称的容器 (无论是运行中还是已停止)
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 查看节点日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    # 先检查容器是否存在，如果不存在，提示用户并返回
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "容器 '$container_name' 未找到。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "正在查看节点 '$node_id' 的日志，按 Ctrl+C 退出日志查看..."
    echo "请选择日志查看模式："
    echo "1. 原始日志（可能包含颜色代码）"
    echo "2. 清理后的日志（移除颜色代码）"
    read -rp "请选择(1-2): " log_mode

    # 使用 docker logs -f 命令
    if [ "$log_mode" = "2" ]; then
        # 尝试使用 `jq` 来更优雅地移除 ANSI 转义码，但为了兼容性，先用 sed
        # 如果你的系统没有 jq, 可以跳过 jq 的部分，仅保留 sed
        docker logs -f "$container_name" | sed -e 's/\x1b\[[0-9;]*m//g' -e 's/\x1b\[?25l//g' -e 's/\x1b\[?25h//g'
    else
        docker logs -f "$container_name"
    fi
}

# 批量启动多个节点
function batch_start_nodes() {
    echo "请输入多个 node-id，每行一个，输入空行结束："
    echo "（输入完成后按回车键，然后按 Ctrl+D 结束输入）"
    
    local node_ids=()
    while read -r line; do
        if [ -n "$line" ]; then
            node_ids+=("$line")
        fi
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 node-id，返回主菜单"
        read -p "按任意键继续"
        return
    fi

    echo "开始构建镜像..."
    build_image

    echo "开始启动节点..."
    for node_id in "${node_ids[@]}"; do
        echo "正在启动节点 '$node_id' ..."
        run_container "$node_id"
        sleep 2  # 添加短暂延迟，避免同时启动太多容器导致系统瞬间负载过高
    done

    echo "所有输入的节点启动完成！"
    read -p "按任意键返回菜单"
}

# 选择要查看的节点
function select_node_to_view() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有节点"
        read -p "按任意键返回菜单"
        return
    fi

    echo "请选择要查看的节点："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        # 使用docker ps -a 获取状态
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}" | tr '[:lower:]' '[:upper:]') # 转换为大写，方便匹配
        if [[ "$status" == "UP"* ]]; then
            echo "$((i+1)). 节点 $node_id [运行中]"
        elif [[ "$status" == "EXITED"* || "$status" == "CREATED"* ]]; then
             echo "$((i+1)). 节点 $node_id [已停止]"
        else # 可能不存在
             echo "$((i+1)). 节点 $node_id [不存在]"
        fi
    done

    read -rp "请输入选项(0-${#all_nodes[@]}): " choice

    if [ "$choice" = "0" ]; then
        return
    fi

    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
        local selected_node=${all_nodes[$((choice-1))]}
        view_node_logs "$selected_node"
    else
        echo "无效的选项"
        read -p "按任意键继续"
    fi
}

# 批量停止并卸载节点
function batch_uninstall_nodes() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有节点"
        read -p "按任意键返回菜单"
        return
    fi

    echo "当前节点状态："
    echo "----------------------------------------"
    echo "序号  节点ID                状态"
    echo "----------------------------------------"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}" | tr '[:lower:]' '[:upper:]') # 转换为大写，方便匹配
        if [[ "$status" == "UP"* ]]; then
            printf "%-6d %-20s [运行中]\n" $((i+1)) "$node_id"
        elif [[ "$status" == "EXITED"* || "$status" == "CREATED"* ]]; then
            printf "%-6d %-20s [已停止]\n" $((i+1)) "$node_id"
        else
             printf "%-6d %-20s [不存在]\n" $((i+1)) "$node_id"
        fi
    done
    echo "----------------------------------------"

    echo "请选择要删除的节点（输入数字，用空格分隔，如：1 3 5）："
    echo "0. 返回主菜单"
    
    read -rp "请输入选项: " choices

    if [ "$choices" = "0" ]; then
        return
    fi

    # 将输入的选项转换为数组
    read -ra selected_choices <<< "$choices"
    
    # 验证输入并执行卸载
    local uninstalled_count=0
    for choice in "${selected_choices[@]}"; do
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
            local selected_node=${all_nodes[$((choice-1))]}
            echo "正在卸载节点 '$selected_node' ..."
            uninstall_node "$selected_node"
            uninstalled_count=$((uninstalled_count + 1))
        else
            echo "警告: 跳过无效选项 '$choice'。"
        fi
    done

    if [ "$uninstalled_count" -gt 0 ]; then
        echo "已完成 ${uninstalled_count} 个节点的卸载。"
    else
        echo "未选择任何有效节点进行卸载。"
    fi
    read -p "按任意键返回菜单"
}

# 删除全部节点
function uninstall_all_nodes() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有节点"
        read -p "按任意键返回菜单"
        return
    fi

    echo "警告：此操作将删除所有节点的所有相关资源！"
    echo "当前共有 ${#all_nodes[@]} 个节点："
    for node_id in "${all_nodes[@]}"; do
        echo "- $node_id"
    done
    
    read -rp "确定要删除所有节点吗？(y/N): " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "已取消操作"
        read -p "按任意键返回菜单"
        return
    fi

    echo "开始删除所有节点..."
    for node_id in "${all_nodes[@]}"; do
        echo "正在卸载节点 '$node_id' ..."
        uninstall_node "$node_id"
    done

    echo "所有节点已删除完成！"
    read -p "按任意键返回菜单"
}

# 批量节点轮换启动
function batch_rotate_nodes() {
    check_pm2
    echo "请输入您想要进行轮换启动的节点 IDs，每行一个，输入空行结束："
    echo "（输入完成后按回车键，然后按 Ctrl+D 结束输入）"
    
    local node_ids=()
    while read -r line; do
        if [ -n "$line" ]; then
            node_ids+=("$line")
        fi
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 node-id，返回主菜单"
        read -p "按任意键继续"
        return
    fi

    # 设置每轮启动的节点数量
    read -rp "请输入每轮要启动的节点数量（默认值：当前总节点数的 1/3，向上取整，以降低单次压力）: " nodes_per_round
    if [ -z "$nodes_per_round" ]; then
        # 计算默认值，例如如果 total=10，则10/3取整为4
        nodes_per_round=$(( (${#node_ids[@]} + 2) / 3 )) 
        # 至少也要设置成 1
        if [ "$nodes_per_round" -lt 1 ]; then
            nodes_per_round=1
        fi
        echo "使用默认的每轮启动节点数量: $nodes_per_round"
    fi

    # 验证输入
    if ! [[ "$nodes_per_round" =~ ^[1-9][0-9]*$ ]] || [ "$nodes_per_round" -gt ${#node_ids[@]} ]; then
        echo "无效的节点数量。请输入一个介于 1 和 ${#node_ids[@]} 之间的正整数。"
        read -p "按任意键返回菜单"
        return
    fi

    # 计算需要多少批次来启动所有节点
    local total_nodes=${#node_ids[@]}
    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    echo "将 '$total_nodes' 个节点分为 '$num_groups' 批进行启动。"

    # 直接删除旧的轮换进程
    echo "停止并移除旧的轮换进程 'nexus-rotate' (如果存在)..."
    pm2 delete nexus-rotate 2>/dev/null || echo "没有找到旧的 'nexus-rotate' 进程。"

    echo "开始构建镜像..."
    build_image

    # 创建存放启动脚本的目录
    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir"
    # 清理旧的脚本
    rm -f "$script_dir"/*.sh

    # 为每批创建一个启动脚本
    echo "正在生成启动脚本..."
    for ((group=1; group<=num_groups; group++)); do
        cat > "$script_dir/start_group${group}.sh" <<EOF
#!/bin/bash
set -e

# 先停止并删除当前批次之前启动的所有 Nexus 节点容器
# 这是一种简单粗暴的方式，保证同一时间只运行一组节点
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 正在停止并删除所有已有的 nexus-node 容器..."
docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f 2>/dev/null || true
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Nexus node 容器清理完成。"

echo ""
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 开始启动第 ${group} 批节点..."
EOF
        # 根据批次和每批数量计算当前批次需要启动的节点
        local start_idx=$(( (group-1) * nodes_per_round ))
        local end_idx=$(( group * nodes_per_round ))
        if [ $end_idx -gt $total_nodes ]; then
            end_idx=$total_nodes
        fi

        for ((i=$start_idx; i<$end_idx; i++)); do
            local node_id=${node_ids[$i]}
            local container_name="${BASE_CONTAINER_NAME}-${node_id}"
            local log_file="${LOG_DIR}/nexus-${node_id}.log"
            
            # 确保日志目录和文件存在
            mkdir -p "$LOG_DIR"
            if [ ! -f "$log_file" ]; then
                touch "$log_file"
                chmod 644 "$log_file"
            fi

            echo "echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 启动节点 $node_id ...\"" >> "$script_dir/start_group${group}.sh"
            # 再次确认：在 run_container 函数中已经设置了资源限制，这里直接调用。
            # 注意：batch_rotate_nodes 直接执行启动逻辑，而不是调用 run_container
            echo "echo \"Starting container $container_name with memory $DEFAULT_MEMORY_LIMIT, cpus $DEFAULT_CPUS_LIMIT...\"" >> "$script_dir/start_group${group}.sh"
            echo "docker run -d --name $container_name --memory $DEFAULT_MEMORY_LIMIT --cpus $DEFAULT_CPUS_LIMIT -v $log_file:/root/nexus.log -e NODE_ID='$node_id' $IMAGE_NAME" >> "$script_dir/start_group${group}.sh"
            echo "sleep 30 # 等待节点启动并写入基本信息" >> "$script_dir/start_group${group}.sh"
        done
        echo "echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 第 ${group} 批节点启动完毕。\"" >> "$script_dir/start_group${group}.sh"
        echo "" >> "$script_dir/start_group${group}.sh"
    done

    # 创建一个主轮换脚本，按批次执行启动脚本
    cat > "$script_dir/rotate_manager.sh" <<EOF
#!/bin/bash
set -e

echo "开始 Nexus 节点轮换管理..."

TOTAL_NODES=${total_nodes}
NODES_PER_ROUND=${nodes_per_round}
NUM_GROUPS=${num_groups}
SCRIPT_DIR="/root/nexus_scripts"

# 使用一个简单的循环来管理轮换
echo "节点将分 ${NUM_GROUPS} 批启动，每批 ${NODES_PER_ROUND} 个节点 (每 ${NODES_PER_ROUND} 个节点之间间隔 2 小时)。"
echo "计划总耗时： approximately $(awk "BEGIN {printf \"%.1f\", ${num_groups} * 2}") 小时。"

for ((group=1; group<=NUM_GROUPS; group++)); do
    echo ""
    echo "############################################################"
    echo "###   开始执行第 ${group}/${NUM_GROUPS} 批节点启动   ###"
    echo "############################################################"
    bash "\${SCRIPT_DIR}/start_group\${group}.sh"
    echo ""
    
    # 除了最后一批，都需要等待2小时
    if [ "\$group" -lt "\$NUM_GROUPS" ]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 所有节点已启动完毕，等待 2 小时进入下一批次..."
        sleep 7200 # 2小时
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 所有批次的节点已启动完成！"
    fi
done

echo ""
echo "Nexus 节点轮换周期完成！正在重启脚本以进入下一轮循环..."
# 简单的循环，每轮结束后重新启动manager脚本（或者可以设置为持续运行）
# 如果要连续运行，可以简单地用 while true do ... done
# 考虑到脚本运行可能会中断，一个简单重开比无限循环更健壮

# 这里简单结束，由PM2来处理重启
exit 0
EOF
    
    chmod +x "$script_dir"/*.sh

    # 使用 pm2 启动主轮换脚本
    echo "使用 PM2 启动轮换管理脚本..."
    # pm2 run 使用 ./ 执行脚本，更加方便管理路径问题
    pm2 start --name "nexus-rotate" "$script_dir/rotate_manager.sh" --interpreter bash
    
    pm2 save # 保存 pm2 配置
    pm2 list # 显示 pm2 状态

    echo ""
    echo "Nexus 节点轮换启动流程已配置并启动！"
    echo "监控 PM2 状态: pm2 status"
    echo "查看轮换日志: pm2 logs nexus-rotate"
    echo "停止轮换: pm2 stop nexus-rotate && pm2 delete nexus-rotate"
    read -p "按任意键返回菜单"
}

# 设置定时清理日志任务（每2天清理一次，只保留最近2天的日志）
function setup_log_cleanup_cron() {
    # 确保 Cron Job 文件路径
    local CRON_FILE="/tmp/nexus_cron_jobs.$$"
    local cron_job="0 3 */2 * * find $LOG_DIR -type f -name 'nexus-*.log' -mtime +2 -delete"
    
    # 获取当前的 cron 配置
    (crontab -l 2>/dev/null > "$CRON_FILE") || { echo "Error: Could not get current crontab."; return 1; }
    
    # 检查是否存在相同的 cron 任务，如果不存在则添加
    if ! grep -Fq "$cron_job" "$CRON_FILE"; then
        echo "$cron_job" >> "$CRON_FILE"
        # 排序并写入新的 crontab
        crontab "$CRON_FILE"
        echo "已添加定时清理日志的任务：每2天在凌晨3点删除超过2天的 nexus*.log 文件。"
    else
        echo "定时清理日志的任务已存在，无需重复添加。"
    fi
    # 清理临时文件
    rm -f "$CRON_FILE"
}

# 主菜单
setup_log_cleanup_cron # 在脚本启动时就设置一次
while true; do
    clear
    echo "+++++++++++++++++++++++++++++++++++++++ 安装部署 Nexus 脚本 +++++++++++++++++++++++++++++++++++++++"
    echo "       作者: 哈哈哈哈 (推特 @ferdie_jhovie) | 本脚本免费开源，仅此唯一账号，谨防受骗"
    echo "========================================= Nexus 多节点管理 ========================================="
    echo "1. 安装并启动单个新节点"
    echo "2. 显示所有 Nexus 节点的状态 (资源占用、状态等)"
    echo "3. 批量停止并卸载指定节点"
    echo "4. 查看指定节点的运行日志"
    echo "5. 批量节点轮换启动 (自动按批次启动，每批之间间隔 2 小时)"
    echo "6. 删除当前系统中的所有 Nexus 节点"
    echo "7. 退出脚本"
    echo "======================================================================================================"

    read -rp "请输入您的选项(1-7): " choice

    case $choice in
        1)
            check_docker
            read -rp "请输入您的 node-id: " NODE_ID
            if [ -z "$NODE_ID" ]; then
                echo "错误：node-id 不能为空！请重新操作。"
                read -p "按任意键继续"
                continue
            fi
            # 每次启动新节点前都尝试重新构建镜像
            echo "准备启动节点 '$NODE_ID'..."
            build_image
            run_container "$NODE_ID"
            read -p "按任意键返回菜单"
            ;;
        2)
            list_nodes
            ;;
        3)
            batch_uninstall_nodes
            ;;
        4)
            select_node_to_view
            ;;
        5)
            check_docker
            batch_rotate_nodes
            ;;
        6)
            uninstall_all_nodes
            ;;
        7)
            echo "正在退出脚本..."
            exit 0
            ;;
        *)
            echo "无效选项，请重新输入。"
            read -p "按任意键继续"
            ;;
    esac
done
