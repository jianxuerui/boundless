#!/bin/bash
# 确保脚本在发生错误时立即退出
set -e

# ==============================================================================
# Nexus 多节点管理脚本 (ARM64专用Docker版)
# 作者: 哈哈哈哈 (推特 @ferdie_jhovie)
# 描述: 此脚本使用 Docker 来管理多个 Nexus 节点，特别为 ARM64 架构优化。
#
# 【V3 更新】: 修复了 "exec format error"，通过自动配置 Docker Buildx
# 来确保跨平台构建环境（QEMU）的正确设置。
# 【V3.1 更新】: 更新二进制文件下载地址至 v0.10.1。
# 【V3.2 社区修复版】:
#   - 修复了原始脚本的格式错误（断行、多余空格）。
#   - 修正了函数参数传递的严重bug (e.g., local node_id=$1)。
#   - 实现了 '批量卸载' 和 '卸载所有节点并删除镜像' 功能。
#   - 优化了菜单和用户交互逻辑。
# ==============================================================================

# --- 配置项 ---
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest-arm64"
LOG_DIR="/root/nexus_logs"
BUILDER_NAME="nexus_builder" # 为我们的项目创建一个专用的 builder

# --- 核心功能函数 ---

# 检查 Docker 是否安装
function check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "检测到未安装 Docker，正在为您安装..."
        apt-get update
        apt-get install -y apt-transport-https ca-certificates curl software-properties-common
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
        add-apt-repository "deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
        apt-get update
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        systemctl enable docker
        systemctl start docker
        echo "Docker 安装完成！"
    fi

    # 确保 buildx 插件可用
    if ! docker buildx version >/dev/null 2>&1; then
        echo "错误：未找到 Docker buildx 插件。请确保您的 Docker 版本包含 buildx。"
        echo "尝试安装命令: apt-get install docker-buildx-plugin"
        exit 1
    fi
}

# 【新增修复】设置 Buildx 以支持跨平台构建
function setup_buildx() {
    # 检查专用的 builder 是否已存在并正在运行
    if docker buildx ls | grep -q "^${BUILDER_NAME}.*running"; then
        echo "Buildx 环境 '$BUILDER_NAME' 已准备就绪。"
        docker buildx use $BUILDER_NAME
        return
    fi

    echo "检测到需要设置跨平台构建环境 (QEMU)..."
    echo "这可能是一次性的设置过程。"

    # 如果存在但未运行，则尝试启动
    if docker buildx ls | grep -q "$BUILDER_NAME"; then
        echo "正在启动已存在的 builder '$BUILDER_NAME'..."
        docker buildx inspect $BUILDER_NAME --bootstrap
    else
        # 创建新的 builder
        echo "正在创建新的 buildx builder '$BUILDER_NAME'..."
        docker buildx create --name $BUILDER_NAME --driver docker-container --use
    fi

    # 确保 QEMU binfmt handlers 已安装，这是解决 "exec format error" 的关键
    # 通过在一个特权容器中运行 binfmt 安装程序来完成
    if ! docker run --rm --privileged tonistiigi/binfmt | grep -q "setting up"; then
        echo "正在注册 QEMU 模拟器..."
        docker run --rm --privileged tonistiigi/binfmt --install all
        echo "QEMU 模拟器注册完成。"
    fi

    echo "Buildx 环境设置完成。"
}

# 构建 Docker 镜像
function build_image() {
    # 如果镜像已存在，则跳过构建
    if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        echo "镜像 $IMAGE_NAME 已存在，跳过构建。"
        return
    fi

    # 每次构建前都确保 buildx 环境就绪
    setup_buildx

    echo "正在准备构建环境..."
    WORKDIR=$(mktemp -d)
    cd "$WORKDIR"

    # --- Dockerfile 内容开始 ---
    cat > Dockerfile <<EOF
# 【修复】使用 ARG 来动态接收平台信息，避免 buildx 警告
ARG TARGETPLATFORM=linux/arm64
FROM --platform=\$TARGETPLATFORM ubuntu:24.04

# 设置环境变量，避免交互式提示
ENV DEBIAN_FRONTEND=noninteractive

# 更新并安装必要的工具。这一步之前会因 "exec format error" 失败
RUN apt-get update && apt-get install -y curl screen bash && rm -rf /var/lib/apt/lists/*

#直接从 GitHub Releases 下载指定版本 v0.10.1 的 ARM64 二进制文件。
RUN echo "正在下载 Nexus ARM64 二进制文件..." && \\
    curl -L -o /usr/local/bin/nexus-network https://github.com/nexus-xyz/nexus-cli/releases/download/v0.10.1/nexus-network-linux-arm64 && \\
    chmod +x /usr/local/bin/nexus-network

# 复制并设置入口点脚本
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# 设置容器启动时执行的命令
ENTRYPOINT ["/entrypoint.sh"]
EOF
    # --- Dockerfile 内容结束 ---

    # --- entrypoint.sh 内容开始 (保持不变) ---
    cat > entrypoint.sh <<'EOF'
#!/bin/bash
set -e

PROVER_ID_FILE="/root/.nexus/node-id"

if [ -z "$NODE_ID" ]; then
    echo "错误：未通过 -e NODE_ID=... 设置环境变量！"
    exit 1
fi

mkdir -p /root/.nexus
echo "$NODE_ID" > "$PROVER_ID_FILE"
echo "已将 Node ID 写入文件: $PROVER_ID_FILE"
echo "使用的 Node ID: $NODE_ID"

if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 命令未在 /usr/local/bin 中找到或不可执行。"
    exit 1
fi

# 确保旧的 screen 会话被清除
screen -S nexus -X quit >/dev/null 2>&1 || true

echo "正在启动 nexus-network 节点..."
screen -dmS nexus bash -c "nexus-network start --node-id $NODE_ID | tee /root/nexus.log"

sleep 3

if screen -list | grep -q "nexus"; then
    echo "节点已在后台 screen 会话中成功启动。"
    echo "容器内日志文件路径: /root/nexus.log"
    echo "您可以使用 'docker logs -f \$HOSTNAME' 实时查看日志"
else
    echo "错误：节点启动失败！请检查配置和网络。"
    if [ -f /root/nexus.log ]; then
        echo "--- 错误日志开始 ---"
        cat /root/nexus.log
        echo "--- 错误日志结束 ---"
    fi
    exit 1
fi

# 保持容器运行并输出日志
tail -f /root/nexus.log
EOF
    # --- entrypoint.sh 内容结束 ---

    echo "正在使用 builder '$BUILDER_NAME' 构建 Docker 镜像 $IMAGE_NAME..."
    # 使用 buildx 进行构建，确保平台正确性，并使用 --load 将镜像加载到本地 docker
    docker buildx build --builder "$BUILDER_NAME" --platform linux/arm64 -t "$IMAGE_NAME" . --load

    echo "清理构建目录..."
    cd - >/dev/null
    rm -rf "$WORKDIR"
    echo "镜像构建完成！"
}

# 启动一个节点容器
function run_container() {
    # 修复：正确接收函数参数
    local node_id="$1"
    if [ -z "$node_id" ]; then
        echo "错误：调用 run_container 时未提供 Node ID。"
        return 1
    fi
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "检测到旧容器 $container_name，正在删除..."
        docker rm -f "$container_name"
    fi

    mkdir -p "$LOG_DIR"
    touch "$log_file"
    chmod 644 "$log_file"

    echo "正在启动容器 $container_name..."
    docker run -d --name "$container_name" \
        -v "$log_file:/root/nexus.log" \
        -e NODE_ID="$node_id" \
        --restart unless-stopped \
        "$IMAGE_NAME"

    echo "容器 $container_name 已启动！"
    echo "宿主机日志文件位于: $log_file"
    echo "查看实时日志命令: tail -f $log_file  或者  docker logs -f $container_name"
}

# --- 辅助管理函数 ---

# 卸载指定节点
function uninstall_node() {
    # 修复：正确接收函数参数
    local node_id="$1"
    if [ -z "$node_id" ]; then
        echo "错误：调用 uninstall_node 时未提供 Node ID。"
        return 1
    fi
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "正在停止并删除容器 $container_name..."
    if docker rm -f "$container_name" >/dev/null 2>&1; then
        echo "容器 $container_name 已删除。"
    else
        echo "容器 $container_name 不存在或已删除。"
    fi

    if [ -f "$log_file" ]; then
        echo "正在删除日志文件 $log_file..."
        rm -f "$log_file"
    fi
    echo "节点 $node_id 的相关资源已卸载。"
}

# 列出所有节点状态
function list_nodes() {
    echo "--------------------------------- 当前 Nexus 节点状态 ---------------------------------"
    printf "%-30s %-12s %-15s %-20s\n" "节点 ID (容器名)" "状态" "CPU %" "内存使用"
    echo "-------------------------------------------------------------------------------------"
    
    # 修复：正确过滤容器名称
    containers=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}")

    if [ -z "$containers" ]; then
        echo "未找到任何 Nexus 节点容器。"
    else
        # 优化显示逻辑，避免多次调用 docker stats
        stats=$(docker stats --no-stream --filter "name=${BASE_CONTAINER_NAME}-" --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}")
        for name in $containers; do
            status_info=$(docker ps -a --filter "name=$name" --format "{{.Status}}")
            # 修复：正确提取 node_id
            node_id=$(echo "$name" | sed "s/${BASE_CONTAINER_NAME}-//")
            
            stats_line=$(echo "$stats" | grep -w "$name")
            if [ -n "$stats_line" ] && echo "$status_info" | grep -q "Up"; then
                cpu_perc=$(echo "$stats_line" | awk '{print $2}')
                mem_usage=$(echo "$stats_line" | awk -F '\t' '{print $3}')
                printf "%-30s %-12s %-15s %-20s\n" "$node_id ($name)" "Running" "$cpu_perc" "$mem_usage"
            else
                printf "%-30s %-12s %-15s %-20s\n" "$node_id ($name)" "Stopped" "N/A" "N/A"
            fi
        done
    fi
    echo "-------------------------------------------------------------------------------------"
}

# 获取所有节点的 ID 列表
function get_all_node_ids() {
    # 修复：正确的 sed 命令和过滤
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort -u
}

# 查看指定节点日志
function view_node_logs() {
    # 修复：正确接收函数参数
    local node_id="$1"
    if [ -z "$node_id" ]; then
        echo "错误：调用 view_node_logs 时未提供 Node ID。"
        return 1
    fi
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"

    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "错误：未找到节点 $node_id 的容器。"
        return 1
    fi

    echo "正在显示节点 '$node_id' 的日志... 按 Ctrl+C 退出。"
    sleep 1
    docker logs -f "$container_name"
}

# 批量启动节点
function batch_start_nodes() {
    build_image # 确保镜像存在
    echo "请输入多个 Node ID，每行一个。输入空行或按 Ctrl+D 结束："
    local node_ids=()
    while IFS= read -r line; do
        # 修复：正确处理输入
        line=$(echo "$line" | xargs) # Trim whitespace
        [ -z "$line" ] && break
        node_ids+=("$line")
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 Node ID，操作取消。"
        return
    fi

    echo "准备启动 ${#node_ids[@]} 个节点..."
    # 修复：正确的循环
    for node_id in "${node_ids[@]}"; do
        run_container "$node_id"
        sleep 1
    done

    echo "所有节点启动任务已提交！"
}

# 选择一个节点执行特定操作
function select_node_for_action() {
    # 修复：正确接收函数参数
    local action_callback="$1"
    local prompt_message="$2"
    local all_nodes=($(get_all_node_ids))

    # 修复：正确的数组空值检查
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有任何节点可供操作。"
        read -p "按任意键返回..."
        return
    fi
    
    echo "请选择一个要'${prompt_message}'的节点："
    echo "0. 返回主菜单"
    # 修复：正确的 for 循环和变量使用
    for i in "${!all_nodes[@]}"; do
        local node_id="${all_nodes[$i]}"
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}")
        printf "%2d. 节点 %-25s [%s]\n" "$((i+1))" "$node_id" "$status"
    done

    read -rp "请输入选项(0-${#all_nodes[@]}): " choice

    # 修复：更健壮的输入验证
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt ${#all_nodes[@]} ]; then
        echo "无效输入，请输入数字 0 到 ${#all_nodes[@]} 之间的数字。"
        sleep 2
        return
    fi
    
    [ "$choice" -eq 0 ] && return
    
    local selected_node_id="${all_nodes[$((choice-1))]}"
    
    # 修复：正确调用回调函数
    "$action_callback" "$selected_node_id"
}

# 【新功能】批量卸载节点
function batch_uninstall_nodes() {
    echo "将卸载所有当前管理的节点，但会保留Docker镜像。"
    read -rp "您确定要继续吗? (y/N): " confirm
    if [[ ! "$confirm" =~ ^[yY]([eE][sS])?$ ]]; then
        echo "操作已取消。"
        return
    fi
    
    local all_nodes=($(get_all_node_ids))
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "没有找到任何节点，无需卸载。"
        return
    fi
    
    echo "正在卸载 ${#all_nodes[@]} 个节点..."
    for node_id in "${all_nodes[@]}"; do
        uninstall_node "$node_id"
    done
    echo "所有节点已卸载完成。"
}

# 【新功能】卸载所有节点并删除镜像
function uninstall_all_nodes_and_image() {
    echo "!!! 警告：此操作将永久删除所有节点容器、日志和Nexus Docker镜像 !!!"
    read -rp "此操作不可逆，请再次确认 (输入 'yes' 继续): " confirm
    if [ "$confirm" != "yes" ]; then
        echo "操作已取消。"
        return
    fi
    
    echo "--- 第一步：卸载所有节点 ---"
    batch_uninstall_nodes # 调用批量卸载函数
    
    echo "--- 第二步：删除 Docker 镜像 ---"
    if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        echo "正在删除镜像 $IMAGE_NAME..."
        docker rmi -f "$IMAGE_NAME"
        echo "镜像已删除。"
    else
        echo "镜像 $IMAGE_NAME 不存在，跳过删除。"
    fi
    
    echo "--- 第三步：(可选) 删除日志目录 ---"
    if [ -d "$LOG_DIR" ]; then
        read -rp "是否要删除宿主机上的总日志目录 '$LOG_DIR'? (y/N): " del_log_dir
        if [[ "$del_log_dir" =~ ^[yY] ]]; then
            rm -rf "$LOG_DIR"
            echo "日志目录 '$LOG_DIR' 已删除。"
        fi
    fi
    
    echo "完全卸载操作完成。"
}


# --- 主菜单循环 ---
function main_menu() {
    while true; do
        clear
        echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
        echo "================ Nexus 多节点管理 (ARM64 Docker版) v3.2 ================"
        echo "1. 安装/启动单个节点"
        echo "2. 批量安装/启动多个节点"
        echo "3. 查看指定节点日志"
        echo "4. 卸载指定节点"
        echo "5. 批量卸载所有节点 (保留镜像)"
        echo "6. 完全卸载 (删除所有节点和镜像)"
        echo "7. 退出脚本"
        echo "==================================================================="
        list_nodes

        read -rp "请输入选项(1-7): " choice

        case $choice in
            1)
                read -rp "请输入您的 Node ID: " NODE_ID
                if [ -z "$NODE_ID" ]; then
                    echo "Node ID 不能为空！"
                else
                    build_image
                    run_container "$NODE_ID"
                fi
                read -p "操作完成，按任意键返回菜单..."
                ;;
            2)
                batch_start_nodes
                read -p "操作完成，按任意键返回菜单..."
                ;;
            3)
                select_node_for_action "view_node_logs" "查看日志"
                ;;
            4)
                select_node_for_action "uninstall_node" "卸载"
                read -p "操作完成，按任意键返回..."
                ;;
            5)
                batch_uninstall_nodes
                read -p "操作完成，按任意键返回..."
                ;;
            6)
                uninstall_all_nodes_and_image
                read -p "操作完成，按任意键返回..."
                ;;
            7)
                echo "退出脚本。"
                exit 0
                ;;
            *)
                echo "无效选项，请重新输入。"
                sleep 1
                ;;
        esac
    done
}

# --- 脚本执行入口 ---
check_docker
main_menu
