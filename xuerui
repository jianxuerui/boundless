#!/bin/bash
# 作者: 哈哈哈哈 (推特 @ferdie_jhovie) | 本脚本免费开源，仅此唯一账号，谨防受骗
# 脚本目标: 管理 Nexus 节点，实现一键安装、启动、停止、日志查看、批量轮换等功能。
# 重要提示: 请确保您运行脚本的机器拥有足够的资源 (CPU/内存) 来运行节点。
#             对于单个节点，建议至少分配 2-4GB 内存。
# 重要风险: 本脚本包含了尝试自动安装 Docker 和 Node.js/PM2 的功能。若您所处环境无法自动安装，
#            可能会导致脚本失败或出现预期外的行为。请谨慎执行。

set -e # 脚本遇到非零退出码时立即退出

BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs"     # 宿主机上的 Nexus 日志存储目录
SCRIPT_DIR="/root/nexus_scripts" # 存放轮换脚本的目录

# !!! 定义默认的节点资源限制 !!!
# 根据您的服务器硬件配置和希望同时运行的节点数量来调整这些值。
# 如果服务器内存不足，应减小 MEMORY_LIMIT 或减少运行的节点数量。
DEFAULT_MEMORY_LIMIT="4g" # 每个节点最多可使用 4GB 内存
DEFAULT_CPUS_LIMIT="2"    # 每个节点最多使用 2 个 CPU 核心 (例如 2.0 表示 2个核心)

# --- 辅助函数 ---

# 检查是否是 root 用户或拥有 sudo 权限
# 返回 0 表示是 root 或有 sudo 权限，返回 1 表示都不是
function is_root_or_sudo_available() {
    if [[ "$EUID" -ne 0 ]]; then
        # 尝试使用 sudo -v 来检测是否有 sudo 权限 (不需要密码)
        if command -v sudo &> /dev/null && sudo -v &> /dev/null; then
            return 0 # 可以使用 sudo
        else
            return 1 # 既不是 root 也不能使用 sudo
        fi
    fi
    return 0 # 本身就是 root
}

# 获取 sudo 命令前缀，如果当前用户不是 root 且有 sudo 权限，则返回 "sudo"
# 否则返回空字符串
function get_sudo_prefix() {
    if [[ "$EUID" -ne 0 ]]; then
        if is_root_or_sudo_available; then
            echo "sudo"
        else
            echo ""
        fi
    else
        echo ""
    fi
}
# 全局设置 SUDO 变量，确保所有需要权限的命令都带上正确的 SUDO 前缀
SUDO=$(get_sudo_prefix)

# 检测当前系统的包管理器
function get_package_manager() {
    if command -v apt &> /dev/null; then
        echo "apt"
    elif command -v yum &> /dev/null; then
        echo "yum"
    elif command -v dnf &> /dev/null; then
        echo "dnf"
    elif command -v apk &> /dev/null; then
        echo "apk"
    else
        echo "unknown"
    fi
}

# 尝试安装包的通用函数
function install_package() {
    local pkgs="$@" # 支持同时安装多个包，例如 "nodejs npm"
    local pm=$(get_package_manager)

    echo "正在尝试安装 '$pkgs'..."
    if ! is_root_or_sudo_available; then
        echo "错误: 安装 '$pkgs' 需要 root 权限或 sudo。请以 root 用户或使用 sudo 执行此命令。"
        return 1
    fi

    case "$pm" in
        apt)
            $SUDO apt update && $SUDO apt install -y "$pkgs"
            ;;
        yum)
            $SUDO yum install -y "$pkgs"
            ;;
        dnf)
            $SUDO dnf install -y "$pkgs"
            ;;
        apk)
            $SUDO apk add "$pkgs"
            ;;
        *)
            echo "错误: 未知或不支持的包管理器 '$pm'。请手动安装 '$pkgs'。"
            return 1
            ;;
    esac
    return $? # 返回 install_package 命令的退出状态
}

# 确保必要的系统工具已安装
function ensure_package_installed() {
    local pkg_name="$1" # 包的名称
    local command_to_check="${2:-$pkg_name}" # 默认为 pkg_name，可选指定检查的命令名

    if ! command -v "$command_to_check" &> /dev/null; then
        echo "必需的命令 '$command_to_check' 未找到。尝试安装 '$pkg_name'..."
        if ! install_package "$pkg_name"; then
            echo "错误：无法自动安装 '$pkg_name'。请手动安装 '$pkg_name' 后重试。"
            echo "您可以使用 '$SUDO apt install $pkg_name' (Debian/Ubuntu), '$SUDO yum install $pkg_name' (CentOS/RHEL), 或 '$SUDO dnf install $pkg_name' (Fedora) 等。"
            exit 1 # 硬停止，因为是关键依赖
        fi
        echo "'$command_to_check' 已成功安装。"
    fi
}

# 检查 Docker 命令是否存在以及服务是否运行
function check_docker() {
    echo "--- 检查 Docker 服务状态 ---"
    # 1. 检查 Docker 命令是否存在
    if ! command -v docker &> /dev/null; then
        echo "错误：未检测到 Docker 命令。请先安装 Docker。"
        echo "您可以尝试运行以下官方脚本来安装 Docker (适用于大多数 Linux 发行版):"
        echo "  ${SUDO} curl -fsSL https://get.docker.com -o get-docker.sh"
        echo "  ${SUDO} sh get-docker.sh --dry-run # 建议先 dry-run 检查兼容性"
        echo "  ${SUDO} sh get-docker.sh"
        echo "安装完成后，请确保将当前用户添加到 docker 组，并重新登录： ${SUDO} usermod -aG docker \$USER"
        echo "然后确保 Docker 服务已启用并正在运行："
        echo "  ${SUDO} systemctl enable docker"
        echo "  ${SUDO} systemctl start docker"
        return 1 # 返回错误码，表示 Docker 未就绪
    fi
    
    # Docker 命令存在，现在检查服务是否运行
    if ! ${SUDO} systemctl is-active --quiet docker; then
        echo "错误：Docker 服务未运行。正在尝试启动..."
        if ${SUDO} systemctl start docker; then
            echo "Docker 服务已尝试启动。等待 5 秒..."
            sleep 5 
            if ! ${SUDO} systemctl is-active --quiet docker; then
                echo "错误：未能成功启动 Docker 服务。请手动检查 '${SUDO} systemctl status docker'。"
                return 1 # 失败
            else
                echo "Docker 服务已成功启动。"
                return 0 # 成功
            fi
        else
            echo "错误：Docker 服务的启动命令执行失败。请手动检查 '${SUDO} systemctl status docker'。"
            return 1
        fi
    fi
    # Docker 已安装且正在运行
    echo "Docker 服务正在运行。"
    return 0 # 成功
}

# 检查 Node.js/npm/pm2 是否安装 (仅为批次轮换准备)
function check_pm2() {
    echo "--- 检查 PM2 及其依赖 (Node.js/npm) ---"
    local pm=$(get_package_manager)

    # 确保 curl 和 gnupg 安装（NodeSource 脚本需要）
    if [[ "$pm" == "apt" ]]; then
        ensure_package_installed "curl"
        ensure_package_installed "gnupg"
    fi

    # 检查 Node.js 和 npm
    if ! command -v node &> /dev/null || ! command -v npm &> /dev/null; then
        echo "错误：未检测到 Node.js/npm。尝试安装..."
        case "$pm" in
            apt)
                echo "您的系统使用 apt，尝试自动安装 Node.js 18..."
                # NodeSource 脚本用于添加最新 Node.js 源
                if ! ${SUDO} curl -fsSL https://deb.nodesource.com/setup_18.x | ${SUDO} bash - ; then
                     echo "错误: 尝试下载并执行 NodeSource 设置脚本失败。可能是 curl 或 bash 环境问题，或网络问题。"
                     return 1
                fi
                if ! install_package nodejs; then
                    echo "错误：使用 '$pm' 安装 Node.js 失败。请手动安装 Node.js。"
                    return 1
                fi
                ;;
            yum|dnf)
                echo "您的系统使用 $pm，尝试安装 Node.js..."
                # 尝试安装 EPEL (Extra Packages for Enterprise Linux)
                if ! ${SUDO} rpm -q epel-release &> /dev/null; then
                    echo "尝试安装 EPEL 仓库..."
                    if [[ "$pm" == "yum" ]]; then
                        ${SUDO} yum install -y epel-release
                    elif [[ "$pm" == "dnf" ]]; then
                        ${SUDO} dnf install -y epel-release
                    fi
                fi
                if ! install_package nodejs; then # 通常 yum/dnf 的 nodejs 包会包含 npm
                    echo "错误：使用 '$pm' 安装 Node.js 失败。请手动安装 Node.js。"
                    return 1
                fi
                ;;
            apk)
                echo "您的系统使用 apk，尝试安装 Node.js..."
                if ! install_package nodejs npm; then # Alpine Linux nodejs 包名通常就是 nodejs
                    echo "错误：使用 '$pm' 安装 Node.js 失败。请手动安装 Node.js。"
                    return 1
                fi
                ;;
            *)
                echo "警告：Node.js/npm 未找到。由于您的系统可能不被自动支持，无法自动安装 Node.js。"
                echo "请手动安装 Node.js (例如使用 nvm 或下载二进制包)。如果手动安装后仍无法找到命令，pm2 功能将不可用。"
                return 1 # 返回失败，因为 PM2 功能对轮换启动是必需的
                ;;
        esac
        
        # 再次检查，确保 Node.js 和 npm 确实被安装了
        if ! command -v node &> /dev/null || ! command -v npm &> /dev/null; then
             echo "错误：Node.js/npm 安装或配置失败，pm2 功能将不可用。"
             return 1 # 表示安装失败
        fi
        echo "Node.js 和 npm 安装完成。"
    fi
    
    # 检查 pm2
    if ! command -v pm2 &> /dev/null; then
        echo "错误：未检测到 pm2。正在安装..."
        # pm2 是通过 npm 安装的
        if ! ${SUDO} npm install -g pm2; then # 使用 sudo 安装全局包
            echo "错误：使用 npm 安装 pm2 失败。请确保 npm 有足够的权限，或者尝试手动运行 '${SUDO} npm install -g pm2'。"
            return 1 # 表示安装失败
        fi
        echo "pm2 安装完成。"
    fi
    echo "PM2 及其依赖检查通过。"
    return 0 # 表示检查通过
}

# 构建 Docker 镜像函数
function build_image() {
    echo "======================================"
    echo " 开始构建 Docker 镜像 '$IMAGE_NAME'..."
    echo "======================================"
    
    if ! check_docker; then
        echo "Docker 环境未就绪，无法构建镜像。"
        return 1
    fi
    ensure_package_installed "jq" # Ensure jq for the Dockerfile base

    # 创建一个临时目录用于构建
    WORKDIR=$(mktemp -d)
    if [ ! -d "$WORKDIR" ]; then
        echo "错误：无法创建临时目录用于 Docker 构建。"
        return 1
    fi
    # 确保临时目录可写
    ${SUDO} chmod 755 "$WORKDIR" # Ensure sudo user can write

    cd "$WORKDIR"

    # 创建 Dockerfile
    cat > Dockerfile <<EOF
FROM ubuntu:24.04

LABEL maintainer="哈哈哈哈 <ferdie_jhovie@example.com>"
LABEL description="Nexus Node Image"

# 设置非交互模式，防止 apt 命令弹出确认对话框
ENV DEBIAN_FRONTEND=noninteractive
# 节点ID由 Docker 运行时注入
ENV NODE_ID="" 
ENV PROVER_ID_FILE="/root/.nexus/node-id"

# 安装基本工具和 Nexus 运行所需的环境
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    screen \
    bash \
    jq \
    && rm -rf /var/lib/apt/lists/* \
    && echo "Base image updated and essentials installed."

# 自动下载并安装最新版 nexus-network
# 使用 NONINTERACTIVE=1 sh 来确保安装过程是非交互式的
RUN echo "Downloading and installing the latest nexus-network..." && \
    curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh && \
    echo "nexus-network installation complete." && \
    # 创建软链接到常用PATH中，方便容器内直接调用
    ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network

# 复制启动脚本到容器内
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# 设置容器启动时执行的命令
ENTRYPOINT ["/entrypoint.sh"]
EOF

    # 创建 entrypoint.sh
    cat > entrypoint.sh <<EOF
#!/bin/bash
set -e # 脚本遇到非零退出码时立即退出

PROVER_ID_FILE="/root/.nexus/node-id"
NEXUS_LOG="/root/nexus.log"

# 检查NODE_ID环境变量是否已设置
if [ -z "\$NODE_ID" ]; then
    echo "错误：未设置 NODE_ID 环境变量。节点无法启动。"
    exit 1
fi

# 确保节点ID文件目录存在
mkdir -p "\$(dirname \$PROVER_ID_FILE)"
echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo "Nexus Node ID set to: \$NODE_ID"
echo "Prover ID file created at: \$PROVER_ID_FILE"

# 检查 nexus-network 是否已安装
if ! command -v nexus-network &> /dev/null; then
    echo "错误：nexus-network 未安装或无法在 PATH 中找到。请检查 Dockerfile 的安装步骤。"
    exit 1
fi

# 启动 Nexus Network
echo "Starting Nexus Network with Node ID: \$NODE_ID..."

# 使用 nohup 运行，输出重定向到日志文件，并将其放到后台
nohup nexus-network start --node-id "\$NODE_ID" &>> "\$NEXUS_LOG" &

# 轮询检查 nexus-network 是否在运行，并给其一定初始化时间
echo "Waiting for Nexus Network to initialize (up to 20 seconds)..."
INIT_COUNTER=0
MAX_INIT_TIME=20 # 增加等待时间以应对较慢的初始化
IS_RUNNING=false

while [ "\$INIT_COUNTER" -lt "\$MAX_INIT_TIME" ]; do
    # 检查 nexus-network 进程是否存在，以及日志文件是否开始有内容写入
    if pgrep nexus-network > /dev/null && [ -s "\$NEXUS_LOG" ]; then
        IS_RUNNING=true
        break
    fi
    sleep 1
    INIT_COUNTER=\$((INIT_COUNTER + 1))
done

if [ "\$IS_RUNNING" = "true" ]; then
    echo "Nexus Network started successfully."
    echo "Log file: \$NEXUS_LOG"
    # 使用 tail -f 保持容器运行，并将 nexus.log 的后续内容输出到 stdout (容器日志)
    tail -f "\$NEXUS_LOG"
else
    echo "错误：Nexus Network 未能成功启动。"
    echo "请检查日志文件 '\$NEXUS_LOG' 以获取详细信息："
    cat "\$NEXUS_LOG" # 输出部分或全部日志内容以帮助调试
    exit 1
fi
EOF

    echo "正在执行 Docker 镜像构建，这可能需要一些时间..."
    # 执行 Docker 构建
    if ! ${SUDO} docker build -t "$IMAGE_NAME" . --progress=plain; then # --progress=plain 使得构建过程日志更详细
        echo "错误：Docker 镜像构建失败。请检查 Dockerfile 和构建输出。"
        cd - > /dev/null # 返回之前目录
        ${SUDO} rm -rf "$WORKDIR"
        return 1
    fi
    
    # 返回上一级目录并清理临时文件
    cd - > /dev/null
    ${SUDO} rm -rf "$WORKDIR"
    echo "======================================"
    echo " Docker 镜像 '$IMAGE_NAME' 构建完成。"
    echo "======================================"
    return 0
}

# 启动单个 Nexus 容器函数
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo ""
    echo "--- 启动节点: $node_id ---"
    echo "    容器名: $container_name"
    echo "    日志文件: $log_file"
    echo "    内存限制: $DEFAULT_MEMORY_LIMIT"
    echo "    CPU 限制: $DEFAULT_CPUS_LIMIT"
    echo "----------------------------"

    if ! check_docker; then
        echo "Docker 环境未就绪，无法启动容器。"
        return 1
    fi

    # 检查是否已存在同名容器，如果有，先删除
    if ${SUDO} docker ps -a --format '{{.Names}}' | grep -q "^${container_name}$"; then
        echo "发现同名容器 '$container_name'。正在尝试删除旧容器..."
        ${SUDO} docker rm -f "${container_name}" > /dev/null 2>&1 || echo "警告: 删除旧容器 '$container_name' 失败，可能需要手动介入。"
    fi

    # 确保日志目录存在并可写
    ${SUDO} mkdir -p "$LOG_DIR"
    if [ ! -d "$LOG_DIR" ]; then
        echo "错误：无法创建宿主机上的日志目录 '$LOG_DIR'。"
        return 1
    fi
    
    # 确保宿主机日志文件存在且可写，并设置正确的权限
    if [ ! -f "$log_file" ]; then
        ${SUDO} touch "$log_file"
        ${SUDO} chmod 644 "$log_file" # 设置日志文件的读写权限
        if [ "$EUID" -ne 0 ]; then
          ${SUDO} chown $(whoami):$(whoami) "$log_file" # 确保所有者是当前用户
        fi
        echo "已创建日志文件: $log_file"
    fi
    # 再次确保权限和所有者，以防万一
    ${SUDO} chmod 644 "$log_file"
    if [ "$EUID" -ne 0 ]; then
      ${SUDO} chown $(whoami):$(whoami) "$log_file" # 明确指定用户和组
    fi

    echo "正在使用镜像 '$IMAGE_NAME' 启动新容器 '$container_name'..."
    
    # 启动容器，设置名称、内存限制、CPU限制、挂载日志文件、传递 NODE_ID
    if ! ${SUDO} docker run -d \
            --name "${container_name}" \
            --memory "${DEFAULT_MEMORY_LIMIT}" \
            --cpus "${DEFAULT_CPUS_LIMIT}" \
            -v "${log_file}":"/root/nexus.log" \
            -e NODE_ID="${node_id}" \
            "${IMAGE_NAME}" > /dev/null; then
        echo "错误：启动容器 '$container_name' 失败！"
        echo "请检查以下信息:"
        echo "  - Docker 容器日志: '${SUDO} docker logs $container_name'"
        echo "  - Nexus 节点日志文件 (宿主机): '$log_file'"
        echo "  - Docker 服务状态: '${SUDO} systemctl status docker'"
        return 1
    fi
    
    echo "容器 '$container_name' 已成功启动。"
    # 通过 docker inspect 获取启动后的 PID (如果有)
    local container_pid=$(${SUDO} docker inspect -f '{{.State.Pid}}' "$container_name" 2>/dev/null || echo "N/A")
    echo "    容器 PID: $container_pid"
    return 0
}

# 停止并卸载单个 Nexus 容器及相关资源
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo ""
    echo "--- 卸载节点: $node_id ---"
    
    if ! check_docker &> /dev/null; then # 静默检查 Docker，如果失败则输出信息并返回
        echo "Docker 命令不可用，无法卸载节点。"
        return 1
    fi
    
    # 停止并删除容器
    echo "    正在停止并删除容器 '$container_name'..."
    if ${SUDO} docker ps -q -f name=${container_name} &> /dev/null; then
        # 如果容器正在运行，则先停止
        ${SUDO} docker stop "${container_name}" > /dev/null 2>&1 || echo "    警告: 尝试停止容器 '$container_name' 但可能已停止或执行命令失败。"
    fi
    
    # 删除容器，即使不存在或已停止，执行命令也能安全处理
    ${SUDO} docker rm "${container_name}" > /dev/null 2>&1 || echo "    警告: 尝试删除容器 '$container_name' 但可能不存在或已删除。"

    # 删除对应的日志文件
    if [ -f "$log_file" ]; then
        echo "    正在删除日志文件 '$log_file'..."
        ${SUDO} rm -f "$log_file"
    else
        echo "    日志文件 '$log_file' 不存在，跳过删除。"
    fi
    echo "    节点 '$node_id' (容器 '$container_name') 卸载完成。"
    return 0
}

# 显示所有已部署 Nexus 节点的状态
function list_nodes() {
    echo ""
    echo "========================= Nexus 节点状态列表 =========================="
    # 表头：序号, 节点ID, CPU使用率, 内存使用, 内存限制, CPU限制, 状态, 创建时间
    printf "%-6s %-20s %-10s %-12s %-12s %-10s %-15s %-20s\n" "序号" "节点ID" "CPU%" "内存使用" "内存限制" "CPU核数" "状态" "创建时间"
    echo "--------------------------------------------------------------------------"
    
    if ! check_docker; then
        echo "Docker 环境未就绪，无法显示节点状态。"
        return 1
    fi
    ensure_package_installed "jq" # 确保宿主机安装了 jq

    # 获取所有匹配 BASE_CONTAINER_NAME 的容器ID，无论其状态如何
    local container_names=($(${SUDO} docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}"))
    
    if [ ${#container_names[@]} -eq 0 ]; then
        echo "当前系统中没有部署 Nexus 节点。"
    else
        local node_index=0
        for container_name in "${container_names[@]}"; do
            # 从容器名提取节点 ID
            local node_id="${container_name#${BASE_CONTAINER_NAME}-}"
            
            # 初始化显示变量为占位符
            local cpu_usage_display="-"
            local mem_usage_display="-"
            local mem_limit_display="-"
            local cpu_limit_display="-"
            local container_status="未知"
            local container_created_time="N/A"

            # 1. 获取容器基本信息: 状态, 创建时间
            local status_and_time=$(${SUDO} docker ps -a --filter "name=${container_name}" --format "{{.Status}}|{{.CreatedAt}}" 2>/dev/null)
            if [ -n "$status_and_time" ]; then
                container_status=$(echo "$status_and_time" | cut -d'|' -f1 | awk '{print $1}') # 只取状态的首个单词
                container_created_time=$(echo "$status_and_time" | cut -d'|' -f2)
            fi

            # 2. 获取容器资源限制信息 (来自 Docker Inspect)
            local inspect_data=$(${SUDO} docker inspect "${container_name}" 2>/dev/null)
            if [ -n "$inspect_data" ] && [[ "$inspect_data" =~ ^\[.*\]$ ]] && [ "$inspect_data" != "[]" ]; then
                local mem_bytes_raw=$(echo "$inspect_data" | jq -r '.[0].HostConfig.Memory')
                if [[ "$mem_bytes_raw" =~ ^[0-9]+$ ]] && [ "$mem_bytes_raw" -gt 0 ]; then
                    mem_limit_display=$(awk -v bytes="$mem_bytes_raw" 'BEGIN {
                        suffixes="KMGTPEZY";
                        num = bytes;
                        unit = "B";
                        for (i=0; num >= 1024 && i<length(suffixes); ++i) {
                            num /= 1024;
                            unit = substr(suffixes, i+1, 1);
                        }
                        printf "%.1f%s", num, unit;
                    }')
                else
                    mem_limit_display="无限制"
                fi

                local nano_cpus_raw=$(echo "$inspect_data" | jq -r '.[0].HostConfig.NanoCPUs')
                if [[ "$nano_cpus_raw" =~ ^[0-9]+$ ]] && [ "$nano_cpus_raw" -gt 0 ]; then
                    cpu_limit_display=$(awk -v nano="$nano_cpus_raw" 'BEGIN { printf "%.2f", nano / 1e9 }')
                else
                    cpu_limit_display="无限制"
                fi
            else
                mem_limit_display="获取失败"
                cpu_limit_display="获取失败"
            fi

            # 3. 如果容器正在运行，则获取实时统计数据
            if [[ "$container_status" == "Up" ]]; then
                local stats_output=$(${SUDO} docker stats --no-stream --format "{{.CPUPerc}}|{{.MemUsage}}" "${container_name}" 2>/dev/null)
                if [ -n "$stats_output" ]; then
                    cpu_usage_display=$(echo "$stats_output" | cut -d'|' -f1 | sed 's/\%//g') # 移除 '%'
                    mem_usage_display=$(echo "$stats_output" | cut -d'|' -f2 | awk '{print $1}') # 取如 "1.5G/4.0G" 中的 "1.5G"
                fi
            fi
            
            node_index=$((node_index + 1))
            printf "%-6d %-20s %-10s %-12s %-12s %-10s %-15s %-20s\n" \
                "$node_index" \
                "$node_id" \
                "$cpu_usage_display" \
                "$mem_usage_display" \
                "$mem_limit_display" \
                "$cpu_limit_display" \
                "$container_status" \
                "$container_created_time"
        done
    fi
    echo "--------------------------------------------------------------------------"
    echo "提示:"
    echo "  - CPU%: 当前容器的 CPU 使用率百分比."
    echo "  - 内存使用: 当前容器正在使用的内存量 ('-' 表示已停止)."
    echo "  - 内存限制: 容器运行时设置的内存上限 (来自 '--memory' 参数)."
    echo "  - CPU核数: 容器运行时设置的 CPU 核心数 (来自 '--cpus' 参数)."
    echo "  - 状态: 容器的当前运行状态 (Up, Exited, Created)."
    echo "  - 创建时间: 容器被创建的时间."
    read -p "按任意键返回主菜单..."
}

# 获取所有已部署 Nexus 节点的 ID 列表
function get_all_node_ids() {
    if ! check_docker &> /dev/null; then # 静默检查 Docker
        return 1 # 命令不存在或服务未运行
    fi
    ${SUDO} docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 查看指定节点的日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    if ! check_docker; then
        echo "Docker 环境未就绪，无法查看日志。"
        return 1
    fi
    
    # 检查容器是否存在
    if ! ${SUDO} docker ps -a --filter "name=${container_name}" --format "{{.Names}}" &> /dev/null; then
        echo ""
        echo "错误：节点 '$node_id' (容器 '$container_name') 在系统中未找到。"
        read -p "按任意键返回菜单..."
        return
    fi

    echo ""
    echo "正在查看节点 '$node_id' 的日志..."
    echo "按 Ctrl+C 退出日志实时跟踪。"
    echo ""
    echo "请选择日志显示模式:"
    echo "1. 原始日志 (包含颜色代码，最完整)"
    echo "2. 清理后的日志 (移除 ANSI 颜色代码)"
    
    read -rp "请输入选项 (1 或 2): " log_mode
    
    case "$log_mode" in
        1)
            ${SUDO} docker logs -f "$container_name"
            ;;
        2)
            # 使用 sed 移除 ANSI 转义序列，使其更易读
            ${SUDO} docker logs -f "$container_name" | sed -e 's/\x1b\[[0-9;]*m//g' -e 's/\x1b\[?25l//g' -e 's/\x1b\[?25h//g'
            ;;
        *)
            echo "无效选项。将使用原始日志模式。"
            ${SUDO} docker logs -f "$container_name"
            ;;
    esac
    echo ""
    echo "已退出日志查看模式。"
}

# 批量启动多个节点
function batch_start_nodes() {
    echo ""
    echo "--- 批量启动 Nexus 节点 ---"
    echo "请输入您要启动的节点 IDs，每行一个，输入空行并按 Ctrl+D 结束输入："
    echo "例如:"
    echo "    node-001"
    echo "    node-002"
    echo "    ..."
    
    local node_ids=()
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            node_ids+=("$line")
        fi
    done
    
    # 检查是否输入了节点 IDs
    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何节点 IDs。返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    read -rp "是否在启动前构建最新的 Docker 镜像? (y/N): " build_image_choice
    if [[ "$build_image_choice" =~ ^[Yy]$ ]]; then
        if ! build_image; then
            echo "错误：镜像构建失败，无法启动节点。请检查上述错误信息。"
            read -p "按任意键继续..."
            return
        fi
    else
        echo "跳过镜像构建，将使用现有镜像（如果镜像不存在，启动将会失败）。"
        if ! ${SUDO} docker images -q "$IMAGE_NAME" &> /dev/null; then
            echo "警告: Docker 镜像 '$IMAGE_NAME' 不存在。您可能需要选择重新构建镜像，否则节点启动会失败。"
            read -p "按任意键继续..."
            return
        fi
    fi

    echo ""
    echo "开始启动以下 ${#node_ids[@]} 个节点："
    for node_id in "${node_ids[@]}"; do echo "    - $node_id"; done
    
    local launch_success_count=0
    local launch_fail_count=0
    
    for node_id in "${node_ids[@]}"; do
        echo "--- 尝试启动节点 '$node_id' ---"
        if run_container "$node_id"; then
            launch_success_count=$((launch_success_count + 1))
            sleep 5 # 在启动连续节点之间添加适当的延迟，以减少对系统的瞬时压力
        else
            launch_fail_count=$((launch_fail_count + 1))
            echo "!! 节点 '$node_id' 启动失败。"
        fi
    done

    echo ""
    echo "批量启动操作完成。"
    echo "成功启动 ${launch_success_count} 个节点，${launch_fail_count} 个节点启动失败。"
    read -p "按任意键返回主菜单..."
}

# 批量节点轮换启动管理
function batch_rotate_nodes() {
    echo ""
    echo "--- Nexus 节点轮换启动管理 ---"
    # 首先确保 Docker 可用
    if ! check_docker; then
        echo "Docker 服务检查失败，无法进行节点轮换管理。" # check_docker 会提供所有信息和指引
        read -p "按任意键继续..."
        return # 如果 Docker 不可用，直接返回，停止当前操作
    fi
    # 只有当 Docker 可用时才检查 PM2
    if ! check_pm2; then
        echo "PM2 (用于管理轮换进程) 检查失败或安装失败，节点轮换管理将无法进行。"
        echo "请确保您已成功安装 Node.js, npm, 并使用 npm 安装了 pm2。"
        read -p "按任意键继续..."
        return
    fi

    echo "请输入您希望参与轮换的节点 IDs，每行一个，输入空行并按 Ctrl+D 结束输入："
    echo "示例:"
    echo "    rot-node-a"
    echo "    rot-node-b"
    echo "    ..."
    
    local node_ids=()
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            node_ids+=("$line")
        fi
    done
    
    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何节点 IDs。返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    local total_nodes=${#node_ids[@]}
    echo "共输入 ${total_nodes} 个节点 ID 进行轮换配置。"

    # 设定每批启动的节点数量
    read -rp "请输入每批要启动的节点数量（留空则按总节点数的 1/3 自动计算，建议 1-3 之间以控制压力）: " nodes_per_round_input
    if [[ -z "$nodes_per_round_input" ]]; then
        nodes_per_round=$(( (total_nodes + 2) / 3 )) # 至少 1 个节点
        [ "$nodes_per_round" -lt 1 ] && nodes_per_round=1
        echo "使用默认的每批启动节点数量: $nodes_per_round"
    else
        nodes_per_round="$nodes_per_round_input"
    fi

    # 输入验证
    if ! [[ "$nodes_per_round" =~ ^[1-9][0-9]*$ ]] || [ "$nodes_per_round" -gt "$total_nodes" ]; then
        echo "输入无效。请确保每批启动的节点数量是大于等于 1 的整数，并且不超过总节点数 (${total_nodes})。"
        read -p "按任意键返回..."
        return
    fi
    
    # 计算批次总数
    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    echo "节点将分 ${num_groups} 批次启动，每批次约启动 ${nodes_per_round} 个节点。"
    echo "每批启动间隔 2 小时。"
    
    # 停止并删除之前可能存在的 'nexus-rotate' PM2 进程
    echo "停止并移除可能存在的旧的 'nexus-rotate' PM2 进程..."
    ${SUDO} pm2 delete nexus-rotate --silent || true # --silent 忽略错误，例如进程不存在

    # 构建最新镜像，轮换启动前务必保证镜像是最新的
    if ! build_image; then
        echo "错误：镜像构建失败，无法进行节点轮换启动。请检查上述错误信息。"
        read -p "按任意键继续..."
        return
    fi
    
    # --- 创建用于轮换启动的脚本 ---
    ${SUDO} mkdir -p "$SCRIPT_DIR"
    ${SUDO} rm -f "${SCRIPT_DIR}"/*.sh # 清理旧的轮换脚本，以防重复创建导致混乱

    echo "正在为节点轮换创建启动脚本..."

    # 为每批次生成一个独立的启动脚本
    for ((group=1; group<=num_groups; group++)); do
        local start_idx=$(( (group-1) * nodes_per_round ))
        local end_idx=$(( group * nodes_per_round ))
        [ "$end_idx" -gt "$total_nodes" ] && end_idx=$total_nodes # 防止越界
        
        local group_script="${SCRIPT_DIR}/start_group${group}.sh"
        cat > "$group_script" <<EOF
#!/bin/bash
set -e

# 在子脚本中再次获取 SUDO 变量，以确保权限正确传递
SUB_SUDO=""
if [[ "\$EUID" -ne 0 ]]; then
    if command -v sudo &> /dev/null && sudo -v &> /dev/null; then
        SUB_SUDO="sudo"
    fi
fi

echo ""
echo "[$(date '+%Y-%m-%d %H:%M:%S')] ================================================"
echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===  开始执行第 ${group}/${num_groups} 批次节点启动指令  ==="
echo "[$(date '+%Y-%m-%d %H:%M:%S')] ================================================"

# !!! 重要步骤：在启动新一批节点前，先停止并删除所有现有的 nexus-node 容器。
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 正在停止并删除所有 Nexus Node 容器..."
if command -v docker &> /dev/null; then
    # -r 表示只有当 xargs 接收到输入时才执行 docker rm
    # -f 强制删除，包括正在运行的容器
    # 2>&1 将 stderr 也重定向到 /dev/null，避免输出“未找到容器”等信息
    \$SUB_SUDO docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r \$SUB_SUDO docker rm -f > /dev/null 2>&1
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 已清理完所有 Nexus Node 容器。"
else
    echo "警告: Docker 命令不可用，无法清理 Nexus Node 容器。请检查 Docker 是否正确安装并运行。"
fi
echo ""

# 依次启动当前批次的节点
EOF

        # 向脚本添加启动每个节点的命令
        for ((i=$start_idx; i<$end_idx; i++)); do
            local node_id="${node_ids[$i]}"
            local container_name="${BASE_CONTAINER_NAME}-${node_id}"
            local log_file="${LOG_DIR}/nexus-${node_id}.log"
            
            # 确保日志目录和文件存在且可写，并设置正确的所有者
            ${SUDO} mkdir -p "$LOG_DIR"
            ${SUDO} touch "$log_file"
            ${SUDO} chmod 644 "$log_file"
            if [ "$EUID" -ne 0 ]; then # 如果主脚本不是root运行，则确保日志文件的用户所有权正确
                ${SUDO} chown $(whoami):$(whoami) "$log_file"
            fi

            echo "echo \"[$(date '+%Y-%m-%d %H:%M:%S')]  ->  尝试启动节点 '$node_id' (容器: '$container_name')\"" >> "$group_script"
            echo "local MEM_LIMIT=\"${DEFAULT_MEMORY_LIMIT}\"" >> "$group_script"
            echo "local CPUS_LIMIT=\"${DEFAULT_CPUS_LIMIT}\"" >> "$group_script"
            echo "local NODE_IMAGE_NAME=\"${IMAGE_NAME}\"" >> "$group_script"
            
            # 使用docker run 命令，保持和run_container相同的逻辑，使用 SUB_SUDO
            echo "\$SUB_SUDO docker run -d \\" >> "$group_script"
            echo "        --name \"${container_name}\" \\" >> "$group_script"
            echo "        --memory \"\${MEM_LIMIT}\" \\" >> "$group_script"
            echo "        --cpus \"\${CPUS_LIMIT}\" \\" >> "$group_script"
            echo "        -v \"${log_file}\":\"/root/nexus.log\" \\" >> "$group_script"
            echo "        -e NODE_ID=\"${node_id}\" \\" >> "$group_script"
            echo "        \"\${NODE_IMAGE_NAME}\" > /dev/null" >> "$group_script"
            echo "if [ \$? -eq 0 ]; then" >> "$group_script"
            echo "  echo \"[$(date '+%Y-%m-%d %H:%M:%S')]      ->  节点 '$node_id' 启动命令已发送（请通过列表或日志确认实际状态）\"" >> "$group_script"
            echo "else" >> "$group_script"
            echo "  echo \"[$(date '+%Y-%m-%d %H:%M:%S')]      ->  !! 节点 '$node_id' 启动命令执行失败！请检查系统资源和Docker日志。\"" >> "$group_script"
            echo "fi" >> "$group_script"
            echo "sleep 10 # 每个节点启动间的小延迟" >> "$group_script"
        done
        
        echo "echo \"[$(date '+%Y-%m-%d %H:%M:%S')] 第 ${group} 批节点启动指令集生成完毕。\"" >> "$group_script"
        ${SUDO} chmod +x "$group_script" # 脚本必须有执行权限
    done

    # --- 创建主管理脚本，用于按批次轮换启动 ---
    local manager_script="${SCRIPT_DIR}/rotate_manager.sh"
    cat > "$manager_script" <<EOF
#!/bin/bash
set -e

# 在子脚本中再次获取 SUDO 变量
SUB_SUDO=""
if [[ "\$EUID" -ne 0 ]]; then
    if command -v sudo &> /dev/null && sudo -v &> /dev/null; then
        SUB_SUDO="sudo"
    fi
fi

echo "[$(date '+%Y-%m-%d %H:%M:%S')] Nexus 节点轮换管理脚本启动..."
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 总节点数: ${total_nodes}, 每批启动数: ${nodes_per_round}, 共 ${num_groups} 批。"

INTERVAL_HOURS=2
SLEEP_SECONDS=\$((INTERVAL_HOURS * 60 * 60)) # 2小时转换为秒

for ((group=1; group<=${num_groups}; group++)); do
    echo ""
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] >>>>>>  正在执行第 \${group}/${num_groups} 批次的节点启动  <<<<<<"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
    
    # 执行当前批次的启动脚本
    local current_group_script="/root/nexus_scripts/start_group\${group}.sh"
    if [ -x "\$current_group_script" ]; then
        "\$current_group_script"
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 错误: 启动脚本 \$current_group_script 不可执行。请检查文件权限，可能需要执行: '\$SUB_SUDO chmod +x \$current_group_script'。"
        exit 1 # 硬停止，因为无法执行子脚本
    fi
    
    # 如果不是最后一批，则等待指定间隔
    if [ "\$group" -lt "${num_groups}" ]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 完成第 \${group} 批次启动指令执行。等待 \${INTERVAL_HOURS} 小时进入下一批次..."
        sleep "\${SLEEP_SECONDS}"
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 所有批次的节点启动指令执行完毕。"
    fi
done

echo ""
echo "[$(date '+%Y-%m-%d %H:%M:%S')] ===== Nexus 节点轮换启动周期完成！====="
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 如需再次轮换，请重新启动本 PM2 进程或再次运行本脚本。"

exit 0
EOF
    ${SUDO} chmod +x "$manager_script"

    # 使用 PM2 启动管理脚本
    echo "使用 PM2 启动轮换管理进程..."
    # 为PM2进程指定输出和错误日志，方便调试
    ${SUDO} pm2 start "${manager_script}" --name "nexus-rotate" --interpreter bash \
        --output "${SCRIPT_DIR}/pm2-rotate-out.log" --error "${SCRIPT_DIR}/pm2-rotate-err.log"
    
    ${SUDO} pm2 save # 保存 PM2 配置，这样 PM2 服务启动时会加载这个进程
    ${SUDO} pm2 list # 显示 PM2 管理的进程列表

    echo "-------------------------------------------------------------"
    echo "Nexus 节点轮换启动配置完成！"
    echo "轮换流程已通过 PM2 启动。请使用以下命令进行监控和管理:"
    echo "  ${SUDO} pm2 list                  # 查看 PM2 管理的进程状态"
    echo "  ${SUDO} pm2 logs nexus-rotate     # 查看轮换管理脚本的聚合日志"
    echo "  ${SUDO} tail -f ${SCRIPT_DIR}/pm2-rotate-out.log # 查看轮换管理脚本的stdout日志"
    echo "  ${SUDO} tail -f ${SCRIPT_DIR}/pm2-rotate-err.log # 查看轮换管理脚本的stderr日志"
    echo "  ${SUDO} pm2 stop nexus-rotate     # 停止轮换进程"
    echo "  ${SUDO} pm2 restart nexus-rotate  # 重启轮换进程"
    echo "  ${SUDO} pm2 delete nexus-rotate   # 删除轮换进程配置"
    echo "-------------------------------------------------------------"
    read -p "按任意键返回主菜单..."
}

# 设置定时任务以自动清理过期的 Nexus 日志文件
function setup_log_cleanup_cron() {
    echo "--- 配置日志清理定时任务 ---"
    if ! is_root_or_sudo_available; then
        echo "警告: 无法设置定时清理任务。请以 root 身份或具备 sudo 权限的用户执行此操作。"
        return 1
    fi

    # 每天凌晨 3 点执行一次清理任务，删除超过 2 天未修改的日志文件
    local cron_job="0 3 * * * find $LOG_DIR -type f -name 'nexus-*.log' -mtime +2 -delete"
    local CRON_FILE="/tmp/nexus_cron_jobs.$$" # 临时存储 cron 配置，确保可写

    # 尝试获取当前用户的 crontab 内容
    if ! ${SUDO} crontab -l &> "$CRON_FILE"; then
        echo "当前用户的 crontab 文件不存在或无法读取。将创建新的 crontab 配置。"
        echo "" > "$CRON_FILE" # 创建一个空的临时文件
    fi

    # 检查任务是否已存在
    if grep -Fq "$cron_job" "$CRON_FILE"; then
        echo "定时日志清理任务已存在，无需重复添加。"
    else
        # 添加新任务到临时文件
        echo "$cron_job" >> "$CRON_FILE"
        # 将临时文件内容导入 crontab
        if ${SUDO} crontab "$CRON_FILE"; then
            echo "成功添加定时日志清理任务。"
            echo "任务内容: \"$cron_job\""
            echo "（任务将在每天凌晨 3 点执行，清理 $LOG_DIR 中超过 2 天未修改的日志）"
        else
            echo "警告: 添加定时日志清理任务失败。请手动检查您的 crontab 配置 ('${SUDO} crontab -e')。"
        fi
    fi
    
    # 清理临时文件
    rm -f "$CRON_FILE"
    echo "日志清理定时任务配置完成。"
}

# 批量卸载节点的函数定义
function batch_uninstall_nodes() {
    echo ""
    echo "--- 批量停止并卸载节点 ---"
    if ! check_docker; then
        echo "Docker 环境未就绪，无法卸载节点。"
        read -p "按任意键返回主菜单..."
        return 1
    fi
    
    local all_nodes_ids=$(get_all_node_ids)
    
    if [ -z "$all_nodes_ids" ]; then
        echo "系统中当前没有已部署的 Nexus 节点。"
        read -p "按任意键返回..."
        return
    fi

    echo "请选择要卸载的节点 (输入数字，用空格分隔，例如: 1 3 5):"
    local node_list=($all_nodes_ids)
    for i in "${!node_list[@]}"; do
        local node_id=${node_list[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        # 获取容器状态
        local status=$(${SUDO} docker ps -a --filter "name=$container_name" --format "{{.Status}}" 2>/dev/null | tr '[:lower:]' '[:upper:]')
        local node_display_id="${node_id}"
        if [[ "$status" == "UP"* ]]; then
            node_display_id+=' [运行中]'
        elif [[ "$status" == "EXITED"* || "$status" == "CREATED"* ]]; then
            node_display_id+=' [已停止]'
        else
            node_display_id+=' [状态未知/不存在]' # 理论上不会走到这里，因为node_list是从ps -a获取的
        fi
        printf "  %d. %s\n" $((i+1)) "$node_display_id"
    done
    echo "  0. 返回主菜单"
    echo ""

    read -rp "请输入您的选择: " choices
    if [ "$choices" == "0" ]; then
        echo "返回主菜单。"
        return
    fi
    
    local selected_indices=()
    # 遍历输入的每个数字，并验证其有效性
    for choice_num in $choices; do
        if [[ "$choice_num" =~ ^[0-9]+$ ]] && [ "$choice_num" -ge 1 ] && [ "$choice_num" -le "${#node_list[@]}" ]; then
            selected_indices+=($((choice_num-1))) # 存储基于0的索引
        else
            echo "警告: 跳过无效的节点编号 '$choice_num'。请输入列表中的有效数字。"
        fi
    done

    if [ ${#selected_indices[@]} -eq 0 ]; then
        echo "未选择任何有效节点进行卸载。"
        read -p "按任意键返回主菜单..."
        return
    fi

    echo ""
    read -rp "您确定要卸载这 ${#selected_indices[@]} 个节点吗？(输入 'yes' 确认): " confirm_uninstall
    if [[ "$confirm_uninstall" == "yes" ]]; then
        local uninstalled_count=0
        for index in "${selected_indices[@]}"; do
            local node_to_uninstall=${node_list[$index]}
            echo "正在卸载节点 '$node_to_uninstall'..."
            if uninstall_node "$node_to_uninstall"; then
                uninstalled_count=$((uninstalled_count + 1))
            else
                echo "错误: 卸载节点 '$node_to_uninstall' 失败。"
            fi
        done
        echo ""
        echo "已完成对 ${uninstalled_count} 个节点的卸载。"
    else
        echo "取消了卸载操作。"
    fi
    read -p "按任意键返回主菜单..."
}


# --- 主菜单与逻辑 ---
function main_menu() {
    # 脚本启动时，先确保基本的系统工具和日志清理任务已设置
    ensure_package_installed "jq" # 用于docker inspect解析
    ensure_package_installed "curl" # 用于下载docker/node安装脚本

    # 尝试配置日志清理定时任务
    setup_log_cleanup_cron

    while true; do
        clear
        echo ""
        echo "========================= Nexus 多节点管理脚本 =========================="
        echo "   脚本作者: 哈哈哈哈 (推特 @ferdie_jhovie)"
        echo "   支持节点数量不限 (取决于您服务器的硬件资源)"
        echo "=========================================================================="
        echo " 1. 部署并启动单个新 Nexus 节点"
        echo " 2. 显示当前已部署所有 Nexus 节点的状态 (包括资源使用情况)"
        echo " 3. 批量停止并卸载指定的 Nexus 节点"
        echo " 4. 查看指定 Nexus 节点的实时运行日志"
        echo " 5. 配置并启动 Nexus 节点轮换计划 (按批次启动，每批间隔 2h)"
        echo " 6. 一键删除并清理所有已部署的 Nexus 节点及相关文件"
        echo " 7. 退出脚本"
        echo "=========================================================================="
        echo "当前节点资源限制设置: 内存=${DEFAULT_MEMORY_LIMIT}, CPU=${DEFAULT_CPUS_LIMIT}"
        if [ "$EUID" -ne 0 ] && ! is_root_or_sudo_available; then
            echo "⚠️  警告: 当前用户无 root 权限或 sudo 权限，部分功能可能受限！"
        fi
        echo ""
        read -rp "请选择您要执行的操作 (1-7): " choice

        case "$choice" in
            1) # 部署新节点
                if ! check_docker; then
                    read -p "按任意键返回主菜单..."
                    continue
                fi
                read -rp "请输入此新节点的 Node ID (例如: my-nexus-node-001): " NODE_ID
                if [ -z "$NODE_ID" ]; then
                    echo "Node ID 不能为空。请重新选择操作。"
                else
                    # 首次部署前，检查镜像是否存在，不存在则构建
                    if ! ${SUDO} docker images -q "$IMAGE_NAME" &> /dev/null; then
                        echo "Nexus Docker 镜像 '$IMAGE_NAME' 未找到，将为您构建..."
                        if ! build_image; then
                            echo "错误: Docker 镜像构建失败，无法部署节点。请检查上述错误。"
                            read -p "按任意键返回主菜单..."
                            continue
                        fi
                    else
                        echo "Nexus Docker 镜像 '$IMAGE_NAME' 已存在，跳过构建。"
                    fi
                    run_container "$NODE_ID"
                fi
                read -p "按任意键返回主菜单..."
                ;;
            2) # 显示所有节点状态
                list_nodes
                ;;
            3) # 批量卸载节点
                batch_uninstall_nodes
                ;;
            4) # 查看日志
                local all_node_ids_temp=$(get_all_node_ids)
                if [ -z "$all_node_ids_temp" ]; then
                    echo "系统中尚无已部署的节点。无法查看日志。"
                else
                    echo ""
                    echo "可用的节点列表用于选择日志查看:"
                    local node_list=($all_node_ids_temp)
                    local node_index=1
                    for id in "${!node_list[@]}"; do
                        local node_id_disp=${node_list[$id]}
                        printf "  %d. %s\n" $((node_index)) "$node_id_disp"
                        node_index=$((node_index + 1))
                    done
                    echo ""
                    read -rp "请输入要查看日志的节点的 Node ID: " node_to_view_id
                    if [ -z "$node_to_view_id" ]; then
                        echo "Node ID 为空，取消操作。"
                    # 使用一个更可靠的方法来检查输入ID是否存在于列表中
                    elif [[ " ${node_list[*]} " =~ " ${node_to_view_id} " ]]; then
                        view_node_logs "$node_to_view_id"
                    else
                        echo "未找到您输入的 Node ID: '$node_to_view_id'。请检查输入是否正确，或选择 '2' 查看节点列表确认。"
                    fi
                fi
                read -p "按任意键返回主菜单..."
                ;;
            5) # 批量轮换启动
                batch_rotate_nodes
                ;;
            6) # 删除所有节点
                echo ""
                echo "======================== 警告: 删除所有节点 ========================="
                echo "此操作将永久删除系统中所有 Nexus Node 容器、PM2 轮换进程、及其所有数据和日志文件。"
                echo "请务必确认您已备份所有重要信息。"
                
                if ! check_docker; then
                    echo "Docker 环境未就绪，无法执行此操作。"
                    read -p "按任意键返回主菜单..."
                    continue
                fi
                
                local existing_nodes_count=$(${SUDO} docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | wc -l)
                if [ "$existing_nodes_count" -eq 0 ]; then
                    echo "系统中没有找到 Nexus 节点需要删除。"
                else
                    echo "系统检测到 ${existing_nodes_count} 个 Nexus 节点。"
                    read -rp "您确定要删除所有 Nexus 节点及相关数据吗？(输入 'yes' 确认): " confirm_delete_all
                    if [[ "$confirm_delete_all" == "yes" ]]; then
                        echo "开始删除所有 Nexus 节点..."
                        local all_nodes=($(get_all_node_ids))
                        for node_id in "${all_nodes[@]}"; do
                            echo "  正在卸载节点 '$node_id'..."
                            uninstall_node "$node_id"
                        done
                        echo "所有节点已删除。"
                    else
                        echo "取消了删除所有节点的操作。"
                    fi
                fi
                
                # 清理 PM2 进程及相关脚本
                if command -v pm2 &> /dev/null; then
                    echo "正在清理 PM2 轮换管理进程和脚本..."
                    ${SUDO} pm2 delete nexus-rotate --silent || true
                    ${SUDO} pm2 save # 保存更改
                    echo "PM2 进程已清理。"
                fi
                if [ -d "$SCRIPT_DIR" ]; then
                    echo "正在删除轮换脚本目录 '$SCRIPT_DIR'..."
                    ${SUDO} rm -rf "$SCRIPT_DIR"
                    echo "脚本目录已删除。"
                fi
                if [ -d "$LOG_DIR" ]; then
                    echo "正在删除节点日志目录 '$LOG_DIR'..."
                    ${SUDO} rm -rf "$LOG_DIR"
                    echo "节点日志目录已删除。"
                fi
                echo "所有相关资源清理完成。"
                read -p "按任意键返回主菜单..."
                ;;
            7) # 退出
                echo ""
                echo "感谢使用 Nexus 节点管理脚本。祝您使用愉快！"
                exit 0
                ;;
            *) # 无效选项
                echo "无效的选项，请输入 1 到 7 之间的数字。"
                read -p "按任意键继续..."
                ;;
        esac
    done
}


# --- 主脚本执行入口 ---
main_menu
