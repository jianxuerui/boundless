#!/bin/bash
set -e

# =========================================================================================
# Nexus 多节点管理脚本 (ARM64 Docker版) - 8核16G 极限优化版
# 作者: 哈哈哈哈 (推特 @ferdie_jhovie)
# 优化: AI Assistant
# 描述: 此脚本为 8核/16G RAM 服务器运行 3个 Nexus 节点提供极致性能优化。
#       【V5 终极优化】:
#       1. 【一键部署】: 新增推荐方案，一键部署为 8C/16G 优化的3个节点。
#       2. 【资源压榨】: 预设激进的CPU(2.5核)与内存(4G)限制，充分利用硬件性能。
#       3. 【精简构建】: 使用 'docker build -f -' 技术，构建过程无需本地临时文件。
#       4. 【增强监控】: 节点列表直接显示内存使用量和分配上限，清晰明了。
# =========================================================================================

# --- 配置项 ---
BASE_CONTAINER_NAME="nexus-node-pro"
IMAGE_NAME="nexus-node:latest-arm64-pro-optimized"
BUILDER_NAME="nexus_builder"

# --- 8核16G服务器，3节点优化配置 ---
# CPU: (8核 - 0.5核留给系统) / 3节点 = 2.5核/节点
CPU_LIMIT="2.5"
# 内存: (16G - 2G留给系统) / 3节点 ≈ 4.6G/节点。我们设置为4G，留有余量。
MEMORY_LIMIT="4g"
# 推荐的一键部署节点ID列表
RECOMMENDED_NODE_IDS=("nexus-jupiter" "nexus-saturn" "nexus-neptune")

# --- 核心功能函数 ---

# check_docker 和 setup_buildx 函数与之前版本相同，保持不变
function check_docker() { if ! command -v docker >/dev/null 2>&1; then echo "检测到未安装 Docker，正在为您安装..." >&2; sudo apt-get update && sudo apt-get install -y ca-certificates curl && sudo install -m 0755 -d /etc/apt/keyrings && sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && sudo chmod a+r /etc/apt/keyrings/docker.asc && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null && sudo apt-get update && sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin && sudo systemctl enable docker && sudo systemctl start docker && echo "Docker 安装完成！"; fi; if ! docker buildx version >/dev/null 2>&1; then echo "错误：未找到 Docker buildx 插件。请确保您的 Docker 版本包含 buildx。" >&2; exit 1; fi; }
function setup_buildx() { if docker buildx ls | grep -q "${BUILDER_NAME}.*running"; then docker buildx use $BUILDER_NAME; return; fi; echo "检测到需要设置跨平台构建环境 (QEMU)..."; if docker buildx ls | grep -q "$BUILDER_NAME"; then docker buildx inspect $BUILDER_NAME --bootstrap; else docker buildx create --name $BUILDER_NAME --driver docker-container --use; fi; if ! docker run --rm --privileged tonistiigi/binfmt | grep -q "setting up"; then docker run --rm --privileged tonistiigi/binfmt --install all; fi; echo "Buildx 环境设置完成。"; }

# 【V5 优化】构建 Docker 镜像，无需临时文件
function build_image() {
    if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        echo "镜像 $IMAGE_NAME 已存在，跳过构建。"
        return
    fi
    
    setup_buildx
    echo "正在准备构建环境 (无临时文件模式)..."

    # 将 entrypoint.sh 的内容存储在变量中
    local entrypoint_script
    read -r -d '' entrypoint_script <<'EOF'
#!/bin/sh
set -e
if [ -z "$NODE_ID" ]; then echo "错误：缺少 NODE_ID 环境变量！" >&2; exit 1; fi
mkdir -p /root/.nexus && echo "$NODE_ID" > /root/.nexus/node-id
echo "节点 [ $NODE_ID ] 配置完成，启动主进程..."
echo "日志将由 Docker 捕获, 使用 'docker logs <容器名>' 查看。"
exec nexus-network start --node-id "$NODE_ID"
EOF

    echo "正在使用 builder '$BUILDER_NAME' 构建镜像 $IMAGE_NAME..."
    # 【优化】使用 here-document 直接将 Dockerfile 内容传给 build 命令
    # 同时，将 entrypoint 脚本内容通过 build context 传递进去
    docker buildx build --builder $BUILDER_NAME --platform linux/arm64 -t "$IMAGE_NAME" --load -f- . <<EOF
ARG TARGETPLATFORM=linux/arm64
FROM --platform=\$TARGETPLATFORM alpine:latest

# 安装依赖并下载二进制文件
RUN apk add --no-cache curl bash ca-certificates \
    && curl -L -o /usr/local/bin/nexus-network https://github.com/nexus-xyz/nexus-cli/releases/download/v0.10.1/nexus-network-linux-arm64 \
    && chmod +x /usr/local/bin/nexus-network

# 复制 entrypoint.sh
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
EOF
    echo "镜像 $IMAGE_NAME 构建完成！"
}

# run_container 函数与之前版本类似，但强调了资源配置
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"

    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "节点 $node_id (容器 $container_name) 已存在，正在删除旧容器..."
        docker rm -f "$container_name"
    fi
    
    echo "正在启动容器 $container_name..."
    echo "  -> 分配资源: ${CPU_LIMIT} CPU 核心, ${MEMORY_LIMIT} 内存"
    
    docker run -d --name "$container_name" \
        -e NODE_ID="$node_id" \
        --cpus="$CPU_LIMIT" \
        --memory="$MEMORY_LIMIT" \
        --restart unless-stopped \
        "$IMAGE_NAME"
    
    echo "容器 $container_name 已启动！使用 'docker logs -f $container_name' 查看。"
}


# 【V5 优化】一键部署推荐方案
function deploy_recommended_setup() {
    echo "即将为您一键部署为 8核/16G 优化的 3 节点方案..."
    echo "将创建以下节点："
    printf " - %s\n" "${RECOMMENDED_NODE_IDS[@]}"
    echo "每个节点将被分配 ${CPU_LIMIT} 个CPU核心 和 ${MEMORY_LIMIT} 的内存。"
    read -rp "是否继续？ [y/N]: " confirmation
    if [[ "$confirmation" != "y" && "$confirmation" != "Y" ]]; then
        echo "操作已取消。"
        return
    fi

    # 1. 确保镜像已构建
    build_image
    
    # 2. 循环启动所有推荐节点
    echo "开始批量启动容器..."
    for node_id in "${RECOMMENDED_NODE_IDS[@]}"; do
        run_container "$node_id"
        sleep 1 # 短暂间隔，避免同时请求 Docker API
    done
    
    echo "=========================================="
    echo "🚀 所有推荐节点已部署并启动！"
    echo "=========================================="
}


# 【V5 优化】增强的节点列表显示
function list_nodes() {
    echo "------------------------------------- 当前 Nexus 节点状态 --------------------------------------"
    printf "%-28s %-15s %-15s %-25s\n" "节点 ID (容器名)" "状态" "CPU % (主机)" "内存使用 / 上限"
    echo "------------------------------------------------------------------------------------------------"
    
    containers=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-*" --format "{{.Names}}")

    if [ -z "$containers" ]; then
        echo "未找到任何 Nexus 节点容器。"
    else
        # 优化显示，一次性获取所有运行中容器的stats
        stats_output=$(docker stats --no-stream --filter "name=${BASE_CONTAINER_NAME}-*" --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemLimit}}")
        
        for name in $containers; do
            status=$(docker ps -a --filter "name=$name" --format "{{.Status}}")
            node_id=$(echo "$name" | sed "s/^${BASE_CONTAINER_NAME}-//")
            
            stats_line=$(echo "$stats_output" | grep -w "$name")
            if [[ -n "$stats_line" && "$status" == Up* ]]; then
                cpu_perc=$(echo "$stats_line" | awk '{print $2}')
                mem_usage=$(echo "$stats_line" | awk '{print $3 " " $4 " " $5}')
                mem_limit=$(echo "$stats_line" | awk '{print $6 " " $7}')
                
                printf "%-28s %-15s %-15s %-25s\n" "$node_id ($name)" "$status" "$cpu_perc" "${mem_usage} / ${mem_limit}"
            else
                printf "%-28s %-15s %-15s %-25s\n" "$node_id ($name)" "$status" "N/A" "N/A"
            fi
        done
    fi
    echo "------------------------------------------------------------------------------------------------"
}

# 其他辅助函数基本保持不变，这里为了简洁省略了代码，它们与V4版本相同。
# 您可以从V4版本拷贝过来，或者使用下面的简化版
function get_all_node_ids() { docker ps -a --filter "name=${BASE_CONTAINER_NAME}-*" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//" | sort -u; }
function uninstall_node() { local node_id=$1; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; echo "正在停止并删除容器 $container_name..."; if docker rm -f "$container_name" >/dev/null 2>&1; then echo "容器已删除。"; else echo "容器不存在。"; fi; }
function view_node_logs() { local node_id=$1; local container_name="${BASE_CONTAINER_NAME}-${node_id}"; if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then echo "错误：未找到节点 $node_id 的容器。"; return 1; fi; echo "显示节点 '$node_id' 的日志... Ctrl+C 退出。"; sleep 1; docker logs -f "$container_name"; }
function select_node_for_action() { local action_callback=$1; local prompt_message=$2; local all_nodes=($(get_all_node_ids)); if [ ${#all_nodes[@]} -eq 0 ]; then echo "当前没有可操作的节点。"; read -p "按任意键返回..." -n1 -s; return; fi; echo "请选择要'$prompt_message'的节点:"; echo "0. 返回"; for i in "${!all_nodes[@]}"; do printf "%2d. %s\n" $((i+1)) "${all_nodes[$i]}"; done; read -rp "请输入选项: "; if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt ${#all_nodes[@]} ]; then echo "无效选项。"; sleep 1; return; fi; [ "$choice" -eq 0 ] && return; local selected_node_id=${all_nodes[$((choice-1))]} ; "$action_callback" "$selected_node_id"; }
function uninstall_all_nodes_and_image() { echo "!!!!!! 极度危险操作 !!!!!!"; echo "将删除所有节点容器和镜像 $IMAGE_NAME"; read -rp "输入 'yes' 确认: "; if [ "$confirmation" != "yes" ]; then echo "操作取消。"; return; fi; local all_nodes=($(get_all_node_ids)); if [ ${#all_nodes[@]} -gt 0 ]; then echo "正在卸载所有节点..."; for node_id in "${all_nodes[@]}"; do uninstall_node "$node_id"; done; fi; if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then echo "删除镜像..."; docker rmi -f "$IMAGE_NAME"; fi; echo "清理完成。"; }

# --- 主菜单循环 (V5) ---
function main_menu() {
    while true; do
        clear
        echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
        echo "========= Nexus 管理 (8核16G 极限优化版 V5) ========="
        echo "1. 【推荐】一键部署 3 节点方案 (专为8核/16G)"
        echo "2. 安装/启动单个自定义节点"
        echo "3. 查看指定节点日志"
        echo "4. 卸载指定节点"
        echo "5. 卸载所有节点并删除镜像 (危险!)"
        echo "6. 退出脚本"
        echo "-----------------------------------------------------------"
        echo "预设资源: CPU=${CPU_LIMIT}/节点, 内存=${MEMORY_LIMIT}/节点"
        echo "==========================================================="
        list_nodes

        read -rp "请输入选项(1-6): " choice

        case $choice in
            1)
                deploy_recommended_setup
                read -p "操作完成，按任意键返回菜单..."
                ;;
            2)
                read -rp "请输入您的 Node ID: " NODE_ID
                if [ -n "$NODE_ID" ]; then
                    build_image
                    run_container "$NODE_ID"
                else
                    echo "Node ID 不能为空！"
                fi
                read -p "操作完成，按任意键返回菜单..."
                ;;
            3)
                select_node_for_action "view_node_logs" "查看日志"
                ;;
            4)
                select_node_for_action "uninstall_node" "卸载"
                read -p "操作完成，按任意键返回..."
                ;;
            5)
                uninstall_all_nodes_and_image
                read -p "操作完成，按任意键返回..."
                ;;
            6)
                echo "退出脚本。"
                exit 0
                ;;
            *)
                echo "无效选项，请重新输入。"
                sleep 1
                ;;
        esac
    done
}

# --- 脚本执行入口 ---
check_docker
# 创建临时的 entrypoint.sh 用于 Docker build context
cat > entrypoint.sh <<'EOF'
#!/bin/sh
set -e
if [ -z "$NODE_ID" ]; then echo "错误：缺少 NODE_ID 环境变量！" >&2; exit 1; fi
mkdir -p /root/.nexus && echo "$NODE_ID" > /root/.nexus/node-id
echo "节点 [ $NODE_ID ] 配置完成，启动主进程..."
echo "日志将由 Docker 捕获, 使用 'docker logs <容器名>' 查看。"
exec nexus-network start --node-id "$NODE_ID"
EOF

# 主逻辑
main_menu

# 脚本结束时清理临时文件
rm -f entrypoint.sh
