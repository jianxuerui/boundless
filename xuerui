#!/bin/bash

# 脚本名称：MyAwesomeScript - 通用管理模板
# 作者：你的名字/你的推特账号
# 版本：2.0 - 引入混沌模式
# 描述：这是一个多功能 Bash 脚本模板，用于展示脚本的结构和交互模式。
#      本次更新加入一个“混沌模式”，用于模拟系统资源争夺、自我强化和类学习行为。
#      极具实验性质，请务必在安全的测试环境中使用！

# 设置脚本在遇到错误时退出
# 注意：在“混沌模式”中，一些错误（如stress-ng进程被杀死）可能被预期或处理，不会直接退出整个脚本
set -e

# =========================================================================
# 常量定义 - 根据你的脚本用途修改这些路径和名称
# =========================================================================
# 你的应用程序或任务的主目录
MY_APP_DIR="$HOME/my_awesome_app"
# 应用程序或任务的主要执行文件（例如：一个可执行文件或另一个脚本）
MY_APP_EXEC_PATH="$MY_APP_DIR/run_app.sh"
# 后台进程的 PID 文件，用于管理周期性任务
PERIODIC_TASK_PID_FILE="/tmp/my_awesome_script_periodic.pid"
# 脚本自身的日志文件
SCRIPT_LOG_FILE="$HOME/my_awesome_script.log"
# Screen 会话的名称，用于在后台运行你的程序
SCREEN_SESSION_NAME="my_awesome_session"
# 你的应用程序可能用到的额外数据目录（例如：配置、日志、数据）
MY_APP_DATA_DIR="$MY_APP_DIR/data"
MY_APP_CONFIG_FILE="$MY_APP_DIR/config.conf"

# === 混沌模式常量 ===
CHAOS_MODE_PID_FILE="/tmp/my_awesome_script_chaos.pid"
CHAOS_POWER_FILE="$HOME/.my_awesome_script_chaos_power" # 存储混沌模式的力量值
INITIAL_POWER=1
MAX_POWER=20           # 混沌模式的最大力量值
REGEN_RATE=0.5         # 每次迭代力量增长速度 (0-1)
DEGEN_RATE=0.1         # 每次失败力量衰减速度 (0-1)
BASE_INTERVAL=10       # 混沌模式基本检查间隔秒数
MIN_INTERVAL=3         # 最小间隔，避免过于频繁
MAX_CHAOS_AGENTS=5     # 最大并发混沌代理（模拟分化）
STRESS_TEST_DURATION=10 # 单次stress-ng测试时长（秒）

# =========================================================================
# 颜色定义 - 用于在终端输出中增加可读性
# =========================================================================
RED='\033[0;31m'    # 红色
GREEN='\033[0;32m'  # 绿色
YELLOW='\033[0;33m' # 黄色
BLUE='\033[0;34m'   # 蓝色
PURPLE='\033[0;35m' # 紫色
CYAN='\033[0;36m'   # 青色
NC='\033[0m'        # No Color - 重置颜色

# =========================================================================
# 辅助函数 - 封装常用操作，提高代码复用性
# =========================================================================

# 辅助函数：输出日志到文件并同时打印到控制台
log_message() {
    echo -e "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$SCRIPT_LOG_FILE"
}

# 辅助函数：暂停并等待用户按下 Enter 键
pause_and_return() {
    echo -e "${YELLOW}按 Enter 键返回菜单...${NC}"
    read -r
}

# 辅助函数：检查 stress-ng 是否安装
check_stress_ng() {
    if ! command -v stress-ng &> /dev/null; then
        log_message "${RED}警告：stress-ng 命令未安装！${NC}"
        log_message "${YELLOW}混沌模式功能将受限，或回退到效率较低的纯 Bash 资源消耗。${NC}"
        log_message "${CYAN}建议安装：sudo apt install stress-ng 或 sudo yum install stress-ng${NC}"
        return 1
    fi
    return 0
}

# 辅助函数：启动你的应用程序在一个新的 screen 会话中
start_app_in_screen() {
    log_message "${YELLOW}正在尝试启动应用程序 '$SCREEN_SESSION_NAME' 会话...${NC}"

    if [ ! -d "$MY_APP_DIR" ]; then
        log_message "${RED}错误：无法找到应用程序目录 ($MY_APP_DIR)。请确保已执行选项 1 初始化。${NC}"
        return 1
    fi

    # 终止现有的 screen 会话（如果存在）
    if screen -list | grep -q "$SCREEN_SESSION_NAME"; then
        log_message "${YELLOW}检测到现有 screen 会话 '$SCREEN_SESSION_NAME'，正在终止...${NC}"
        screen -S "$SCREEN_SESSION_NAME" -X quit || true # `|| true` 防止因为没有会话而退出
        sleep 1 # 稍微等待 screen 进程结束
    fi

    log_message "${GREEN}正在新的 screen 会话 '$SCREEN_SESSION_NAME' 中启动应用程序...${NC}"
    # 在这里，MY_APP_EXEC_PATH 应该是一个可执行文件或者可被 bash 执行的脚本
    # 如果 MY_APP_EXEC_PATH 需要在特定目录下运行，请使用 cd $MY_APP_DIR && 完整路径
    screen -dmS "$SCREEN_SESSION_NAME" bash -c "cd '$MY_APP_DIR' && '$MY_APP_EXEC_PATH' >> '$MY_APP_DIR/app.log' 2>&1"
    
    if [ $? -ne 0 ]; then
        log_message "${RED}错误：启动应用程序失败。请检查 $MY_APP_EXEC_PATH 脚本或权限。${NC}"
        return 1
    else
        log_message "${GREEN}应用程序已在 screen 会话 '$SCREEN_SESSION_NAME' 中成功启动！${NC}"
        log_message "您可以通过选项 2 或运行 '${YELLOW}screen -r $SCREEN_SESSION_NAME${NC}' 进入会话查看实时状态。"
        log_message "按 ${YELLOW}Ctrl+A${NC} 然后按 ${YELLOW}D${NC} 退出 screen 会话而不终止程序。"
        return 0
    fi
}

# 辅助函数：停止周期性后台进程（通用）
disable_periodic_task() {
    log_message "${YELLOW}正在检查并禁用周期性后台进程...${NC}"
    if [ -f "$PERIODIC_TASK_PID_FILE" ]; then
        PID=$(cat "$PERIODIC_TASK_PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then # 检查 PID 是否仍然活跃
            kill "$PID" 2>/dev/null || true # 尝试终止进程
            log_message "${GREEN}已终止 PID $PID 对应的周期性后台进程。${NC}"
        else
            log_message "${YELLOW}周期性任务 PID 文件 ($PID) 存在，但进程已不存在。${NC}"
        fi
        rm -f "$PERIODIC_TASK_PID_FILE" || true
    else
        log_message "${YELLOW}未找到周期性任务的 PID 文件，无需禁用。${NC}"
    fi
}

# =========================================================================
# 主要功能函数 - 对应主菜单的各项选择
# =========================================================================

# 功能：初始化并运行你的应用程序/服务
init_and_run_app() {
    echo -e "${YELLOW}=== 初始化并运行您的应用程序 ===${NC}"
    echo -e "${GREEN}请输入您的应用程序或服务的唯一标识符/名称 (例如: 您的用户ID或项目名): ${NC}"
    read -r APP_ID

    if [ -z "$APP_ID" ]; then
        log_message "${RED}错误：应用程序标识符不能为空。${NC}"
        return 1
    fi

    log_message "${GREEN}正在为应用程序 '$APP_ID' 设置环境...${NC}"

    # 1. 创建必要的目录
    mkdir -p "$MY_APP_DIR" "$MY_APP_DATA_DIR" || { log_message "${RED}错误：无法创建应用程序目录。${NC}"; return 1; }
    log_message "应用程序主目录已创建：$MY_APP_DIR"
    log_message "应用程序数据目录已创建：$MY_APP_DATA_DIR"

    # 2. 模拟下载或生成核心应用程序文件
    log_message "${YELLOW}模拟：正在下载或生成核心应用程序文件到 $MY_APP_DIR...${NC}"
    echo "#!/bin/bash" > "$MY_APP_EXEC_PATH"
    echo "echo 'My Awesome App is running for $APP_ID! Time: \$(date)'" >> "$MY_APP_EXEC_PATH"
    echo "sleep 30" # 模拟程序运行一段时间
    echo "echo 'My Awesome App finished its task.'" >> "$MY_APP_EXEC_PATH"
    chmod +x "$MY_APP_EXEC_PATH" || { log_message "${RED}错误：无法设置执行权限。${NC}"; return 1; }
    log_message "核心执行脚本已创建并设置权限：$MY_APP_EXEC_PATH"

    # 3. 模拟配置文件的生成或更新
    log_message "${YELLOW}模拟：正在创建或更新应用程序配置文件：$MY_APP_CONFIG_FILE...${NC}"
    echo "APP_IDENTIFIER=$APP_ID" > "$MY_APP_CONFIG_FILE"
    echo "LAST_INIT_TIME=$(date)" >> "$MY_APP_CONFIG_FILE"
    log_message "配置文件已生成。"

    log_message "${YELLOW}环境设置完成，尝试启动应用程序...${NC}"
    sleep 3 # 给文件系统一点时间同步

    start_app_in_screen
    if [ $? -eq 0 ]; then
        log_message "${GREEN}应用程序已初始化并启动完成。${NC}"
        echo -e "${BLUE}请根据您的实际应用程序需求修改此函数内部的命令和逻辑。${NC}"
        echo -e "${CYAN}您可以通过选项 2 查看 'app.log' 或 screen 会话来检查程序的运行状况。${NC}"
    fi
}

# 功能：查看 screen 会话日志或脚本日志
view_logs() {
    log_message "${YELLOW}=== 查看日志文件 ===${NC}"
    echo -e "${GREEN}1. 查看脚本自身管理日志 ($SCRIPT_LOG_FILE)${NC}"
    echo -e "${GREEN}2. 进入应用程序 Screen 会话 ($SCREEN_SESSION_NAME) 查看实时输出${NC}"
    echo -e "${GREEN}3. 查看应用程序日志 ($MY_APP_DIR/app.log)${NC}"
    echo -e "${YELLOW}请输入您的选择（1-3）：${NC}"
    read -r log_choice

    case $log_choice in
        1)
            if [ -f "$SCRIPT_LOG_FILE" ]; then
                log_message "${CYAN}正在显示脚本日志，按 Ctrl+C 停止。${NC}"
                tail -f "$SCRIPT_LOG_FILE"
            else
                log_message "${RED}错误：脚本日志文件 ($SCRIPT_LOG_FILE) 不存在。${NC}"
            fi
            ;;
        2)
            if screen -list | grep -q "$SCREEN_SESSION_NAME"; then
                log_message "${GREEN}找到 screen 会话 '$SCREEN_SESSION_NAME'。${NC}"
                echo -e "您将进入 screen 会话查看实时输出，命令为：${YELLOW}screen -r $SCREEN_SESSION_NAME${NC}"
                echo -e "按 ${YELLOW}Ctrl+A${NC} 然后按 ${YELLOW}D${NC} 退出 screen 会话而不终止程序。"
                screen -r "$SCREEN_SESSION_NAME"
            else
                log_message "${RED}错误：未找到名为 '$SCREEN_SESSION_NAME' 的 screen 会话。${NC}"
                log_message "${YELLOW}请确保已通过选项 1 或 3 启动应用程序。${NC}"
            fi
            ;;
        3)
            if [ -f "$MY_APP_DIR/app.log" ]; then
                log_message "${CYAN}正在显示应用程序日志 ($MY_APP_DIR/app.log)，按 Ctrl+C 停止。${NC}"
                tail -f "$MY_APP_DIR/app.log"
            else
                log_message "${RED}错误：应用程序日志文件 ($MY_APP_DIR/app.log) 不存在。${NC}"
                log_message "${YELLOW}请确保应用程序已启动并产生日志。${NC}"
            fi
            ;;
        *)
            log_message "${RED}无效的选择。${NC}"
            ;;
    esac
}

# 功能：管理应用程序/服务
manage_app_service() {
    while true; do
        clear
        echo -e "=== ${GREEN}应用程序服务管理子菜单${NC} ==="
        echo "1. 手动启动/重启应用程序服务"
        echo "2. 启用周期性自动检查并启动应用程序（每小时）"
        echo "3. 禁用周期性自动检查任务"
        echo "4. 返回主菜单"
        echo -e "${YELLOW}请输入您的选择（1-4）：${NC}"
        read -r sub_choice

        case $sub_choice in
            1)
                log_message "${YELLOW}正在尝试手动启动/重启应用程序...${NC}"
                disable_periodic_task # 确保手动连接时不会有旧的自动连接在干扰
                start_app_in_screen
                pause_and_return
                ;;
            2)
                log_message "${YELLOW}启用周期性自动检查并启动应用程序（每小时）...${NC}"
                disable_periodic_task # 确保只运行一个实例

                log_message "周期性任务日志将记录在 ${YELLOW}$SCRIPT_LOG_FILE${NC}"
                # 启动后台循环
                (
                    log_message "--- 周期性服务监控任务已启动 on $(date) ---"
                    while true; do
                        log_message "[$(date)] ${YELLOW}尝试自动检查并启动应用程序...${NC}"
                        if ! screen -list | grep -q "$SCREEN_SESSION_NAME"; then # 检查 screen 会话是否还在
                            if start_app_in_screen; then # 如果会话不在，尝试启动
                                log_message "[$(date)] ${GREEN}自动启动成功。${NC}"
                            else
                                log_message "[$(date)] ${RED}自动启动失败。${NC}"
                            fi
                        else
                            log_message "[$(date)] ${CYAN}应用程序 '$SCREEN_SESSION_NAME' 正在运行中，跳过启动。${NC}"
                        fi
                        log_message "[$(date)] ${YELLOW}等待 1 小时后再次检查...${NC}"
                        sleep 3600 # 每小时（3600秒）执行一次
                    done
                ) &
                PID=$!
                echo "$PID" > "$PERIODIC_TASK_PID_FILE"
                log_message "${GREEN}周期性服务监控已在后台启用 (PID: $PID)。${NC}"
                pause_and_return
                ;;
            3)
                disable_periodic_task
                pause_and_return
                ;;
            4)
                return 0
                ;;
            *)
                log_message "${RED}无效的选择，请输入 1-4。${NC}"
                pause_and_return
                ;;
        esac
    done
}

# 功能：更新你的应用程序或脚本
update_my_app() {
    echo -e "=== ${GREEN}更新我的应用程序/脚本${NC} ==="
    # 1. 检查应用程序是否已安装
    if [ ! -d "$MY_APP_DIR" ]; then
        log_message "${RED}错误：应用程序目录 ($MY_APP_DIR) 不存在。请先选择选项 1 初始化。${NC}"
        return 1
    fi

    echo -e "${YELLOW}警告：更新操作将${RED}终止${YELLOW}当前运行的应用程序，${RED}下载/替换最新版本${YELLOW}并可能${RED}修改配置文件${YELLOW}。${NC}"
    echo -e "如果已启用周期性任务，它将被临时禁用并随新版本启动后重新激活。"
    echo -e "${YELLOW}是否继续？（y/n）${NC}"
    read -r confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        log_message "${YELLOW}更新操作已取消。${NC}"
        return 0
    fi

    # 禁用周期性任务，防止更新时其启动旧版本
    disable_periodic_task
    # 禁用混沌模式（如果开启）
    disable_chaos_mode # 更新时不希望它还在压榨系统

    # 停止 screen 会话
    if screen -list | grep -q "$SCREEN_SESSION_NAME"; then
        log_message "${YELLOW}正在终止 '$SCREEN_SESSION_NAME' screen 会话...${NC}"
        screen -S "$SCREEN_SESSION_NAME" -X quit || true
        sleep 1
    fi

    log_message "${YELLOW}进入应用程序目录 ($MY_APP_DIR)...${NC}"
    cd "$MY_APP_DIR" || { log_message "${RED}错误：无法切换到 $MY_APP_DIR 目录。${NC}"; return 1; }

    # === 在这里添加你的具体更新逻辑 ===
    log_message "${YELLOW}模拟：正在删除旧的应用程序文件和数据...${NC}"
    rm -f "run_app.sh" || true # 删除模拟的执行文件
    rm -rf "$MY_APP_DATA_DIR" || true # 删除数据目录，如果需要完全刷新
    log_message "${YELLOW}模拟：正在下载或替换新的应用程序文件...${NC}"
    # 例如：curl -L "你的应用程序新版本下载URL" -o new_app_binary
    # cp /path/to/new_version/run_app.sh . # 如果新版本在你本地
    echo "#!/bin/bash" > "$MY_APP_EXEC_PATH"
    echo "echo 'My Awesome App is running (UPDATED!)! Time: \$(date)'" >> "$MY_APP_EXEC_PATH"
    echo "sleep 30"
    chmod +x "$MY_APP_EXEC_PATH" || { log_message "${RED}错误：无法设置新的执行文件权限。${NC}"; return 1; }
    log_message "${YELLOW}模拟：更新 config.conf 文件 (例如：更改 API 端点)...${NC}"
    # 例如：sed -i 's#old_api_endpoint#new_api_endpoint#' config.conf
    # 为本示例添加一个更新标记
    echo "LAST_UPDATE_TIME=$(date)" >> "$MY_APP_CONFIG_FILE"
    # ==================================

    log_message "${GREEN}应用程序文件已成功更新。现在重新启动...${NC}"
    start_app_in_screen

    log_message "${GREEN}我的应用程序更新并重新启动完成。${NC}"
    echo -e "请使用选项 2 查看日志确认运行状态。"
}

# 功能：卸载并清理你的应用程序/服务
uninstall_my_app() {
    echo -e "${RED}警告：此操作将终止 '$SCREEN_SESSION_NAME' screen 会话，删除所有周期性任务，${NC}"
    echo -e "${RED}并停止混沌模式（如果运行），最后删除 $MY_APP_DIR 目录下的所有文件！${NC}"
    echo -e "${YELLOW}这是${RED}不可逆${YELLOW}的操作。请务必确认！${NC}"
    echo -e "${YELLOW}是否继续？（y/n）${NC}"
    read -r confirm
    if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
        disable_periodic_task # 禁用所有周期性任务
        disable_chaos_mode # 禁用混沌模式

        # 检查并终止 screen 会话
        if screen -list | grep -q "$SCREEN_SESSION_NAME"; then
            screen -S "$SCREEN_SESSION_NAME" -X quit || true
            log_message "${GREEN}已终止 '$SCREEN_SESSION_NAME' screen 会话。${NC}"
        else
            log_message "${YELLOW}未找到 '$SCREEN_SESSION_NAME' screen 会话，跳过终止步骤。${NC}"
        fi

        # 删除应用程序主目录
        if [ -d "$MY_APP_DIR" ]; then
            log_message "${YELLOW}正在删除 $MY_APP_DIR 目录...${NC}"
            rm -rf "$MY_APP_DIR"
            if [ $? -eq 0 ]; then
                log_message "${GREEN}已成功删除 $MY_APP_DIR 目录。${NC}"
            else
                log_message "${RED}错误：删除 $MY_APP_DIR 目录失败，请检查权限或目录状态。${NC}"
                return 1
            fi
        else
            log_message "${YELLOW}未找到 $MY_APP_DIR 目录，跳过删除步骤。${NC}"
        fi
        
        # 删除脚本自身的日志文件（可选）
        if [ -f "$SCRIPT_LOG_FILE" ]; then
            log_message "${YELLOW}正在删除脚本日志文件 ($SCRIPT_LOG_FILE)...${NC}"
            rm -f "$SCRIPT_LOG_FILE" || true
            log_message "${GREEN}已删除脚本日志文件。${NC}"
        fi

        log_message "${GREEN}卸载操作完成。${NC}"
    else
        log_message "${YELLOW}操作已取消，未删除任何内容。${NC}"
    fi
}

# =========================================================================
# 混沌模式功能函数
# =========================================================================

# 获取或初始化混沌模式的力量值
get_chaos_power() {
    if [ -f "$CHAOS_POWER_FILE" ] && [[ "$(cat "$CHAOS_POWER_FILE")" =~ ^[0-9]+$ ]]; then
        cat "$CHAOS_POWER_FILE"
    else
        echo "$INITIAL_POWER" > "$CHAOS_POWER_FILE"
        echo "$INITIAL_POWER"
    fi
}

# 设置混沌模式的力量值
set_chaos_power() {
    local new_power="$1"
    # 限制力量值在 MIN_POWER 和 MAX_POWER 之间
    if (( new_power < INITIAL_POWER )); then new_power=$INITIAL_POWER; fi
    if (( new_power > MAX_POWER )); then new_power=$MAX_POWER; fi
    echo "$new_power" > "$CHAOS_POWER_FILE"
}

# 停止所有由混沌模式可能产生的 stress-ng 进程
cleanup_stress_processes() {
    local pids=$(pgrep -f "stress-ng --chaos-agent" 2>/dev/null || true)
    if [ -n "$pids" ]; then
        log_message "${YELLOW}正在终止活跃的混沌代理 (stress-ng)...${NC}"
        for pid in $pids; do
            if ps -p "$pid" > /dev/null 2>&1; then
                kill "$pid" 2>/dev/null || true
            fi
        done
        sleep 1
    fi
}

# 禁用混沌模式
disable_chaos_mode() {
    log_message "${YELLOW}正在检查并禁用混沌模式后台进程...${NC}"
    if [ -f "$CHAOS_MODE_PID_FILE" ]; then
        PID=$(cat "$CHAOS_MODE_PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then
            kill "$PID" 2>/dev/null || true
            log_message "${GREEN}已终止 PID $PID 对应的混沌模式进程。${NC}"
        else
            log_message "${YELLOW}混沌模式 PID 文件 ($PID) 存在，但主进程已不存在。${NC}"
        fi
        rm -f "$CHAOS_MODE_PID_FILE" || true
    else
        log_message "${YELLOW}未找到混沌模式的 PID 文件，无需禁用。${NC}"
    fi
    cleanup_stress_processes # 确保清理残留的 stress-ng
    log_message "${YELLOW}混沌模式已停止。${NC}"
}

# 启用混沌模式（主循环）
enable_chaos_mode() {
    echo -e "${RED}警告：混沌模式将积极占用系统资源，可能导致系统不稳定甚至无响应！${NC}"
    echo -e "${YELLOW}请在安全且可以接受数据丢失的虚拟机或测试系统上使用此功能！${NC}"
    echo -e "${YELLOW}强烈建议您安装 'stress-ng' 命令以获得最佳模拟效果。${NC}"
    echo -e "${RED}您确定要启用混沌模式吗？这可能需要强制重启系统！${NC}"
    echo -e "${YELLOW}是否继续？（y/n）${NC}"
    read -r confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        log_message "${YELLOW}混沌模式启用已取消。${NC}"
        return 0
    fi

    disable_chaos_mode # 确保只运行一个实例
    
    local has_stress_ng=0
    if check_stress_ng; then
        has_stress_ng=1
    fi

    log_message "${GREEN}正在启动混沌模式后台进程...${NC}"
    # 启动后台循环
    (
        log_message "--- 混沌模式已启动 on $(date) ---"
        log_message "当前混沌力量值: $(get_chaos_power)"
        
        while true; do
            CURRENT_POWER=$(get_chaos_power)
            log_message "[$(date)] ${CYAN}混沌力量：$CURRENT_POWER${NC} - ${YELLOW}能量增长...${NC}"

            # 模拟“学习”：随机调整力量
            # 如果是成功迭代，力量值倾向于增加；如果是失败，力量值倾向于减少
            RAND_SUCCESS_BOOST=$(awk -v rp="$REGEN_RATE" 'BEGIN {print rand()*rp}') # 随机0到REGEN_RATE之间
            RAND_FAILURE_DROP=$(awk -v dp="$DEGEN_RATE" 'BEGIN {print rand()*dp}') # 随机0到DEGEN_RATE之间
            
            # 计算目标并发代理数（力量值越高，并发数越多）
            TARGET_AGENTS=$(( (CURRENT_POWER * MAX_CHAOS_AGENTS / MAX_POWER) > 0 ? (CURRENT_POWER * MAX_CHAOS_AGENTS / MAX_POWER) : 1 ))
            TARGET_AGENTS=$(( TARGET_AGENTS > MAX_CHAOS_AGENTS ? MAX_CHAOS_AGENTS : TARGET_AGENTS ))

            ACTIVE_AGENTS=0
            pids=$(pgrep -f "stress-ng --chaos-agent" 2>/dev/null || true)
            if [ -n "$pids" ]; then
                for pid in $pids; do
                    if ps -p "$pid" > /dev/null 2>&1; then
                        ACTIVE_AGENTS=$((ACTIVE_AGENTS + 1))
                    fi
                done
            fi

            # 决定要启动或停止多少个代理以达到目标
            AGENTS_TO_ADJUST=$((TARGET_AGENTS - ACTIVE_AGENTS))
            if (( AGENTS_TO_ADJUST > 0 )); then
                log_message "${PURPLE}正在启动 ${AGENTS_TO_ADJUST} 个新的混沌代理... (当前活跃: $ACTIVE_AGENTS / 目标: $TARGET_AGENTS)${NC}"
            elif (( AGENTS_TO_ADJUST < 0 )); then
                log_message "${PURPLE}正在关闭 ${-AGENTS_TO_ADJUST} 个混沌代理... (当前活跃: $ACTIVE_AGENTS / 目标: $TARGET_AGENTS)${NC}"
                # 随机终止多余的 stress-ng 进程
                local kill_pids=$(pgrep -f "stress-ng --chaos-agent" | shuf | head -n ${-AGENTS_TO_ADJUST})
                if [ -n "$kill_pids" ]; then
                    for pid_to_kill in $kill_pids; do
                        log_message "${YELLOW}终止混沌代理 PID $pid_to_kill${NC}"
                        kill "$pid_to_kill" 2>/dev/null || true
                    done
                fi
            fi

            for i in $(seq 1 $TARGET_AGENTS); do
                # 随机选择资源类型
                resource_type_num=$((1 + RANDOM % 4))
                resource_type=""
                stress_command=""

                case $resource_type_num in
                    1) resource_type="CPU"
                       workers=$(( CURRENT_POWER / 2 + 1 )) # 力量越高，核心越多
                       stress_command="stress-ng --cpu $workers --cpu-method matrixprod --timeout ${STRESS_TEST_DURATION}s --metrics --quiet --perf -q --process-name 'stress-ng --chaos-agent-cpu'"
                       ;;
                    2) resource_type="RAM"
                       mem_mb=$(( CURRENT_POWER * 50 + 100 )) # 力量越高，内存越多
                       stress_command="stress-ng --vm 1 --vm-bytes ${mem_mb}M --timeout ${STRESS_TEST_DURATION}s --metrics --quiet --perf -q --process-name 'stress-ng --chaos-agent-mem'"
                       ;;
                    3) resource_type="IO"
                       io_rate=$(( CURRENT_POWER * 20 + 100 )) # 力量越高，I/O速度越快
                       stress_command="stress-ng --io 1 --timeout ${STRESS_TEST_DURATION}s --metrics --quiet --perf -q --process-name 'stress-ng --chaos-agent-io'"
                       ;;
                    4) resource_type="NET"
                       net_conn=$(( CURRENT_POWER / 5 + 1 )) # 力量越高，连接越多
                       stress_command="stress-ng --net-io $net_conn --timeout ${STRESS_TEST_DURATION}s --metrics --quiet --perf -q --process-name 'stress-ng --chaos-agent-net'"
                       ;;
                esac
                
                log_message "${CYAN}正在启动混沌代理：力量 ${CURRENT_POWER} 级别下的 $resource_type 压力。${NC}"
                
                # 在后台启动 stress-ng，并进行一些基本的“学习”
                if (( has_stress_ng == 1 )); then
                    (
                        timeout "${STRESS_TEST_DURATION}s" "$stress_command" &> /dev/null
                        EXIT_CODE=$?
                        if (( EXIT_CODE == 0 )) || (( EXIT_CODE == 124 )); then # 0: 正常退出，124: timeout命令正常退出
                            # 成功运行，增加力量（有随机性）
                            NEW_POWER=$(awk -v cp="$CURRENT_POWER" -v rb="$RAND_SUCCESS_BOOST" 'BEGIN {print int(cp + (cp * rb))}')
                            set_chaos_power "$NEW_POWER"
                            log_message "${GREEN}混沌代理成功压榨 ${resource_type}！力量增长到 ${NEW_POWER}${NC}"
                        else
                            # 运行失败，减少力量（模拟学习和调整）
                            NEW_POWER=$(awk -v cp="$CURRENT_POWER" -v dd="$RAND_FAILURE_DROP" 'BEGIN {print int(cp - (cp * dd))}')
                            set_chaos_power "$NEW_POWER"
                            log_message "${RED}混沌代理压榨 ${resource_type} 失败 (Exit $EXIT_CODE)！力量衰减到 ${NEW_POWER}${NC}"
                        fi
                    ) & # 每一个 stress-ng 作为一个独立的子进程在后台运行
                else
                    log_message "${RED}stress-ng 未安装，回退到简陋模式：仅模拟 CPU 负载${NC}"
                    (
                        # 简陋的 CPU 负载模拟
                        END_TIME=$(( SECONDS + STRESS_TEST_DURATION ))
                        while (( SECONDS < END_TIME )); do
                            _ignored_var=$(( RANDOM * RANDOM )) # 无意义的计算
                        done
                        # 简单地每次成功都增加力量
                        NEW_POWER=$(awk -v cp="$CURRENT_POWER" -v rb="$RAND_SUCCESS_BOOST" 'BEGIN {print int(cp + (cp * rb))}')
                        set_chaos_power "$NEW_POWER"
                        log_message "${GREEN}混沌代理 (简陋版) 模拟压榨 CPU 成功！力量增长到 ${NEW_POWER}${NC}"
                    ) &
                fi
                sleep 0.1 # 短暂暂停，避免在主循环中同时启动太多
            done

            # 根据力量值动态调整休眠间隔，力量值越高，间隔越短，检查越频繁
            # INTERVAL=$(awk -v bp="$BASE_INTERVAL" -v mp="$MAX_POWER" -v cp="$CURRENT_POWER" -v mi="$MIN_INTERVAL" 'BEGIN {val = bp - (bp * (cp / mp) * 0.8); if (val < mi) print mi; else print val}')
            # 使用更平滑的逆向计算，确保最小值
            INTERVAL=$(echo "scale=2; $BASE_INTERVAL - ($BASE_INTERVAL - $MIN_INTERVAL) * ($CURRENT_POWER / $MAX_POWER)" | bc -l)
            if (( $(echo "$INTERVAL < $MIN_INTERVAL" | bc -l) )); then INTERVAL=$MIN_INTERVAL; fi

            log_message "${YELLOW}等待 ${INTERVAL} 秒后再次迭代...${NC}"
            sleep "$INTERVAL"
        done
    ) &
    PID=$!
    echo "$PID" > "$CHAOS_MODE_PID_FILE"
    log_message "${GREEN}混沌模式已在后台启用 (PID: $PID)。请注意系统资源占用！${NC}"
    log_message "${YELLOW}您可以通过选择菜单选项 6 (退出脚本) 或手动运行 '${NC}${CYAN}kill $PID${NC}${YELLOW}' 并运行 '${NC}${CYAN}pkill -f 'stress-ng --chaos-agent'${NC}${YELLOW}' 来终止它。${NC}"
    pause_and_return
}

# =========================================================================
# 主菜单循环 - 程序的入口点
# =========================================================================
while true; do
    clear
    echo -e "============================================"
    echo -e "${GREEN}=== 脚本由你的名字免费开源，分享自由 ===${NC}"
    echo -e "${YELLOW}=== MyAwesomeScript 通用管理菜单 ===${NC}"
    echo -e "============================================"
    echo -e "${BLUE}1. 初始化并运行应用程序/服务${NC}"
    echo -e "${BLUE}2. 查看应用程序/脚本日志${NC}"
    echo -e "${BLUE}3. 管理应用程序服务（手动启动/周期性检查）${NC}"
    echo -e "${BLUE}4. 更新我的应用程序/脚本${NC}"
    echo -e "${BLUE}5. 卸载/清理应用程序数据${NC}"
    echo -e "${RED}--- 危险实验区域 ---${NC}"
    echo -e "${PURPLE}6. 启用混沌模式（模拟资源占用与自我强化）${NC}"
    echo -e "${PURPLE}7. 禁用混沌模式${NC}"
    echo -e "${RED}8. 退出脚本${NC}"
    echo -e "============================================"
    echo -e "${YELLOW}请输入您的选择（1-8）：${NC}"
    read -r choice

    case $choice in
        1)
            init_and_run_app
            pause_and_return
            ;;
        2)
            view_logs
            pause_and_return # 在tail -f返回后会等待
            ;;
        3)
            manage_app_service
            ;;
        4)
            update_my_app
            pause_and_return
            ;;
        5)
            uninstall_my_app
            pause_and_return
            ;;
        6)
            enable_chaos_mode
            ;;
        7)
            disable_chaos_mode
            pause_and_return
            ;;
        8)
            log_message "${YELLOW}退出脚本...${NC}"
            exit 0
            ;;
        *)
            log_message "${RED}无效的选择，请输入 1-8。${NC}"
            pause_and_return
            ;;
    esac
done
