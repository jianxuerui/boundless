#!/bin/bash
# Nexus 多节点管理脚本
# 作者：哈哈哈哈 (Twitter: @ferdie_jhovie)
# 这是一个免费开源的脚本，请勿相信任何收费宣传。

# 启用严格模式，遇到错误立即退出，对未设置的变量报错，管道中任何命令失败都算作失败
set -euo pipefail

# === 全局变量定义 ===
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs"
SCRIPT_TMP_DIR="/tmp/nexus_script_build" # 用于 Dockerfile 和 entrypoint 文件的临时目录

# === Dockerfile 内容定义 ===
# 注意：screen 的使用在 Docker 最佳实践中不常见，因为它引入了额外的进程管理层。
# 通常，Docker 容器设计为运行一个前台主进程。
# 此处保留 screen 是为了兼容原脚本的逻辑，如果 nexus-network 本身就会后台运行或需要额外的TTY。
# 如果 nexus-network start 是一个阻塞命令且输出到stdout，则可以简化 Dockerfile 和 entrypoint.sh。
DOCKERFILE_CONTENT=$(cat <<'EOF'
FROM ubuntu:24.04

ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id

RUN apt-get update -q && apt-get install -y --no-install-recommends \
    curl \
    screen \
    bash \
    procps \
    && rm -rf /var/lib/apt/lists/*

# 自动下载安装最新版 nexus-network
# 使用 PROXY 环境变量，便于在特定网络环境下设置代理
# curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh
# NOTE: Removed proxy for public version to avoid breaking for most users, add if needed.
RUN curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh \
    && ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
EOF
)

# === entrypoint.sh 内容定义 ===
ENTRYPOINT_CONTENT=$(cat <<'EOF'
#!/bin/bash
set -eo pipefail

PROVER_ID_FILE="/root/.nexus/node-id"

if [ -z "${NODE_ID}" ]; then
    echo "错误：未设置 NODE_ID 环境变量"
    exit 1
fi

echo "${NODE_ID}" > "${PROVER_ID_FILE}"
echo "使用的 node-id: ${NODE_ID}"

if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 未安装或不可用"
    exit 1
fi

# 检查并清理旧的 screen 会话
# -ls 会列出所有会话，-q 安静模式不输出，只返回状态码
screen -S nexus -X quit >/dev/null 2>&1 || true

echo "启动 nexus-network 节点..."
# screen -dmS nexus bash -c "nexus-network start --node-id ${NODE_ID} &>> /root/nexus.log"
# 更改为直接在前台运行并输出到 stdout/stderr，Docker 自动收集日志，更符合 Docker 理念。
# 但为了兼容原脚本中明确指定的 /root/nexus.log 文件写入，仍然通过 bash -c 将输出重定向。
# 注意：如果 nexus-network start 本身就是前台阻塞并输出到stdout的，那就不需要screen和重定向了。
# 此处仍保留原逻辑，以确保日志文件写入行为与原始脚本保持一致。
# docker log会抓取/dev/stdout的内容，通过tail -f让容器主进程持续运行并收集日志。
nexus-network start --node-id "${NODE_ID}" &>> /root/nexus.log &
NEXUS_PID=$!
echo "Nexus Network 进程已在后台启动，PID: $NEXUS_PID"

# 简短的延迟，让 nexus 进程有机会启动并写入一些日志
sleep 5

# 检查 nexus 进程是否存活
if ps -p "$NEXUS_PID" > /dev/null; then
    echo "节点已在后台启动。日志文件：/root/nexus.log"
    echo "可以使用 docker logs \$CONTAINER_NAME 或 tail -f /root/nexus.log 查看日志"
else
    echo "节点启动失败，请检查 /root/nexus.log"
    # Cat the last 50 lines for immediate debugging
    tail -n 50 /root/nexus.log || true
    exit 1
fi

# 保持容器运行，并通过tail -f显示日志
echo "==== 实时日志 (Press Ctrl+C to exit) ===="
tail -f /root/nexus.log

# 在 tail 退出时（如 Ctrl+C），等待 nexus 进程结束或终止它
kill $NEXUS_PID 2>/dev/null || true
echo "容器退出..."

EOF
)


# === 辅助函数 ===

# 显示一条彩色消息
function echo_color() {
    local color="$1"
    local message="$2"
    case "$color" in
        "red")    echo -e "\033[31m${message}\033[0m" ;;
        "green")  echo -e "\033[32m${message}\033[0m" ;;
        "yellow") echo -e "\033[33m${message}\033[0m" ;;
        "blue")   echo -e "\033[34m${message}\033[0m" ;;
        *)        echo "${message}" ;; # default
    esac
}

# 提示用户按任意键继续
function press_any_key() {
    echo "" # Add a newline for better readability
    read -rp "$(echo_color blue "按任意键返回菜单...")"
}

# 从用户那里获取多个 node-id
function get_node_ids_from_user() {
    local __result_arr_name=$1
    local ids_array=()
    echo ""
    echo_color blue "---------------------------------------------------------"
    echo_color blue "请输入多个 node-id，每行一个，输入空行后按 Ctrl+D 结束输入："
    echo_color blue "(Node ID 是唯一的，类似于您的账户标识。请妥善保管和使用。)"
    echo_color blue "---------------------------------------------------------"
    
    local line_count=0
    while IFS= read -r line; do
        if [ -z "$line" ]; then
            continue # Allow empty lines during input, but don't store them
        fi
        ids_array+=("$line")
        line_count=$((line_count+1))
        echo "已输入: $line (共 $line_count 个)"
    done

    if [ ${#ids_array[@]} -eq 0 ]; then
        echo_color yellow "未输入任何有效的 node-id。"
        # Do not return immediately here; let the caller handle the empty array
    fi
    # 使用 nameref 或 global assignment 传回数组
    if [[ -n "${__result_arr_name}" ]]; then
        eval "${__result_arr_name}=($(printf "'%s' " "${ids_array[@]}"))"
    fi
}


# 检查 Docker 是否安装
function check_docker() {
    echo_color blue "=== 检查 Docker 安装状态 ==="
    if ! command -v docker >/dev/null 2>&1; then
        echo_color yellow "检测到未安装 Docker，正在安装..."
        apt update -qq
        apt install -y apt-transport-https ca-certificates curl software-properties-common
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
        apt update -qq
        apt install -y docker-ce docker-ce-cli containerd.io
        systemctl enable docker
        systemctl start docker
        if command -v docker >/dev/null 2>&1; then
            echo_color green "Docker 安装成功并已启动。"
        else
            echo_color red "Docker 安装失败，请检查日志并手动安装。"
            exit 1
        fi
    else
        echo_color green "Docker 已安装。"
    fi
    docker info >/dev/null 2>&1 || { echo_color red "Docker 服务未运行或当前用户无权限。请尝试 'sudo systemctl start docker' 或将用户加入 'docker' 组。"; exit 1; }
    echo ""
}

# 检查 Node.js/npm/pm2 是否安装
function check_pm2() {
    echo_color blue "=== 检查 Node.js/npm/pm2 安装状态 ==="
    if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
        echo_color yellow "检测到未安装 Node.js/npm，正在安装 Node.js 18.x..."
        # Remove old nodesource entry if exists
        rm -f /etc/apt/sources.list.d/nodesource.list
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
        apt-get install -y nodejs
        if ! command -v node >/dev/null 2>&1; then
            echo_color red "Node.js 安装失败，请检查日志。"
            exit 1
        fi
        echo_color green "Node.js/npm 安装成功。"
    else
        echo_color green "Node.js/npm 已安装。"
    fi

    if ! command -v pm2 >/dev/null 2>&1; then
        echo_color yellow "检测到未安装 pm2，正在安装..."
        npm install -g pm2
        if ! command -v pm2 >/dev/null 2>&1; then
            echo_color red "pm2 安装失败，请检查日志。"
            exit 1
        fi
        echo_color green "pm2 安装成功。"
        pm2 save >/dev/null 2>&1 || true # Save process list for future restarts
    else
        echo_color green "pm2 已安装。"
    fi
    echo ""
}

# 构建docker镜像函数
function build_image() {
    echo_color blue "=== 构建 Docker 镜像 ==="
    # 使用一个确定性的临时目录，并设置trap确保清理
    mkdir -p "$SCRIPT_TMP_DIR"
    # 在脚本退出时自动清理临时目录
    trap "rm -rf '$SCRIPT_TMP_DIR'" EXIT

    echo "${DOCKERFILE_CONTENT}" > "${SCRIPT_TMP_DIR}/Dockerfile"
    echo "${ENTRYPOINT_CONTENT}" > "${SCRIPT_TMP_DIR}/entrypoint.sh"

    if docker build -t "$IMAGE_NAME" "$SCRIPT_TMP_DIR"; then
        echo_color green "Docker 镜像 '$IMAGE_NAME' 构建成功。"
    else
        echo_color red "Docker 镜像构建失败，请检查上述错误信息。"
        exit 1
    fi
    echo ""
}

# 启动容器（挂载宿主机日志文件）
function run_container() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo_color blue "--- 正在准备启动容器 '$container_name' ---"
    
    # 停止并删除可能存在的旧容器
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo_color yellow "检测到旧容器 '$container_name'，先停止并删除..."
        docker rm -f "$container_name"
    fi

    # 确保日志目录存在
    mkdir -p "$LOG_DIR"
    
    # 确保宿主机日志文件存在并有写权限
    # 检查 $log_file 是否是目录，如果是，先删除
    if [ -d "$log_file" ]; then
        echo_color yellow "警告：日志文件路径 '$log_file' 冲突，检测到同名目录。正在删除该目录..."
        rm -rf "$log_file"
    fi
    if [ ! -f "$log_file" ]; then
        touch "$log_file"
        chmod 644 "$log_file"
    fi

    echo "正在启动容器 '$container_name'..."
    if docker run -d --name "$container_name" -v "$log_file":/root/nexus.log -e NODE_ID="$node_id" "$IMAGE_NAME"; then
        echo_color green "容器 '$container_name' 已启动！"
    else
        echo_color red "容器 '$container_name' 启动失败。请检查 Docker 日志或运行 'docker logs $container_name' 查看详情。"
    fi
}

# 停止并卸载容器和镜像、删除日志
function uninstall_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "停止并删除容器 '$container_name'..."
    # Suppress output if container doesn't exist to make it cleaner
    if docker rm -f "$container_name" >/dev/null 2>&1; then
        echo_color green "容器 '$container_name' 已删除。"
    else
        echo_color yellow "容器 '$container_name' 不存在或已停止，跳过删除。"
    fi

    if [ -f "$log_file" ]; then
        echo "删除日志文件 '$log_file'..."
        rm -f "$log_file"
    else
        echo_color yellow "日志文件不存在：'$log_file'，跳过删除。"
    fi

    echo_color green "节点 '$node_id' 已卸载完成。"
}

# 显示所有运行中的节点
function list_nodes() {
    echo_color blue "=== 当前 Nexus 节点状态 ==="
    
    local all_nodes_count=$(get_all_nodes | wc -l)
    if [ "$all_nodes_count" -eq 0 ]; then
        echo_color yellow "当前未发现任何 Nexus 节点容器。"
        press_any_key
        return
    fi

    echo_color blue "------------------------------------------------------------------------------------------------------------------------"
    printf "%-6s %-20s %-15s %-12s %-12s %-10s %-25s\n" "序号" "节点ID" "状态" "CPU使用率" "内存使用" "内存限制" "创建时间"
    echo_color blue "------------------------------------------------------------------------------------------------------------------------"
    
    local all_nodes=($(get_all_nodes)) # Use subshell to convert output to array
    local found_running_or_exited=false

    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        
        local container_status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}" 2>/dev/null | head -n 1)
        local container_created=$(docker ps -a --filter "name=$container_name" --format "{{.CreatedAt}}" 2>/dev/null | head -n 1)

        local cpu_usage="N/A"
        local mem_usage="N/A"
        local mem_limit="N/A"

        # 尝试获取 docker stats。stats只对运行中的容器有效。
        if [[ "$container_status" == Up* ]]; then
            local stats_output=$(docker stats --no-stream --format "{{.CPUPerc}}::{{.MemUsage}}" "$container_name" 2>/dev/null)
            if [ -n "$stats_output" ]; then
                IFS='::' read -r cpu_percent mem_full <<< "$stats_output"
                cpu_usage="$cpu_percent"
                
                # Split memory usage string (e.g., "1.23MiB / 2GiB")
                # Using 'cut' for simplicity or 'sed' for more complex cases
                local parts=($mem_full)
                mem_usage="${parts[0]} ${parts[1]}" # e.g. "1.23 MiB"
                mem_limit="${parts[3]} ${parts[4]}" # e.g. "2 GiB" (if parts[2] is '/')
            fi
        fi

        # Color the status output
        local display_status_color=""
        local display_status=$(echo "$container_status" | cut -d' ' -f1) # Get first word like "Up" or "Exited"
        if [[ "$display_status" == "Up" ]]; then
            display_status_color=$(echo_color green "${container_status}")
        elif [[ "$display_status" == "Exited" ]]; then
            display_status_color=$(echo_color red "${container_status}")
        else
            display_status_color=$(echo_color yellow "${container_status}")
        fi
        
        if [ -n "$container_status" ]; then
            found_running_or_exited=true
            printf "%-6d %-20s %-25s %-12s %-12s %-10s %-25s\n" \
                $((i+1)) \
                "$node_id" \
                "$(echo "$display_status_color" | sed 's/\x1b\[[0-9;]*m//g' )" "$cpu_usage" "$mem_usage" "$mem_limit" "$container_created"
        fi
    done
    
    if [ "$found_running_or_exited" == "false" ]; then
        echo_color yellow "没有找到任何符合命名规则的 Nexus 节点容器 (可能已手动删除)。"
    fi
    echo_color blue "------------------------------------------------------------------------------------------------------------------------"
    echo "提示："
    echo "- CPU使用率：显示容器CPU使用百分比"
    echo "- 内存使用：显示容器当前使用的内存"
    echo "- 内存限制：显示容器内存使用限制 (仅在Docker分配了特定限制时显示)"
    echo "- 状态：显示容器的运行状态 ('Up' 表示运行中, 'Exited' 表示已停止/退出)"
    echo "- 创建时间：显示容器的创建时间"
    press_any_key
}

# 获取所有节点ID（包括已停止的）
function get_all_nodes() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort
}

# 查看节点日志
function view_node_logs() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    echo_color blue "=== 查看节点 ${node_id} 日志 ==="
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo_color red "容器 '$container_name' 不存在。请确认节点ID正确或容器已启动。"
        press_any_key
        return
    fi

    if docker ps -a --filter "name=$container_name" --filter "status=running" --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "请选择日志查看模式："
        echo "1. 原始日志（可能包含颜色代码）"
        echo "2. 清理后的日志（移除颜色代码）"
        read -rp "$(echo_color blue "请选择(1-2): ")" log_mode

        echo_color yellow "正在加载日志，按 Ctrl+C 退出实时日志查看。"
        echo "---------------------------------------------------"
        if [ "$log_mode" = "2" ]; then
            # Clean up ANSI escape codes, including cursor positioning
            docker logs -f "$container_name" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})*)?m//g" | sed 's/\x1b\[?25l//g; s/\x1b\[?25h//g'
        else
            docker logs -f "$container_name"
        fi
        echo "---------------------------------------------------"
    else
        echo_color yellow "容器 '$container_name' 未运行，将尝试显示历史日志。"
        echo "---------------------------------------------------"
        local log_file_on_host="${LOG_DIR}/nexus-${node_id}.log"
        if [ -f "$log_file_on_host" ]; then
            tail -n 50 "$log_file_on_host" || echo_color red "无法读取日志文件或文件为空: $log_file_on_host"
        else
            echo_color red "宿主机上找不到日志文件: $log_file_on_host"
            echo "尝试从容器内部获取历史日志（如果容器日志驱动器保留了）。"
            docker logs "$container_name" || echo_color red "无法从停止的容器中获取日志。"
        fi
        echo "---------------------------------------------------"
    fi
    press_any_key
}

# 选择要查看的节点
function select_node_to_view() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo_color yellow "当前没有可供操作的节点。"
        press_any_key
        return
    fi

    echo_color blue "=== 选择要查看日志的节点 ==="
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status_str="[未知状态]"
        if docker ps -a --filter "name=$container_name" --format '{{.Status}}' | grep -q 'Up'; then
            status_str=$(echo_color green "[运行中]")
        elif docker ps -a --filter "name=$container_name" --format '{{.Status}}' | grep -q 'Exited'; then
            status_str=$(echo_color red "[已停止]")
        else
            status_str=$(echo_color yellow "[不存在/其他]")
        fi
        printf "%-6d. %-20s %s\n" $((i+1)) "$node_id" "$status_str"
    done

    local choice
    read -rp "$(echo_color blue "请输入选项(0-${#all_nodes[@]}): ")" choice

    if [ "$choice" = "0" ]; then
        return
    fi

    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
        local selected_node=${all_nodes[$((choice-1))]}
        view_node_logs "$selected_node"
    else
        echo_color red "无效的选项：'$choice'。请输入列表中对应的数字。"
        press_any_key
    fi
}

# 批量启动多个节点
function batch_start_nodes() {
    echo_color blue "=== 批量启动多个 Nexus 节点 ==="
    local node_ids=()
    get_node_ids_from_user node_ids # 收集 node-id 到 ids_array 变量

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo_color yellow "未输入任何 node-id，已取消批量启动操作。"
        press_any_key
        return
    fi

    echo_color blue "开始构建镜像 (如果需要或尚未构建)..."
    build_image

    echo_color blue "开始启动节点..."
    local start_count=0
    for node_id in "${node_ids[@]}"; do
        run_container "$node_id"
        start_count=$((start_count+1))
        # 进度提示
        echo "已启动 ${start_count}/${#node_ids[@]} 个节点..."
        sleep 1 # 添加短暂延迟，避免同时启动太多容器对系统造成冲击
    done

    echo_color green "所有指定节点启动完成！"
    echo_color blue "使用 '2. 显示所有节点状态' 查看节点信息。"
    press_any_key
}

# 批量停止并卸载节点
function batch_uninstall_nodes() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo_color yellow "当前没有可供卸载的节点。"
        press_any_key
        return
    fi

    echo_color blue "=== 批量卸载指定 Nexus 节点 ==="
    echo "当前节点列表："
    echo_color blue "----------------------------------------"
    echo_color blue "序号  节点ID                状态"
    echo_color blue "----------------------------------------"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status_str="[未知状态]"
        if docker ps -a --filter "name=$container_name" --format '{{.Status}}' | grep -q 'Up'; then
            status_str=$(echo_color green "[运行中]")
        elif docker ps -a --filter "name=$container_name" --format '{{.Status}}' | grep -q 'Exited'; then
            status_str=$(echo_color red "[已停止]")
        else
            status_str=$(echo_color yellow "[不存在/其他]")
        fi
        printf "%-6d %-20s %s\n" $((i+1)) "$node_id" "$status_str"
    done
    echo_color blue "----------------------------------------"

    echo "请选择要卸载的节点（可多选，输入数字，用空格分隔）："
    echo_color red "警告：此操作将永久删除节点数据（日志文件）和Docker容器，无法恢复！"
    echo "0. 返回主菜单"
    
    local choices_input
    read -rp "$(echo_color blue "请输入选项(0 或 数字，用空格分隔): ")" choices_input

    if [ "$choices_input" = "0" ]; then
        echo_color yellow "已取消批量卸载操作。"
        press_any_key
        return
    fi

    # 将输入的选项转换为数组
    local selected_indices=()
    read -ra selected_indices <<< "$choices_input" # Reads into an array, splitting by whitespace

    # 过滤掉重复和无效的选项
    local unique_selected_indices=()
    for index in "${selected_indices[@]}"; do
        if [[ "$index" =~ ^[0-9]+$ ]] && [ "$index" -ge 1 ] && [ "$index" -le ${#all_nodes[@]} ]; then
            # Add to unique list only if not already present
            local found=false
            for u_index in "${unique_selected_indices[@]}"; do
                if [ "$u_index" == "$index" ]; then
                    found=true
                    break
                fi
            done
            if [ "$found" == false ]; then
                unique_selected_indices+=("$index")
            fi
        else
            echo_color yellow "跳过无效或重复的选项: '$index'"
        fi
    done

    if [ ${#unique_selected_indices[@]} -eq 0 ]; then
        echo_color yellow "未选择任何有效节点，已取消批量卸载操作。"
        press_any_key
        return
    fi

    echo ""
    echo_color yellow "您确定要卸载以下 ${#unique_selected_indices[@]} 个节点吗？"
    for choice in "${unique_selected_indices[@]}"; do
        local selected_node=${all_nodes[$((choice-1))]}
        echo_color yellow "- ${selected_node}"
    done
    read -rp "$(echo_color red "输入 'yes' 确认卸载，否则将取消: ")" confirm
    if [[ ! "$confirm" == "yes" ]]; then
        echo_color yellow "已取消批量卸载操作。"
        press_any_key
        return
    fi

    echo_color blue "开始卸载选定节点..."
    for choice in "${unique_selected_indices[@]}"; do
        local selected_node=${all_nodes[$((choice-1))]}
        uninstall_node "$selected_node"
        sleep 0.5 # Give a small breather between deletions
    done

    echo_color green "批量卸载完成！"
    press_any_key
}

# 删除全部节点
function uninstall_all_nodes() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo_color yellow "当前没有可供删除的节点。"
        press_any_key
        return
    fi

    echo_color red "!!! 严重警告：此操作将删除所有 Nexus 节点相关数据和 Docker 容器 !!!"
    echo_color red "!!! 确定删除后将无法恢复，请谨慎操作！！！"
    echo "当前共有 ${#all_nodes[@]} 个节点将被删除："
    for node_id in "${all_nodes[@]}"; do
        echo_color yellow "- $node_id"
    done
    
    read -rp "$(echo_color red "确定要删除所有节点吗？(输入 'yes' 确认): ")" confirm
    if [[ ! "$confirm" == "yes" ]]; then
        echo_color yellow "已取消操作。"
        press_any_key
        return
    fi

    echo_color blue "开始删除所有节点..."
    # Stop and remove all managed Docker containers
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format '{{.Names}}' | while read -r container_name; do
        echo "正在停止并删除容器 '$container_name'..."
        docker rm -f "$container_name" || echo_color yellow "警告：无法删除容器 '$container_name'。"
    done
    
    # Remove all managed log files
    if [ -d "$LOG_DIR" ]; then
        echo "删除日志目录 '$LOG_DIR' 下的所有Nexus日志文件..."
        find "$LOG_DIR" -type f -name "nexus-*.log" -delete || echo_color yellow "警告：无法删除部分日志文件。"
    fi

    # Optionally remove the Docker image itself
    if docker images -q "$IMAGE_NAME" | grep -q .; then
        read -rp "$(echo_color yellow "是否同时删除 Nexus Docker 镜像 '$IMAGE_NAME'？(y/N): ")" delete_image_confirm
        if [[ "$delete_image_confirm" =~ ^[Yy]$ ]]; then
            echo "正在删除 Docker 镜像 '$IMAGE_NAME'..."
            docker rmi "$IMAGE_NAME" || echo_color yellow "警告：无法删除 Docker 镜像 '$IMAGE_NAME' (可能被其他容器使用)。"
        fi
    fi

    # Optionally clean up the scripts directory if rotation was used
    local script_dir="/root/nexus_scripts"
    if [ -d "$script_dir" ]; then
        read -rp "$(echo_color yellow "是否删除节点轮换脚本目录 '$script_dir' 和 pm2 进程？(y/N): ")" clean_script_confirm
        if [[ "$clean_script_confirm" =~ ^[Yy]$ ]]; then
            echo "停止并删除 pm2 进程 'nexus-rotate'..."
            pm2 delete nexus-rotate >/dev/null 2>&1 || true
            pm2 save >/dev/null 2>&1 || true
            echo "删除脚本目录 '$script_dir'..."
            rm -rf "$script_dir"
        fi
    fi

    echo_color green "所有 Nexus 节点已删除完成！"
    press_any_key
}

# 批量节点轮换启动的核心脚本
# 注意：此函数将生成一个PM2控制的Bash脚本，该脚本将管理轮换逻辑。
# 它不是一个传统的轮换负载均衡，而是定期停止所有当前节点，然后启动一个新的节点子集。
function batch_rotate_nodes() {
    echo_color blue "=== 批量节点轮换启动 ==="
    check_pm2 # pm2 是运行轮换任务所必需的

    local all_input_node_ids=()
    get_node_ids_from_user all_input_node_ids # 收集 node-id 到 all_input_node_ids 变量

    if [ ${#all_input_node_ids[@]} -eq 0 ]; then
        echo_color yellow "未输入任何 node-id，已取消批量轮换操作。"
        press_any_key
        return
    fi

    # 过滤掉重复的 node-id，确保每个ID只使用一次
    # Using `mapfile` to directly populate array with unique sorted IDs
    local unique_node_ids_arr=()
    mapfile -t unique_node_ids_arr < <(printf "%s\n" "${all_input_node_ids[@]}" | sort -u)

    local total_nodes=${#unique_node_ids_arr[@]}

    echo ""
    echo_color yellow "检测到 $total_nodes 个唯一 Node ID，它们将被用于轮换。"
    read -rp "$(echo_color blue "请输入每轮要运行的节点数量（默认：${total_nodes}的一半，向上取整；最少1个）: ")" nodes_per_round_input
    
    local nodes_per_round
    if [ -z "$nodes_per_round_input" ]; then
        nodes_per_round=$(( (total_nodes + 1) / 2 )) # Default to half, rounded up
    elif [[ "$nodes_per_round_input" =~ ^[0-9]+$ ]] && [ "$nodes_per_round_input" -ge 1 ] && [ "$nodes_per_round_input" -le "$total_nodes" ]; then
        nodes_per_round="$nodes_per_round_input"
    else
        echo_color red "无效的节点数量。请输入1到$total_nodes之间的整数。"
        press_any_key
        return
    fi

    read -rp "$(echo_color blue "请输入每轮轮换间隔时间（小时，默认：2小时；最少1小时）: ")" rotate_interval_hours_input
    local rotate_interval_hours
    if [ -z "$rotate_interval_hours_input" ]; then
        rotate_interval_hours=2 # Default to 2 hours
    elif [[ "$rotate_interval_hours_input" =~ ^[0-9]+$ ]] && [ "$rotate_interval_hours_input" -ge 1 ]; then
        rotate_interval_hours="$rotate_interval_hours_input"
    else
        echo_color red "无效的轮换间隔时间。请输入大于等于1的整数小时数。"
        press_any_key
        return
    fi
    local rotate_interval_seconds=$(( rotate_interval_hours * 3600 ))

    echo ""
    echo_color yellow "--- 轮换设置摘要 ---"
    echo "总共节点数：$total_nodes"
    echo "每轮运行节点数：$nodes_per_round"
    echo "每轮轮换间隔：${rotate_interval_hours} 小时"
    echo_color yellow "--------------------"

    read -rp "$(echo_color red "确定要开始节点轮换吗？此操作将停止所有现有Nexus容器。(输入 'yes' 确认): ")" confirm
    if [[ ! "$confirm" == "yes" ]]; then
        echo_color yellow "已取消轮换操作。"
        press_any_key
        return
    fi

    echo_color blue "开始构建镜像 (如果需要或尚未构建)..."
    build_image

    # 清理旧的 pm2 进程
    echo_color yellow "停止并删除旧的轮换进程 'nexus-rotate' (如果存在)..."
    pm2 delete nexus-rotate 2>/dev/null || true

    # 创建启动脚本目录
    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir"
    chmod 700 "$script_dir" # Secure permissions

    # 生成轮换主脚本 `rotate.sh`
    # 此脚本将由 pm2 运行
    cat > "$script_dir/rotate.sh" <<EOF
#!/bin/bash
set -euo pipefail

BASE_CONTAINER_NAME="${BASE_CONTAINER_NAME}"
IMAGE_NAME="${IMAGE_NAME}"
LOG_DIR="${LOG_DIR}"
TOTAL_NODE_IDS=( ${unique_node_ids_arr[@]/#/ } ) # Make a shell array with correct quoting
NODES_PER_ROUND=${nodes_per_round}
ROTATE_INTERVAL_SECONDS=${rotate_interval_seconds}
TOTAL_NODES_COUNT=${total_nodes}

CURRENT_NODE_INDEX=0 # Global index to track starting node for current round

function log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] \$1"
}

function run_single_container() {
    local node_id="\$1"
    local container_name="\${BASE_CONTAINER_NAME}-\${node_id}"
    local log_file="\${LOG_DIR}/nexus-\${node_id}.log"

    mkdir -p "\${LOG_DIR}"
    if [ -d "\$log_file" ]; then rm -rf "\$log_file"; fi
    if [ ! -f "\$log_file" ]; then touch "\$log_file"; chmod 644 "\$log_file"; fi

    # Stop and remove if container already exists (even from previous failures)
    docker rm -f "\$container_name" >/dev/null 2>&1 || true

    log_message "    启动节点: \$node_id (容器: \$container_name)"
    docker run -d --name "\$container_name" -v "\$log_file":/root/nexus.log -e NODE_ID="\$node_id" "\$IMAGE_NAME" &> /dev/null
    
    # Small delay for container to start its process
    sleep 3
    
    if docker ps -a --format '{{.Names}}' | grep -qw "\$container_name"; then
        if docker inspect --format='{{.State.Running}}' "\$container_name" 2>/dev/null | grep -q "true"; then
            log_message "      节点 \$node_id 启动成功。"
        else
            log_message "      节点 \$node_id 启动，但未运行起来。检查 docker logs \$container_name。"
        fi
    else
        log_message "      节点 \$node_id 容器未成功创建！"
    fi
}

function stop_all_managed_containers() {
    log_message "停止并清理所有 Nexus 节点容器..."
    local containers_to_stop=""
    containers_to_stop=\$(docker ps -a --filter "name=\${BASE_CONTAINER_NAME}-" --format '{{.Names}}' | tr '\\n' ' ')
    if [ -n "\$containers_to_stop" ]; then
        docker rm -f \$containers_to_stop || true # Use rm -f to stop and remove in one go
        log_message "  所有旧容器已清理。"
    else
        log_message "  没有找到运行中的Nexus节点容器。"
    fi
}

while true; do
    log_message "=========================================================="
    log_message "新的轮换周期开始..."
    log_message "=========================================================="

    # 1. 停止并清理所有现有 managed 容器
    stop_all_managed_containers

    # 2. 确定本轮要激活的节点
    local current_round_nodes=()
    local i
    for (( i=0; i<NODES_PER_ROUND; i++ )); do
        local node_idx=\$((\$((\${CURRENT_NODE_INDEX} + i)) % \${TOTAL_NODES_COUNT}))
        current_round_nodes+=("\${TOTAL_NODE_IDS[\${node_idx}]}")
    done
    
    log_message "本轮将启动以下 ${#current_round_nodes[@]} 个节点: \${current_round_nodes[*]}"

    # 3. 启动本轮节点
    for node_id in "\${current_round_nodes[@]}"; do
        run_single_container "\$node_id"
    done

    log_message "本轮节点启动完毕。"
    log_message "更新下次启动索引: 从节点 ${current_round_nodes[0]} 开始 (实际索引 \$CURRENT_NODE_INDEX)"
    CURRENT_NODE_INDEX=\$(( (\${CURRENT_NODE_INDEX} + \${NODES_PER_ROUND}) % \${TOTAL_NODES_COUNT} ))
    
    log_message "----------------------------------------------------------"
    log_message "等待 \$((ROTATE_INTERVAL_SECONDS / 3600)) 小时进入下一轮轮换..."
    log_message "----------------------------------------------------------"
    sleep "\$ROTATE_INTERVAL_SECONDS"
done
EOF
)
    # 设置轮换脚本权限
    chmod +x "$script_dir/rotate.sh"

    # 使用 pm2 启动轮换脚本
    pm2 start "$script_dir/rotate.sh" --name "nexus-rotate" --output "$script_dir/rotate_output.log" --error "$script_dir/rotate_error.log"
    pm2 save

    echo_color green "节点轮换已启动并由 PM2 管理！"
    echo_color blue "总共 $total_nodes 个唯一节点，每轮启动 $nodes_per_round 个节点。"
    echo_color blue "每 ${rotate_interval_hours} 小时轮换一次，确保节点持续在线且循环运行。"
    echo_color blue "使用 'pm2 status' 查看 PM2 进程状态。"
    echo_color blue "使用 'pm2 logs nexus-rotate' 查看轮换进程的实时日志。"
    echo_color blue "使用 'pm2 stop nexus-rotate' 停止轮换， 'pm2 delete nexus-rotate' 删除轮换进程。"
    echo_color blue "注意：如果您想暂停，请使用 'pm2 stop nexus-rotate'；想要彻底移除，使用 'pm2 delete nexus-rotate' 后，请手动执行 6.删除全部节点 或 3.批量停止并卸载指定节点 再次清理已启动的容器。"

    press_any_key
}


# 设置定时清理日志任务（每2天清理一次，只保留最近2天的日志）
function setup_log_cleanup_cron() {
    echo_color blue "=== 设置日志清理定时任务 ==="
    # 清理日志，只保留最近2天的日志文件。确保 LOG_DIR 存在且是非空的，避免 `find` 错误
    local cron_job="# Nexus node log cleanup: Keep logs for 2 days. Created by nexus-node-manager.sh\n0 3 * * * find \"$LOG_DIR\" -maxdepth 1 -type f -name 'nexus-*.log' -mtime +2 -delete"

    # 检查是否已存在相同的定时任务（仅通过 grep -q 判断部分字符串，可能不精确，但足够）
    if crontab -l 2>/dev/null | grep -q "nexus-*.log -mtime +2 -delete"; then
        echo_color green "日志清理定时任务已存在，无需重复设置。"
    else
        # 追加或创建定时任务
        (crontab -l 2>/dev/null; echo -e "$cron_job") | crontab -
        echo_color green "已设置每2天自动清理过期 Nexus 日志的任务（保留最近2天）。"
    fi
    echo ""
}

# 主菜单
function main_menu() {
    setup_log_cleanup_cron # 每次启动脚本都确保定时任务已设置
    while true; do
        clear
        echo_color green "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
        echo_color green "如有问题，可联系推特，仅此只有一个号"
        echo ""
        echo_color blue "========== Nexus 多节点管理 =========="
        echo_color blue "1. 安装并启动新节点 (单个)"
        echo_color blue "2. 显示所有节点状态"
        echo_color blue "3. 批量停止并卸载指定节点"
        echo_color blue "4. 查看指定节点日志"
        echo_color blue "5. 批量节点轮换启动 (通过PM2实现循环启动新节点，旧节点被替换)"
        echo_color blue "6. 删除全部节点 (危险操作，慎用！)"
        echo_color blue "7. 退出"
        echo_color blue "==================================="

        read -rp "$(echo_color blue "请输入选项(1-7): ")" choice

        case $choice in
            1)
                check_docker
                read -rp "$(echo_color blue "请输入您的 node-id: ")" NODE_ID
                if [ -z "$NODE_ID" ]; then
                    echo_color red "node-id 不能为空，请重新输入。"
                    press_any_key
                    continue
                fi
                build_image
                run_container "$NODE_ID"
                echo_color green "单个节点 '$NODE_ID' 启动成功！请等待其数据同步。"
                press_any_key
                ;;
            2)
                list_nodes
                ;;
            3)
                batch_uninstall_nodes
                ;;
            4)
                select_node_to_view
                ;;
            5)
                check_docker
                batch_rotate_nodes
                ;;
            6)
                uninstall_all_nodes
                ;;
            7)
                echo_color blue "感谢使用，退出脚本。"
                exit 0
                ;;
            *)
                echo_color red "无效选项 '$choice'，请重新输入。"
                press_any_key
                ;;
        esac
    done
}

# === 脚本主入口 ===
main_menu
