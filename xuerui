#!/bin/bash
set -e

# ================================================================================================
# Nexus 多节点管理脚本 (ARM64 Docker) - v4.1.11 终端显示鲁棒性增强版
#
# 原作者: 哈哈哈哈 (推特 @ferdie_jhovie)
# 改版者: AI & 社区智慧
#
# 【V4.1.11 更新】:
#   - 【兼容性增强】: 进一步增强了脚本的终端显示鲁棒性。
#     - 将脚本内的多数彩色输出函数 (`print_color`, `print_bold`) 调用，
#       尝试统一为更不容易出错的 `printf` 格式。
#     - 重新审视了所有可能包含不安全字符或特殊结构的字符串，特别是用户输入的 Node ID，
#       以防止在输出或使用它们时引起 Shell 解析错误（如 EOF 错误）。
#
# ... (保留之前的 V4.1.10, V4.1.9, V4.1.8, V4.1.7, V4.1.6, V4.1.5, V4.1.4, V4.1.3, V4.1.2, V4.1.1, V4.0 更新说明) ...
# ================================================================================================

# --- 配置项 (可在此处自定义) ---
SCRIPT_VERSION="v4.1.11 终端显示鲁棒性增强版"
# --- 此处已更新 nexus-cli 版本 ---
NEXUS_CLI_VERSION="v0.10.7"
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest-arm64"
LOG_DIR="/root/nexus_logs"
BUILDER_NAME="nexus_builder"

# --- 颜色定义 ---
# Ensuring ANSI color codes are treated purely as strings.
COLOR_RESET='\033[0m'
COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[0;33m'
COLOR_BLUE='\033[0;34m'
COLOR_CYAN='\033[0;36m'
COLOR_BOLD='\033[1m' # 增加加粗颜色

# --- 辅助函数 ---
# Modified print_color to use printf internally for better control over string interpretation.
# The primary function now takes care of all the -e and escape processing.
print_color() {
    # Safely format and print the colored string.
    printf "%s%s%s\n" "$2" "$1" "$COLOR_RESET"
}
print_success() { print_color "$1" "$COLOR_GREEN"; }
print_error() { print_color "$1" "$COLOR_RED"; }
print_warning() { print_color "$1" "$COLOR_YELLOW"; }
print_info() { print_color "$1" "$COLOR_CYAN"; }
print_bold() { print_color "$1" "${COLOR_BOLD}${COLOR_CYAN}"; } # Using cyan bold for bold info

confirm_action() {
    local prompt_message="$1"
    # Ensure the prompt itself uses printf for consistency and safety.
    printf "${COLOR_YELLOW}>>> ${prompt_message} (y/N): ${COLOR_RESET}"
    local confirm="" # Initialize confirm variable
    read -r confirm
    [[ "$confirm" =~ ^[yY]([eE][sS])?$ ]]
}

# Initialize TMP_WORKDIR outside trap to ensure it's always set before mktemp is called
TMP_WORKDIR=""
# Trap for cleanup on exit, including common signals.
trap 'EXITCODE=$?; printf "\n"; print_info "Executing cleanup operations..."; rm -rf "$TMP_WORKDIR"; exit $EXITCODE' EXIT HUP INT QUIT TERM

# --- Core Functions ---
check_docker_daemon() {
    if ! docker info >/dev/null 2>&1; then
        print_error "!! 致命错误: Docker 服务未运行或当前用户无权访问 !!"
        if ! systemctl is-active docker >/dev/null 2>&1; then
            print_error "    Docker 服务 (${COLOR_YELLOW}docker${COLOR_RESET}) 状态: ${COLOR_RED} inactive/dead${COLOR_RESET}."
            print_error "    请尝试启动 Docker: ${COLOR_CYAN}sudo systemctl start docker${COLOR_RESET}"
            print_error "    并设为开机自启: ${COLOR_CYAN}sudo systemctl enable docker${COLOR_RESET}"
        else
            print_error "    Docker 服务 (${COLOR_YELLOW}docker${COLOR_RESET}) 正在运行，但当前用户可能没有权限访问。"
            print_error "    请确保脚本以 root 用户运行 (${COLOR_CYAN}sudo su${COLOR_RESET} 或 ${COLOR_CYAN}sudo ./your_script.sh${COLOR_RESET})。"
        fi
        exit 1
    fi
}

check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        print_warning "未检测到 Docker 命令, 正在尝试自动安装..."
        if ! dpkg --print-architecture | grep -q "arm64"; then
            print_error "!! 警告: 当前系统不是 ARM64 架构, 脚本主要为 ARM64 设计。安装可能失败或运行不兼容。!!"
        fi

        print_info "正在执行 Docker 安装准备步骤..."
        if ! apt-get update -qq; then
            print_warning "apt update 失败，可能影响 Docker 安装。请检查网络连接和软件源配置。"
        fi
        
        print_info "正在安装 Docker 所需的依赖包..."
        if ! apt-get install -y --no-install-recommends apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release >/dev/null 2>&1; then
            print_warning "部分依赖安装失败，Docker 安装可能受影响。"
        fi

        print_info "正在添加 Docker 的 GPG 签名密钥..."
        mkdir -p /etc/apt/keyrings
        # Use curl --fail to get a non-zero exit code on download failure.
        if ! curl -fsSL --fail https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg; then
             print_error "!! Docker GPG key 下载或处理失败 !! 这是安装 Docker 的关键步骤，脚本将终止。"
             exit 1
        fi
        # Ensure the file is not empty after operation.
        if [ ! -s /etc/apt/keyrings/docker.gpg ]; then
             print_error "!! Docker GPG key 文件 '/etc/apt/keyrings/docker.gpg' 创建失败或为空 !! 脚本将终止。"
             exit 1
        fi
        print_success "Docker GPG 密钥已成功添加到 /etc/apt/keyrings/。"

        print_info "正在配置 Docker 的 APT 软件源..."
        # Safely construct the source list line.
        echo \
          "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
          $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
        print_success "Docker APT 源配置完成。"

        print_info "正在更新 APT 软件包列表..."
        if ! apt-get update -qq; then
            print_warning "apt update 失败，可能影响 Docker CE 的安装。"
        fi
        
        print_info "正在安装 Docker CE (Community Edition)..."
        if ! apt-get install -y --no-install-recommends docker-ce docker-ce-cli containerd.io docker-buildx-plugin >/dev/null 2>&1; then
            print_error "!! Docker CE 安装失败 !! 脚本将终止，请检查以上错误信息。"
            exit 1
        fi
        print_success "Docker CE 及相关插件安装完成。"

        print_info "正在启动并启用 Docker 服务..."
        if ! systemctl is-active docker >/dev/null 2>&1; then
            if ! systemctl start docker; then
                print_error "Docker 服务启动失败！"
                print_error "请尝试手动启动: ${COLOR_CYAN}sudo systemctl start docker${COLOR_RESET}"
                exit 1
            fi
        fi
        if ! systemctl is-enabled docker >/dev/null 2>&1; then
             if ! systemctl enable docker; then
                print_warning "Docker 服务开机自启设置失败。请检查 systemctl。"
             fi
        fi
        print_success "Docker 服务已准备就绪。"
    fi

    # Verify docker buildx plugin existence and function.
    if ! docker buildx version >/dev/null 2>&1; then
        print_error "错误：未找到 Docker buildx 插件。这是构建多架构镜像的关键组件。"
        print_warning "正在尝试安装 'docker-buildx-plugin'..."
        if ! apt-get update -qq >/dev/null; then
            print_warning "apt update 失败，可能影响 buildx 插件安装。"
        fi
        if ! apt-get install -y --no-install-recommends docker-buildx-plugin >/dev/null 2>&1; then
             print_error "!! Docker buildx 插件安装失败 !! "
             print_error "   请尝试手动安装: ${COLOR_CYAN}sudo apt-get install docker-buildx-plugin${COLOR_RESET}"
             exit 1
        fi
        # Double check if buildx is available after installation.
        if ! docker buildx version >/dev/null 2>&1; then
            print_error "!! Docker buildx 插件安装后仍然无法使用。!! 脚本将无法继续，请手动检查 Docker 及 Buildx 安装。"
            exit 1
        fi
        print_success "Docker buildx 插件已成功安装。"
    fi
}

# --- SETUP BUILDX - ENHANCED WITH MORE DELIBERATE CLEANUP AND ERROR REPORTING ---
setup_buildx() {
    print_info "正在检查和配置 Buildx builder '$BUILDER_NAME'..."

    local builder_exists=0
    # Use a robust check to see if the builder *name* is listed.
    if docker buildx ls | grep -q "^${BUILDER_NAME}\s"; then
        builder_exists=1
        print_warning "检测到 Buildx builder '$BUILDER_NAME' 已存在。"
        
        print_info "强制尝试移除现有的 Buildx builder '$BUILDER_NAME'..."
        # Use `docker buildx rm "$BUILDER_NAME"` which should ideally handle known states.
        # Redirect output and suppress errors that might indicate non-existence or unusual states,
        # relying on the subsequent existence check.
        if ! docker buildx rm "$BUILDER_NAME" >/dev/null 2>&1; then
            print_warning "Buildx builder '$BUILDER_NAME' 移除命令执行（或可能因为 Builder 处于特殊状态而返回非零值）。"
            print_warning "    请注意：如果 Builders 处于复杂状态，可能需要手动介入。请检查 'docker buildx ls' 输出。"
        else
            print_success "Buildx builder '$BUILDER_NAME' 移除命令已成功执行。"
        fi
        
        sleep 1 # Give Docker daemon a moment.

        # Final check: If builder STILL exists, then something is fundamentally wrong.
        if docker buildx ls | grep -q "^${BUILDER_NAME}\s"; then
            print_error "!! 严重错误: 移除 Buildx builder '$BUILDER_NAME' 尝试后，它仍然存在。!!"
            print_error "    这强烈表明 Docker Buildx 或 Docker Daemon 存在配置问题或状态异常。"
            print_error "    请尝试手动清理："
            print_error "      1. ${COLOR_CYAN}sudo systemctl stop docker${COLOR_RESET}"
            print_error "      2. ${COLOR_YELLOW}(谨慎) 尝试手动清理 Builder：${COLOR_CYAN}sudo rm -rf $(dirname $(which docker))/${BUILDER_NAME}* # （如果知道具体缓存位置）${COLOR_RESET}"
            print_error "      3. ${COLOR_CYAN}sudo systemctl start docker${COLOR_RESET}"
            print_error "      4. 再次运行脚本。"
            exit 1 # Critical failure: cannot ensure a clean builder state.
        else
            print_success "Buildx builder '$BUILDER_NAME' 已成功清理（或之前不存在）。"
        fi
    fi
    
    # Proceed to create a new builder if none was properly found or managed.
    print_info "正在创建新的 Buildx builder '$BUILDER_NAME'..."
    if ! docker buildx create --name "$BUILDER_NAME" --driver docker-container --bootstrap --use >/dev/null 2>&1; then
        print_error "!! Buildx builder '$BUILDER_NAME' 创建失败！!!"
        print_error "    这是构建镜像的关键前置条件，脚本将无法继续。"
        print_error "    请检查 Docker Daemon 日志 (${COLOR_CYAN}sudo journalctl -u docker.service${COLOR_RESET}) 或 Buildx 相关输出。"
        exit 1
    fi
    
    # Ensure binfmt support, vital for cross-platform builds.
    if ! docker run --rm --privileged tonistiigi/binfmt:latest --install all >/dev/null 2>&1; then
       print_info "正在为多架构构建设置 binfmt 支持..."
       if ! docker run --rm --privileged tonistiigi/binfmt:latest --install all >/dev/null 2>&1; then
           print_warning "Binfmt support installation command might have failed. Multi-arch builds may not work correctly."
       else
           print_success "Binfmt support installation command executed."
           sleep 2 # Give the system a moment to register the binfmt changes.
           if ! docker run --rm --privileged tonistiigi/binfmt:latest --print 2>/dev/null | grep -q "supported"; then
               print_warning "Binfmt support still not detected as active after installation attempt."
           fi
       fi
    fi
    
    print_success "Buildx builder '$BUILDER_NAME' 已成功创建并设置为默认。"
}

build_image() {
    local force_build=${1:-""}
    if [[ -z "$force_build" ]] && docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        print_info "镜像 '$IMAGE_NAME' 已存在，跳过构建。如需强制构建，请在主菜单中选择更新选项。"
        return
    fi
    
    setup_buildx # Ensures buildx is ready
    
    TMP_WORKDIR=$(mktemp -d -t nexus_docker_build_XXXXXX)
    # Added specific cleanup for TMP_WORKDIR. The general trap should also catch it, but this is more targeted.
    trap 'EXITCODE=$?; printf "\n"; print_info "Executing build cleanup..."; rm -rf "$TMP_WORKDIR"; exit $EXITCODE' EXIT HUP INT QUIT TERM
    cd "$TMP_WORKDIR"
    
    local cli_url="https://github.com/nexus-xyz/nexus-cli/releases/download/${NEXUS_CLI_VERSION}/nexus-network-linux-arm64"
    
    print_info "正在生成 Dockerfile 及 entrypoint 脚本..."
    
    # Dockerfile content. Ensure curl and ca-certificates are present.
    printf '%s\n' \
      'ARG TARGETPLATFORM=linux/arm64' \
      'FROM --platform=$TARGETPLATFORM ubuntu:24.04' \
      'ENV DEBIAN_FRONTEND=noninteractive' \
      'RUN apt-get update && apt-get install -y --no-install-recommends curl screen netcat-openbsd ca-certificates && rm -rf /var/lib/apt/lists/*' \
      "RUN mkdir -p /usr/local/bin && curl --cacert /etc/ssl/certs/ca-certificates.crt -L -o /usr/local/bin/nexus-network ${cli_url} && chmod +x /usr/local/bin/nexus-network" \
      'COPY entrypoint.sh /entrypoint.sh' \
      'RUN chmod +x /entrypoint.sh' \
      'ENTRYPOINT ["/entrypoint.sh"]' \
      'VOLUME /root/.nexus' \
      'EXPOSE 8080' > Dockerfile

    # Entrypoint script for running Nexus network.
    printf '%s\n' \
      '#!/bin/bash' \
      'set -e' \
      'if [ -z "$NODE_ID" ]; then echo "错误: NODE_ID 环境变量未设置！" >&2; exit 1; fi' \
      'if ! command -v nexus-network >/dev/null 2>&1; then echo "错误: nexus-network 命令不存在!" >&2; exit 1; fi' \
      'echo "准备 Nexus 节点 (NODE_ID: $NODE_ID)..."' \
      'mkdir -p /root/.nexus && echo "$NODE_ID" > /root/.nexus/node-id' \
      'LOG_FILE="/root/nexus.log"' \
      'SCREEN_SESSION_NAME="nexus_'$NODE_ID'"' \
      '# Clean up previous screen sessions for the same node if they exist' \
      'if screen -list | grep -q "\. N:$SCREEN_SESSION_NAME"; then' \
      '  echo "正在停止现有的 Nexus 进程 (Screen session: $SCREEN_SESSION_NAME)..."' \
      '  screen -S "$SCREEN_SESSION_NAME" -X quit || true' \
      '  sleep 1' \
      'fi' \
      'echo "正在后台启动 Nexus 节点 (NODE_ID: $NODE_ID)..."' \
      'screen -dmS "$SCREEN_SESSION_NAME" bash -c "exec nexus-network start --node-id \$NODE_ID | tee -a $LOG_FILE"' \
      'sleep 2' \
      'if ! screen -list | grep -q "\. N:$SCREEN_SESSION_NAME"; then' \
      '  echo "!! Nexus 节点启动失败 (Screen session: $SCREEN_SESSION_NAME), 请检查日志: $LOG_FILE !! " >&2' \
      '  cat $LOG_FILE >&2 || true' \
      '  exit 1' \
      'fi' \
      'echo "Nexus 节点 ${NODE_ID} 启动成功，屏幕会话 '${SCREEN_SESSION_NAME}'。"' \
      '# Keep the container running indefinitely by tailing a file.' \
      'tail -f /dev/null' > entrypoint.sh

    print_info "正在构建节点镜像 '$IMAGE_NAME' (Nexus CLI: ${NEXUS_CLI_VERSION})，此过程可能需要几分钟..."
    # Use the specified builder, platform, and load into docker.
    if ! docker buildx build --builder "$BUILDER_NAME" --platform linux/arm64 -t "$IMAGE_NAME" . --load >/dev/null 2>&1; then
        print_error "!! Docker buildx build 过程中出错！构建镜像失败。!!\n"
        print_error "    请检查构建输出（可能在调试模式下显示），以及 Docker Buildx 和 Daemon 的日志。\n"
        exit 1 # Build failure is critical.
    fi
    
    print_success "镜像 '$IMAGE_NAME' 构建完成。"
}

run_container() {
    local node_id="$1"
    if [ -z "$node_id" ]; then print_error "错误: 未提供 Node ID"; return 1; fi
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    # Manage existing container: stop and remove if present.
    if docker ps -a -q -f name="${container_name}" | grep -q .; then
        print_info "容器 '$container_name' 已存在。正在停止并移除旧容器..."
        docker stop "$container_name" > /dev/null 2>&1 || print_warning "停止容器 '$container_name' 失败（可能已停止），继续移除。"
        # Use force rm if standard rm fails? Generally not needed if stopped, but good to know.
        if ! docker rm "$container_name" > /dev/null 2>&1; then
            print_warning "移除容器 '$container_name' 失败，可能是因为容器被进程锁定或存在卷问题。"
        fi
    fi

    # Prepare log directory and file.
    mkdir -p "$LOG_DIR"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"
    # Touch ensures the file exists with correct permissions before the container tries to write to it.
    if ! touch "$log_file" || ! chmod 644 "$log_file"; then
        print_error "!! 无法创建或设置日志文件 '$log_file' 的权限。 !!\n    请检查 '$LOG_DIR' 目录权限。"
        return 1 # Cannot proceed if logs can't be written.
    fi
    
    print_info "正在启动节点 ${node_id} (容器名: ${container_name})..."
    # Execute docker run.
    if ! docker run -d --name "$container_name" \
        -v "${log_file}:/root/nexus.log:rw" \
        -e NODE_ID="$node_id" \
        --restart unless-stopped \
        "$IMAGE_NAME" >/dev/null 2>&1; then
        
        print_error "!! Docker run 命令执行失败 !! 容器 '${container_name}' 未能启动。\n"
        print_error "    可能原因: 镜像 '$IMAGE_NAME' 问题，或 CMD/ENTRYPOINT 脚本错误。"
        print_error "    请检查 Docker Daemon 日志 (${COLOR_CYAN}sudo journalctl -u docker.service${COLOR_RESET})。"
        # Try to show the log file content if it exists, though it might be empty if the container never wrote anything.
        if [ -f "$log_file" ]; then
            print_error "--- Content of potentially relevant log file: ---"
            cat "$log_file" >&2
            print_error "-----------------------------------------------"
        fi
        exit 1 # Exit as container start is essential for the node.
    fi
    
    sleep 3 # Give container and its entrypoint a moment to start and stabilize.
    
    # Verify container is actually running.
    if ! docker ps -q -f name="${container_name}" | grep -q .; then
        print_error "节点 ${node_id} (${container_name}) 启动后未在运行！\n    这是个严重问题。请使用日志功能检查详细原因。"
        print_error "    Log file location: ${log_file}"
        # Attempt to display the log file's content for immediate diagnosis.
        if [ -f "$log_file" ]; then
            print_error "--- Log content from ${log_file}: ---"
            cat "$log_file" >&2
            print_error "-------------------------------------"
        else
            print_error "    Log file not found."
        fi
        # Consider exiting or allowing menu to proceed but with clear error indication.
        # For now, just logging the error and letting it proceed.
    else
        print_success "节点 $node_id ($container_name) 已成功启动。日志路径: $log_file"
    fi
}

stop_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    # Check if container exists and is running
    if docker ps --format '{{.Names}}' | grep -qw "$container_name"; then
        print_info "正在停止节点 $node_id ($container_name)..."
        if ! docker stop "$container_name" > /dev/null 2>&1; then
             print_error "!! Docker stop 命令失败 !! 容器 '${container_name}' 可能未能停止。"
             # If stop fails, attempt removal as a last resort or to proceed
             print_warning "尝试移除可能处于停止状态的容器 '$container_name'。"
             docker rm "$container_name" >/dev/null 2>&1 || true
             return 1
        else
             print_success "节点 $node_id ($container_name) 已停止。"
        fi
    elif docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_info "节点 $node_id ($container_name) 已停止。正在尝试移除。"
        if ! docker rm "$container_name" > /dev/null 2>&1; then
            print_warning "移除已停止的容器 '$container_name' 失败。"
        else
            print_success "已移除停止的节点 $node_id ($container_name)。"
        fi
    else
        print_error "未找到容器 '$container_name'。"
    fi
}

start_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    # Check if container exists (even if stopped)
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_info "正在启动节点 $node_id ($container_name)..."
        if ! docker start "$container_name" > /dev/null 2>&1; then
            print_error "!! Docker start 命令失败 !! 容器 '${container_name}' 未能启动。"
            print_error "    请检查容器状态或 Docker Daemon 日志。"
            return 1
        fi
        sleep 3
        if docker ps -q -f name="${container_name}" | grep -q .; then
            print_success "节点 $node_id ($container_name) 已启动。"
        else
            print_error "节点 $node_id ($container_name) 启动后状态异常，请检查日志。"
        fi
    else
        print_error "未找到容器 '$container_name'。请先使用安装功能。"
    fi
}

restart_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_info "正在重启节点 $node_id ($container_name)..."
        if ! docker restart "$container_name" > /dev/null 2>&1; then
            print_error "!! Docker restart 命令失败 !! 容器 '${container_name}' 未能重启。"
            print_error "    请检查容器状态或 Docker Daemon 日志。"
            return 1
        fi
        sleep 3
        if docker ps -q -f name="${container_name}" | grep -q .; then
            print_success "节点 $node_id ($container_name) 已重启。"
        else
            print_error "节点 $node_id ($container_name) 重启后状态异常，请检查日志。"
        fi
    else
        print_error "未找到容器 '$container_name'。"
    fi
}

uninstall_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    print_info "正在卸载节点 $node_id (容器名: ${container_name})..."
    
    # Stop the container gracefully first.
    docker stop "$container_name" > /dev/null 2>&1 || true # Ignore error if already stopped.
    # Then remove the container.
    if ! docker rm "$container_name" > /dev/null 2>&1; then
        print_warning "移除容器 '$container_name' 失败。它可能已被移除，或存在卷问题。"
    else
        print_success "容器 '$container_name' 已移除。"
    fi
    
    # Remove associated log file.
    local log_file="${LOG_DIR}/nexus-${node_id}.log"
    if [ -f "$log_file" ]; then
        if ! rm -f "$log_file"; then
            print_warning "无法移除日志文件 '$log_file'。"
        else
            print_info "已移除日志文件: $log_file"
        fi
    fi
}

get_all_node_ids() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//" | sort -u
}

view_node_logs() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    # Check if container exists at all.
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_error "错误: 未找到容器 '$container_name'。"
        return 1
    fi
    
    print_info "正在查看节点 ${node_id} ($container_name) 的日志。按 Ctrl+C 退出。"
    
    # Stream logs if running, otherwise show file content.
    if docker ps -q -f name="${container_name}" | grep -q .; then
        print_color "--- Streaming logs from running container '$container_name' ---" "$COLOR_BLUE"
        # Using 'docker logs -f' is preferred for streaming.
        if ! docker logs -f "$container_name"; then
            print_warning "Log streaming for '$container_name' interrupted or failed."
        fi
    else
        # If container is stopped, show static log file content.
        local log_file="${LOG_DIR}/nexus-${node_id}.log"
        if [ -f "$log_file" ]; then
            print_color "--- Showing logs from file '$log_file' (container is stopped) ---" "$COLOR_YELLOW"
            if ! cat "$log_file"; then
                print_warning "Could not display log file content for '$log_file'."
            fi
            print_color "--- End of log file ---" "$COLOR_YELLOW"
        else
            print_warning "Log file for node $node_id not found. Container is stopped and no log file exists."
        fi
    fi
}

# --- LIST NODES FUNCTION - FINAL PARSED STATS LOGIC ---
list_nodes() {
    print_color "============================== 当前 Nexus 节点状态 ===============================" "$COLOR_BLUE"
    printf "%-40s %-28s %-12s %-18s %s\n" \
        "$(print_bold "节点 ID (容器名)")" \
        "$(print_bold "状态")" \
        "$(print_bold "CPU %")" \
        "$(print_bold "内存使用")" \
        "$(print_bold "镜像")"
    print_color "--------------------------------------------------------------------------------------" "$COLOR_BLUE"
    
    local all_node_info=() # Stores node_id:container_name pairs
    
    # 1. Gather all potential nodes by listing containers that match our naming pattern.
    while IFS= read -r container_name; do
        local node_id
        node_id=$(echo "$container_name" | sed "s/^${BASE_CONTAINER_NAME}-//")
        all_node_info+=("$node_id:$container_name")
    done < <(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}")

    if [ ${#all_node_info[@]} -eq 0 ]; then
        print_warning "未找到任何 Nexus 节点容器。"
    else
        local running_container_ids
        # Get IDs of ALL running containers matching our pattern.
        running_container_ids=$(docker ps -q -f name="${BASE_CONTAINER_NAME}-") 

        declare -A stats_map # Map: container_name -> "CPUPerc\tMemUsage"
        local stats_output=""

        # 2. Collect stats ONLY for RUNNING containers.
        if [ -n "$running_container_ids" ]; then
            # Execute docker stats with specific format. 'table' format often uses flexible spacing.
            stats_output=$(docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" "$running_container_ids")
            
            # --- DIAGNOSTIC OUTPUT FOR STATS PARSING ---
            echo -e "\n${CYAN}--- Docker Stats Raw Output (for running containers) ---${RESET}" >&2
            if [ -z "$stats_output" ]; then
                echo -e "${YELLOW}docker stats command returned no data for running containers.${RESET}" >&2
            else
                echo -e "$stats_output" >&2
            fi
            echo -e "${CYAN}----------------------------------------------------${RESET}\n" >&2
            # --- END DIAGNOSTIC OUTPUT ---

            # 3. Parse stats output robustly. This part is critical.
            # We will process the raw output line by line, using regex for extraction
            # as column alignment (and thus direct TAB splitting) is not reliable.
            echo "$stats_output" | while IFS= read -r line; do
                # Trim leading/trailing whitespace from each line.
                line=$(echo "$line" | sed 's/^[ \t]*//;s/[ \t]*$//')
                
                # Skip the header line ("NAME ...") or any blank lines.
                if [[ "$line" == "NAME"* || -z "$line" ]]; then
                    continue
                fi
                
                local name=""
                local cpu_perc_raw=""
                local mem_usage_raw=""
                local temp_line="$line" # Use a temporary variable for manipulation.

                # Extract container NAME using awk for the first whitespace-separated field.
                name=$(echo "$temp_line" | awk '{print $1}')
                
                # Ensure we are only processing lines belonging to our Nexus containers.
                if [[ "$name" != "${BASE_CONTAINER_NAME}-"* ]]; then
                    continue # Skip lines that do not match our container naming convention.
                fi

                # Extract CPU Usage: Regex looks for a number, optionally with a decimal, followed by '%'
                # It must be preceded by whitespace to avoid partial matches.
                if [[ "$temp_line" =~ [[:space:]]([0-9]*\.?[0-9]+%) ]]; then
                    cpu_perc_raw="${BASH_REMATCH[1]}"
                fi
                
                # Extract Memory Usage: Regex looks for a string like "4.181GiB" or "100MiB"
                # which is a number, optionally with decimal, followed by power unit (K, M, G, T, iB).
                # We capture this pattern as the first occurrence found after name.
                if [[ "$temp_line" =~ ([0-9]+\.?[0-9]*[KMGT]?i?B) ]]; then
                    mem_usage_raw="${BASH_REMATCH[1]}"
                fi

                # Clean extracted values: remove ANSI color codes and any leftover whitespace.
                cpu_perc=$(echo "$cpu_perc_raw" | sed 's/\x1b\[[0-9;]*m//g' | xargs)
                mem_usage=$(echo "$mem_usage_raw" | sed 's/\x1b\[[0-9;]*m//g' | xargs)

                # Assign "N/A" if extraction failed for either metric.
                [ -z "$cpu_perc" ] && cpu_perc="N/A"
                [ -z "$mem_usage" ] && mem_usage="N/A"
                
                # Store extracted values in the map. Use TAB as separator.
                stats_map["$name"]="$cpu_perc"$'\t'"$mem_usage"
            done
        else
            echo -e "\n${YELLOW}No running containers found to collect stats from.${RESET}\n" >&2
        fi
        
        # 4. Iterate through all identified nodes to display their consolidated information.
        for item in "${all_node_info[@]}"; do
            IFS=':' read -r node_id container_name <<< "$item"
            
            local status_raw="Unknown"
            local formatted_status
            local cpu_perc="N/A" 
            local mem_usage="N/A"  
            local image_name="<none>"
            local display_node_info="$node_id ($container_name)" # Combine Node ID and Container Name

            # Get status and image details for each container.
            local container_details
            container_details=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}\t{{.Image}}")

            if [ -n "$container_details" ]; then
                # Parse status and image correctly.
                status_raw=$(echo "$container_details" | cut -f1)
                image_name=$(echo "$container_details" | cut -f2)
                
                if [[ "$status_raw" == *"Up"* ]]; then
                    formatted_status=$(print_color "$status_raw" "$COLOR_GREEN")
                    # Retrieve parsed stats if available.
                    if [[ -v stats_map["$container_name"] ]]; then
                        IFS=$'\t' read -r cpu_perc mem_usage <<< "${stats_map["$container_name"]}"
                    else
                        # If a running container's stats weren't parsed.
                        print_warning "Stats parsing failed or stats not found for running container '$container_name'." >&2
                        cpu_perc="N/A (parse)" # Indicate potential parsing issue.
                        mem_usage="N/A (parse)"
                    fi
                elif [[ "$status_raw" == *"Exited"* ]]; then
                    formatted_status=$(print_color "$status_raw" "$COLOR_YELLOW")
                else 
                    formatted_status=$(print_color "$status_raw" "$COLOR_RED")
                fi
            else
                # Case where container name was matched initially, but 'docker ps -a' now doesn't find it.
                formatted_status="$(print_color "Not Found" "$COLOR_RED")"
                image_name="-"
                display_node_info="$node_id ($container_name - Stale)"
            fi
            
            # Trim image name if it's too long for the table.
            if [ ${#image_name} -gt 25 ]; then image_name="${image_name:0:22}..."; fi

            # Print the formatted row.
            printf "%-40s %-28s %-12s %-18s %s\n" "$display_node_info" "$formatted_status" "$cpu_perc" "$mem_usage" "$image_name"
        done
    fi
    print_color "======================================================================================" "$COLOR_BLUE"
}


# --- Menu Handling Functions ---
select_node_action() {
    local action_callback="$1"
    local prompt_message="$2"
    
    local available_nodes=()
    # Ensure we only list nodes for which containers actually exist.
    while IFS= read -r node_id; do
        if docker ps -a --filter "name=${BASE_CONTAINER_NAME}-${node_id}" --format '{{.Names}}' | grep -q .; then
            available_nodes+=("$node_id")
        fi
    done < <(get_all_node_ids)

    if [ ${#available_nodes[@]} -eq 0 ]; then
        print_warning "当前无任何节点可操作。"
        read -n 1 -s -r -p "按任意键返回..."
        return
    fi
    
    echo "请选择要'${prompt_message}'的节点:"
    
    local display_options=()
    for i in "${!available_nodes[@]}"; do
        local node_id="${available_nodes[$i]}"
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status="Not Found"
        local container_info
        # Get status more directly.
        container_info=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}")
        if [ -n "$container_info" ]; then status="$container_info"; fi
        
        # Determine status color.
        local color="$COLOR_RED"
        if [[ "$status" == *"Up"* ]]; then color="$COLOR_GREEN"; elif [[ "$status" == *"Exited"* ]]; then color="$COLOR_YELLOW"; fi
        # Consistent display for options: numbered, node_id (container_name), [status].
        display_options+=("  ${COLOR_CYAN}%2d.${COLOR_RESET} %-30s [%s]") "$((i+1))" "$node_id ($container_name)" "$(print_color "$status" "$color")"
    done

    printf '%s\n' "${display_options[@]}"
    echo "   0. 返回主菜单"
    
    read -rp "${COLOR_YELLOW}请输入选项 (0-${#available_nodes[@]}): ${COLOR_RESET}" choice
    
    # Input validation.
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt ${#available_nodes[@]} ]; then
        print_error "无效输入。"
        sleep 1
        return
    fi
    
    [ "$choice" -eq 0 ] && return # User chose to go back.
    
    # Execute the action callback for the selected node.
    local selected_node_id="${available_nodes[$((choice-1))]}"
    if ! "$action_callback" "$selected_node_id"; then
        print_error "Action '$action_callback' for node '$selected_node_id' failed."
    fi
    
    read -n 1 -s -r -p "按任意键返回..."
}

select_multiple_nodes_action() {
    local action_callback="$1"
    local prompt_message="$2"
    
    local available_nodes=()
    while IFS= read -r node_id; do
        if docker ps -a --filter "name=${BASE_CONTAINER_NAME}-${node_id}" --format '{{.Names}}' | grep -q .; then
            available_nodes+=("$node_id")
        fi
    done < <(get_all_node_ids)

    if [ ${#available_nodes[@]} -eq 0 ]; then
        print_warning "当前无任何节点可操作。"
        read -n 1 -s -r -p "按任意键返回..."
        return
    fi
    
    echo "请选择要'${prompt_message}'的节点 (输入数字, 可多选, 用空格隔开; 输入 'all' 全选):"
    
    local display_options=()
    for i in "${!available_nodes[@]}"; do
        local node_id="${available_nodes[$i]}"
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status="Not Found"
        local container_info
        container_info=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}")
        if [ -n "$container_info" ]; then status="$container_info"; fi

        local color="$COLOR_RED"
        if [[ "$status" == *"Up"* ]]; then color="$COLOR_GREEN"; elif [[ "$status" == *"Exited"* ]]; then color="$COLOR_YELLOW"; fi
        # Consistent display for options.
        display_options+=("  ${CYAN}%2d.${COLOR_RESET} %-30s [%s]") "$((i+1))" "$node_id ($container_name)" "$(print_color "$status" "$color")"
    done
    printf '%s\n' "${display_options[@]}"
    echo "   0. 返回主菜单"

    read -rp "${COLOR_YELLOW}请输入选项: ${COLOR_RESET}" choices_str
    if [[ -z "$choices_str" ]] || [[ "$choices_str" == "0" ]]; then return; fi

    local selected_nodes=()
    if [[ "$choices_str" == "all" ]]; then
        selected_nodes=("${available_nodes[@]}")
    else
        local cleaned_choices=$(echo "$choices_str" | tr ',' ' ' | xargs) # Normalize choices.
        local choices_array=($cleaned_choices)
        
        for choice in "${choices_array[@]}"; do
            # Validate input for each choice.
            if [[ "$choice" =~ ^[1-9][0-9]*$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#available_nodes[@]} ]; then
                selected_nodes+=("${available_nodes[$((choice-1))]}")
            else
                print_warning "输入 '$choice' 无效, 已忽略。"
            fi
        done
    fi

    if [ ${#selected_nodes[@]} -eq 0 ]; then
        print_warning "未选择任何有效节点。"
        sleep 1
        return
    fi
    
    echo "将要对以下节点执行 '${prompt_message}':"
    printf "  %s\n" "${selected_nodes[*]}"
    
    if confirm_action "确认执行此批量操作吗?"; then
        for node_id in "${selected_nodes[@]}"; do
            print_info "--- 执行 '${prompt_message}' 节点: $node_id ---"
            if ! "$action_callback" "$node_id"; then
                print_error "批量操作 '${action_callback}' 对节点 '$node_id' 失败。"
            fi
            echo
            sleep 0.5 # Small delay between operations.
        done
        print_success "批量操作执行完毕。"
    else
        print_info "操作已取消。"
    fi
    read -n 1 -s -r -p "按任意键返回..."
}

menu_install_single() {
    read -rp "${COLOR_YELLOW}请输入要安装的 Node ID (唯一标识符, 建议使用数字): ${COLOR_RESET}" node_id
    if [ -n "$node_id" ]; then
        # Sanitize Node ID: allow only alphanumeric, underscore, hyphen.
        node_id=$(echo "$node_id" | xargs | sed 's/[^a-zA-Z0-9_-]//g')
        if [ -z "$node_id" ]; then
            print_error "Node ID 不能为空且只能包含字母、数字、下划线和短横线。"
            read -n 1 -s -r -p "按任意键返回..."
            return
        fi
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        
        if docker ps -a -q -f name="${container_name}" | grep -q .; then
            print_warning "容器 '$container_name' 已存在。"
            local running_status
            running_status=$(docker ps -f name="${container_name}" --format "{{.Status}}")
            if [[ "$running_status" == *"Up"* ]]; then
                print_info "该节点已在运行中。"
            else
                # Offer to start if container exists but is stopped.
                if confirm_action "是否要启动这个已停止的容器 '$container_name'?"; then
                    start_node "$node_id"
                else
                    print_info "操作已取消。"
                fi
            fi
        else
            # Check if Docker image exists. If not, try to build it.
            if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                print_warning "Nexus 镜像 '$IMAGE_NAME' 未构建。正在尝试构建..."
                build_image "--force"
            fi
            # If image is available (or was built successfully), run the container.
            if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                 if ! run_container "$node_id"; then
                     print_error "节点 '$node_id' 安装过程中出错。"
                 fi
            else
                 print_error "构建镜像失败，无法安装节点。"
            fi
        fi
    else
        print_warning "未输入 Node ID，操作取消。"
    fi
    read -n 1 -s -r -p "按任意键返回..."
}

menu_batch_install() {
    # Pre-check if image exists, attempt build if not.
    if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        print_warning "Nexus 镜像 '$IMAGE_NAME' 未构建。正在尝试构建..."
        build_image "--force"
    fi
    
    if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        print_error "Nexus 镜像构建失败，无法执行批量安装。请先手动构建镜像。"
        read -n 1 -s -r -p "按任意键返回..."
        return
    fi

    print_info "请输入多个 Node ID，每行一个，输入空行或 EOF (Ctrl+D) 结束:"
    local node_ids_to_install=()
    local line_num=0
    # Read Node IDs line by line.
    while IFS= read -r line; do
        line_num=$((line_num+1))
        # Sanitize input as before.
        line=$(echo "$line" | xargs | sed 's/[^a-zA-Z0-9_-]//g') 
        
        if [ -z "$line" ]; then 
            if [ "$line_num" -eq 1 ]; then 
                print_warning "未输入任何 Node ID，操作取消。"
                return # Exit if the first input line is empty.
            fi
            continue # Ignore subsequent empty lines.
        fi
        
        local container_name="${BASE_CONTAINER_NAME}-${line}"
        # Prevent adding duplicate or already existing nodes.
        if docker ps -a --filter "name=${container_name}" --format '{{.Names}}' | grep -q .; then
            print_warning "节点 '$line' (容器: ${container_name}) 已存在, 已忽略。"
        else
            node_ids_to_install+=("$line")
        fi
    done
    
    # If no new nodes to install after filtering.
    if [ ${#node_ids_to_install[@]} -eq 0 ]; then
        print_warning "未找到需要安装的新节点。"
    else
        print_success "将要安装 ${#node_ids_to_install[@]} 个新节点..."
        if confirm_action "确认执行批量安装?"; then
            # Loop through and run_container for each new node.
            for node_id in "${node_ids_to_install[@]}"; do
                print_info "--- 安装节点: $node_id ---"
                if ! run_container "$node_id"; then
                    print_error "节点 '$node_id' 安装失败！"
                fi
                echo
                sleep 1 # Small delay between installations.
            done
            print_success "批量安装任务完成。"
        else
            print_info "操作已取消。"
        fi
    fi
    read -n 1 -s -r -p "按任意键返回..."
}

# --- MENU UPDATE --- Function for system maintenance sub-menu.
menu_update() {
    while true; do
        clear
        print_color "================================================================================" "$COLOR_BLUE"
        print_color "                       系统维护与更新 (Nexus)" "$COLOR_CYAN"
        print_color "================================================================================" "$COLOR_BLUE"
        print_info "Nexus CLI 版本: ${NEXUS_CLI_VERSION}"
        print_info "Docker 镜像: ${IMAGE_NAME}"
        echo
        # Displaying sub-menu options with consistent coloring and formatting.
        echo "  ${COLOR_CYAN}1${COLOR_RESET}. 强制重新构建 Docker 镜像 (更新 nexus-cli 到 ${NEXUS_CLI_VERSION})"
        echo "  ${COLOR_CYAN}2${COLOR_RESET}. 更新所有正在运行的节点 (使用最新镜像滚动更新)"
        echo "  ${COLOR_CYAN}3${COLOR_RESET}. 清理并移除所有节点容器、日志及可选的 Docker 镜像/Builder"
        echo "  ${COLOR_CYAN}0${COLOR_RESET}. 返回主菜单"
        echo
        read -rp "${COLOR_YELLOW}请输入选项: ${COLOR_RESET}" choice
        
        case $choice in
            1) 
               print_warning "此操作将重新构建 '$IMAGE_NAME' 镜像，并会下载最新的 nexus-cli。"
               print_warning "这可能需要一些时间，请确保网络连接稳定。"
               if confirm_action "确认强制重新构建镜像吗?"; then
                   build_image "--force"
                   print_success "镜像强制重建完成。"
               else
                   print_info "操作已取消。"
               fi
               read -n 1 -s -r -p "按任意键返回..."
               ;;
            2)
               print_warning "此操作将停止并删除所有 *正在运行* 的 Nexus 节点容器，"
               print_warning "然后使用最新构建的镜像重新启动它们。Node ID 将保持不变。"
               if confirm_action "确认更新所有正在运行的节点吗?"; then
                   print_info "开始构建最新镜像（确保 nexus-cli 是最新版本）..."
                   build_image "--force" # Ensure we have the latest image
                   
                   print_info "正在查找所有正在运行的 Nexus 节点..."
                   local running_nodes_to_update=()
                   local running_container_ids
                   # Get IDs of all running containers matching our pattern.
                   running_container_ids=$(docker ps -q -f name="${BASE_CONTAINER_NAME}-")

                   if [ -z "$running_container_ids" ]; then
                       print_warning "没有正在运行的节点需要更新。"
                   else
                       # Extract Node IDs from running container names.
                       while IFS= read -r container_id; do
                           local container_name
                           container_name=$(docker ps -f id="$container_id" --format '{{.Names}}')
                           local node_id
                           node_id=$(echo "$container_name" | sed "s/^${BASE_CONTAINER_NAME}-//")
                           running_nodes_to_update+=("$node_id")
                       done <<< "$running_container_ids"

                       if [ ${#running_nodes_to_update[@]} -eq 0 ]; then
                           print_warning "未识别到任何需要更新的运行中节点。"
                       else
                           print_success "将执行更新的节点列表:"
                           printf "  %s\n" "${running_nodes_to_update[@]}"
                           
                           print_info "正在开始滚动更新 ${#running_nodes_to_update[@]} 个节点..."
                           for node_id in "${running_nodes_to_update[@]}"; do
                               print_info "--- 更新节点: $node_id ---"
                               # Perform a full uninstall-then-run for a clean update.
                               uninstall_node "$node_id" 
                               run_container "$node_id"  
                               echo # Add a newline for better readability between updates.
                               sleep 2 # Brief pause to avoid overwhelming the system.
                           done
                           print_success "所有需要更新的运行中节点已完成更新。"
                       fi
                   fi
               else
                   print_info "操作已取消。"
               fi
               read -n 1 -s -r -p "按任意键返回..."
               ;;
            3)
               print_error "${COLOR_RED}警告！此操作将移除所有 Nexus 节点容器、相关的日志文件。"
               print_error "${COLOR_YELLOW}您还可以选择移除 Nexus Docker 镜像和 Buildx builder。"
               
               if confirm_action "确定要继续清理吗?"; then
                   print_info "正在卸载所有 Nexus 节点..."
                   local all_node_ids_to_remove=()
                   # Get all node IDs that currently have container entries.
                   while IFS= read -r node_id; do
                       if docker ps -a --filter "name=${BASE_CONTAINER_NAME}-${node_id}" --format '{{.Names}}' | grep -q .; then
                           all_node_ids_to_remove+=("$node_id")
                       fi
                   done < <(get_all_node_ids)
                   
                   if [ ${#all_node_ids_to_remove[@]} -eq 0 ]; then
                       print_info "未找到需要卸载的节点。"
                   else
                       # Uninstall each identified node.
                       for node_id in "${all_node_ids_to_remove[@]}"; do
                           uninstall_node "$node_id"
                           echo # Newline for spacing.
                       done
                       print_success "所有节点已卸载。"
                   fi

                   # Offer to remove Docker image.
                   if docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
                       if confirm_action "是否移除 Docker 镜像 '$IMAGE_NAME'?"; then
                           if ! docker rmi -f "$IMAGE_NAME" >/dev/null 2>&1; then
                               print_warning "删除镜像 '$IMAGE_NAME' 失败。可能它正在被某个容器使用，或存在其他问题。"
                           else
                               print_success "镜像 '$IMAGE_NAME' 已移除。"
                           fi
                       else
                           print_info "已保留 Docker 镜像 '$IMAGE_NAME'。"
                       fi
                   else
                       print_info "Docker 镜像 '$IMAGE_NAME' 已不存在。"
                   fi

                   # Offer to remove Buildx builder.
                   if docker buildx ls | grep -q "^${BUILDER_NAME}\s"; then
                       if confirm_action "是否移除 Buildx builder '$BUILDER_NAME'?"; then
                           if ! docker buildx rm "$BUILDER_NAME" >/dev/null 2>&1; then
                               print_warning "移除 Buildx builder '$BUILDER_NAME' 失败。"
                           else
                               print_success "Buildx builder '$BUILDER_NAME' 已移除。"
                           fi
                       else
                           print_info "已保留 Buildx builder '$BUILDER_NAME'。"
                       fi
                   else
                       print_info "Buildx builder '$BUILDER_NAME' 已不存在。"
                   fi

                   # Offer to remove log directory if it exists and is not empty.
                   if [ -d "$LOG_DIR" ]; then
                       if [ -n "$(ls -A "$LOG_DIR")" ]; then # Check if directory is not empty.
                            if confirm_action "是否移除 Nexus 日志目录 '$LOG_DIR'?"; then
                                if ! rm -rf "$LOG_DIR"; then
                                    print_warning "移除日志目录 '$LOG_DIR' 失败。"
                                else
                                    print_success "日志目录 '$LOG_DIR' 已移除。"
                                fi
                            else
                                print_info "已保留 Nexus 日志目录 '$LOG_DIR'。"
                            fi
                       else
                           print_info "日志目录 '$LOG_DIR' 为空，无需移除。"
                       fi
                   else
                       print_info "Nexus 日志目录 '$LOG_DIR' 已不存在。"
                   fi
                   
               else
                   print_info "操作已取消。"
               fi
               read -n 1 -s -r -p "按任意键返回..."
               ;;
            0) break ;; # Exit menu_update loop
            *) print_error "无效选项。" && sleep 1;;
        esac
    done
}


# --- Main Menu Loop ---
main_menu() {
    # Initial check: script must be run as root.
    if [ "$(id -u)" -ne 0 ]; then 
        print_error "错误: 此脚本需要 root 权限运行。"
        print_error "请尝试: sudo ./$(basename "$0")"
        exit 1 
    fi
    
    # --- Essential Pre-checks ---
    # Docker daemon and CLI/Buildx checks are performed first. Exiting on failure.
    check_docker_daemon
    check_docker

    # Inform user if Nexus Docker image isn't built yet.
    if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        print_warning "Nexus 镜像 '$IMAGE_NAME' 未构建。请在菜单中选择更新/维护选项 (11) 进行构建。"
    fi

    # Main menu loop
    while true; do
        clear
        print_color "================================================================================" "$COLOR_BLUE"
        print_color "           Nexus 管理脚本 (ARM64 Docker) - ${SCRIPT_VERSION}" "$COLOR_CYAN"
        print_color "================================================================================" "$COLOR_BLUE"
        
        # Call list_nodes to refresh and display the status of all nodes.
        list_nodes 

        echo
        # Main menu options, ensuring consistent formatting and colors.
        print_info "\n--- 节点管理 ---"
        echo "  ${COLOR_CYAN}1${COLOR_RESET}. 安装/启动单个节点        ${COLOR_CYAN}4${COLOR_RESET}. 停止指定节点"
        echo "  ${COLOR_CYAN}2${COLOR_RESET}. 查看指定节点日志         ${COLOR_CYAN}5${COLOR_RESET}. 启动已停止的节点"
        echo "  ${COLOR_CYAN}3${COLOR_RESET}. 卸载指定节点             ${COLOR_CYAN}6${COLOR_RESET}. 重启指定节点"

        print_info "\n--- 批量操作 ---"
        echo "  ${COLOR_CYAN}7${COLOR_RESET}. 批量安装/启动新节点      ${COLOR_CYAN}10${COLOR_RESET}. 批量卸载节点"
        echo "  ${COLOR_CYAN}8${COLOR_RESET}. 批量停止节点             "
        echo "  ${COLOR_CYAN}9${COLOR_RESET}. 批量启动节点             "

        print_info "\n--- 系统维护 ---"
        # Map option 11 to the dedicated menu_update function.
        echo "  ${COLOR_CYAN}11${COLOR_RESET}. 系统更新与维护"
        echo "   ${COLOR_CYAN}0${COLOR_RESET}. 退出脚本"
        echo
        
        # Prompt for user input.
        read -rp "${COLOR_YELLOW}请输入选项: ${COLOR_RESET}" choice
        
        # Process user's choice.
        case $choice in
            1) menu_install_single ;;
            2) select_node_action "view_node_logs" "查看日志" ;;
            3) select_node_action "uninstall_node" "卸载" ;;
            4) select_node_action "stop_node" "停止" ;;
            5) select_node_action "start_node" "启动" ;;
            6) select_node_action "restart_node" "重启" ;;
            
            7) menu_batch_install ;;
            8) select_multiple_nodes_action "stop_node" "停止" ;;
            9) select_multiple_nodes_action "start_node" "启动" ;;
            10) select_multiple_nodes_action "uninstall_node" "卸载" ;;

            11) menu_update ;; # Navigate to the system update/maintenance menu.
            
            0) print_info "感谢使用 Nexus 管理脚本，再见！"; exit 0 ;; # Exit the script gracefully.
            *) print_error "无效选项，请重新输入。" && sleep 1 ;; # Handle invalid input.
        esac
    done
}

# --- Script Entry Point ---
main_menu
