#!/bin/bash
#===============================================================================
# 脚本名称: nexus_manager.sh
# 作者: 哈哈哈哈 (Twitter: @ferdie_jhovie)
# 版本: 1.2.0
# 功能: 管理 Nexus 节点的部署、运行、监控、轮换和卸载。
# 特点: 支持批量部署，节点轮换，日志管理，依赖检查。
# 版权: 免费开源，请勿相信任何收费行为。
#===============================================================================

# 设置 -e 选项，确保任何命令失败时脚本会立即退出。
set -e
# 设置 -o pipefail 选项，使管道中的任何命令失败都会导致整个管道命令失败。
set -o pipefail
# 设置 -u 选项，对未设置的变量报错，提高脚本健壮性。
# set -u # 根据实际情况考虑是否启用此选项，有时在特定环境会有影响

# --- 全局配置 ---
BASE_CONTAINER_NAME="nexus-node"      # 所有 Nexus 节点的 Docker 容器名前缀
IMAGE_NAME="nexus-node:latest"       # 构建的 Docker 镜像名称和标签
LOG_DIR="/root/nexus_logs"           # 宿主机上 Nexus 日志的存储目录
NEXUS_CLI_VERSION="1.1.20"           # 硬编码 Nexus CLI 的版本，用于下载

# --- 函数定义 ---

# 检查 Docker 是否已安装且运行
function check_docker() {
    echo ">>> 检测 Docker 状态..."
    if ! command -v docker &> /dev/null; then
        echo ">>> Docker 未安装，开始安装..."
        # 更新包列表并安装必要的依赖
        apt-get update -qq || { echo ">>> ERROR: apt update 失败，请检查网络连接或尝试手动执行 'apt update'"; exit 1; }
        apt-get install -y -qq apt-transport-https ca-certificates curl software-properties-common || { echo ">>> ERROR: 安装 Docker 所需的包失败"; exit 1; }

        # 添加 Docker 的官方 GPG 密钥
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg &> /dev/null || { echo ">>> ERROR: 下载 Docker GPG 密钥失败"; exit 1; }
        
        # 添加 Docker 的 APT 仓库
        add-apt-repository -y "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" || { echo ">>> ERROR: 添加 Docker APT 仓库失败"; exit 1; }
        
        # 更新包列表后安装 Docker CE
        apt-get update -qq
        apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-compose-plugin || { echo ">>> ERROR: 安装 docker-ce 失败"; exit 1; }
        
        # 启用并启动 Docker 服务
        systemctl enable docker || { echo ">>> ERROR: 启用 Docker 服务失败"; exit 1; }
        systemctl start docker || { echo ">>> ERROR: 启动 Docker 服务失败"; exit 1; }
        echo ">>> Docker 已成功安装并启动。"
    else
        # 检查 Docker 服务是否正在运行
        if ! systemctl is-active --quiet docker; then
            echo ">>> 检测到 Docker 服务未运行，正在尝试启动..."
            systemctl start docker || { echo ">>> ERROR: 启动 Docker 服务失败"; exit 1; }
            echo ">>> Docker 服务已启动。"
        else
            echo ">>> Docker 已安装并正在运行。"
        fi
    fi
}

# 检查 Node.js/npm/pm2 是否已安装
function check_pm2() {
    echo ">>> 检测 Node.js/npm/pm2 状态..."
    if ! command -v node &> /dev/null || ! command -v npm &> /dev/null; then
        echo ">>> 检测到未安装 Node.js/npm，开始安装..."
        # 使用官方 NodeSource 仓库安装 Node.js 18.x
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash - &> /dev/null || { echo ">>> ERROR: 设置 Node.js 18.x 源失败"; exit 1; }
        apt-get update -qq
        apt-get install -y -qq nodejs || { echo ">>> ERROR: 安装 Node.js 失败"; exit 1; }
        echo ">>> Node.js 和 npm 已安装。"
    fi
    if ! command -v pm2 &> /dev/null; then
        echo ">>> 检测到未安装 pm2，开始安装..."
        npm install -g pm2 || { echo ">>> ERROR: 安装 pm2 全局模块失败"; exit 1; }
        echo ">>> pm2 已安装。"
    fi
}

# 构建docker镜像函数
function build_image() {
    echo ">>> 开始构建 Docker 镜像 '$IMAGE_NAME'..."
    local WORKDIR
    # 创建一个临时目录，用于存放 Dockerfile 和 entrypoint.sh
    # 使用 mktemp 并为其设置 trap 清理
    WORKDIR=$(mktemp -d)
    # 确保在脚本退出时，即使发生错误，临时目录也会被删除
    trap 'echo ">>> [Build Image] 清理临时目录 $WORKDIR"; rm -rf -- "$WORKDIR"' EXIT
    trap 'echo ">>> [Build Image] 清理临时目录 $WORKDIR 并 abort"; rm -rf -- "$WORKDIR"; exit 1' INT TERM # 为中断信号也设置trap
    
    cd "$WORKDIR" || { echo ">>> ERROR: 无法进入临时目录 '$WORKDIR'"; exit 1; }

    # --- 创建 Dockerfile ---
    cat > Dockerfile <<EOF
# --- Dockerfile for Nexus Node ---
FROM ubuntu:24.04

LABEL maintainer="哈哈哈哈 <https://twitter.com/ferdie_jhovie>"

# 设置非交互式前端和日志变量
ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id
ENV NODE_LOG_PATH=/root/nexus.log

# 安装基础依赖并清理 APT 缓存以减小镜像大小
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    tar \
    ca-certificates \
    screen \
    bash \
    jq \
    && rm -rf /var/lib/apt/lists/*

# === 下载和安装 Nexus CLI ===
# 使用硬编码的版本号 `${NEXUS_CLI_VERSION}` 来确保跨平台兼容性，并直接内联到 URL。
RUN NEXUS_CLI_VERSION="${NEXUS_CLI_VERSION}" && \
    ARCH=\$(uname -m) && \
    echo ">>> Docker build: 检测到的架构为 \$ARCH，将安装 Nexus CLI 版本 \$NEXUS_CLI_VERSION。" && \
    case "\$ARCH" in \
        "aarch64") \
            URL="https://github.com/nexus-xyz/nexus-network-services/releases/download/v\${NEXUS_CLI_VERSION}/nexus-cli_\${NEXUS_CLI_VERSION}_linux_arm64.tar.gz" ;; \
        "x86_64") \
            URL="https://github.com/nexus-xyz/nexus-network-services/releases/download/v\${NEXUS_CLI_VERSION}/nexus-cli_\${NEXUS_CLI_VERSION}_linux_amd64.tar.gz" ;; \
        *) \
            echo ">>> Docker build: 错误 - 不支持的 CPU 架构: \$ARCH。仅支持 aarch64 和 x86_64。" >&2 && exit 1 ;; \
    esac && \
    echo ">>> Docker build: 将从 \${URL} 下载 Nexus CLI..." && \
    # 创建 Nexus 的安装目录
    mkdir -p /root/.nexus/bin && \
    # 使用临时目录进行下载和解压
    TMP_DIR=\$(mktemp -d) && \
    # 下载压缩包，并将其解压到临时目录
    curl -fsSL "\${URL}" | tar -xzf - -C "\$TMP_DIR" || { echo ">>> Docker build: 下载或解压 Nexus CLI 包失败。" >&2; exit 1; } && \
    # 将 nexus-network 可执行文件移动到 /root/.nexus/bin/
    mv "\$TMP_DIR/nexus-network" /root/.nexus/bin/ || { echo ">>> Docker build: 移动 nexus-network 到安装目录失败。" >&2; exit 1; } && \
    # 在 /usr/local/bin 创建一个指向 nexus-network 的符号链接，以便直接使用 nexus-network 命令
    ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network || { echo ">>> Docker build: 创建 nexus-network 软链接失败。" >&2; exit 1; } && \
    # 清理临时文件以减小镜像层
    rm -rf "\$TMP_DIR" && \
    echo ">>> Docker build: Nexus CLI v\${NEXUS_CLI_VERSION} 安装成功。"
# === Nexus CLI 安装结束 ===

# 复制入口脚本到容器，并赋予执行权限
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# 设置容器启动时执行的命令
ENTRYPOINT ["/entrypoint.sh"]
EOF

    # --- 创建 entrypoint.sh ---
    cat > entrypoint.sh <<EOF
#!/bin/bash
# --- Entrypoint script for Nexus Node Container ---
set -e
set -o pipefail

PROVER_ID_FILE="/root/.nexus/node-id"
NODE_LOG_PATH="/root/nexus.log"

# 确保 NODE_ID 环境变量已被设置
if [ -z "\$NODE_ID" ]; then
    echo ">>> ERROR: NODE_ID 环境变量未设置。容器无法启动。请检查运行命令。" >&2
    exit 1
fi

# 设置 Node ID 文件，供 Nexus 服务读取
echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo ">>> Container: Nexus 节点 ID 为: \$NODE_ID"
echo ">>> Container: Nexus 运行日志将输出到: \$NODE_LOG_PATH"

# 检查 Nexus network-manager 命令是否可用
if ! command -v nexus-network &> /dev/null; then
    echo ">>> ERROR: 'nexus-network' 命令不可用。请检查镜像构建或安装。" >&2
    exit 1
fi

# 启动 Nexus network-manager，并使用 screen 在后台运行以管理进程和日志。
# screen -S nexus 会创建一个名为 'nexus' 的 session。
# -dmS 参数表示：detached (后台运行), monitor (监听), session name (会话名)。
# bash -c "..." 会在 screen session 中执行命令。

# 避免重复启动同一个 nexus screen session
if screen -list | grep -q "nexus"; then
    echo ">>> Container: Nexus 进程已在运行的 'nexus' screen session 中管理。"
else
    echo ">>> Container: 启动 Nexus 进程 (使用 screen 管理)..."
    # 使用 'exec' 替换当前 shell 进程为 screen，避免了额外的 shell 层级
    # 但为了方便输出日志，我们不使用 exec
    # 为了让 screen 持久运行并捕获nexus的退出，我们使用一个无限循环来管理
    # 确保 NexusCLI 以screen session方式启动，以便可以附加和捕获其输出和退出状态。
    screen -dmS nexus bash -c ' \
        trap "echo >>> Screen \"nexus\" session received SIGTERM, cleaning up...; \
                 pkill -f \"nexus-network start --node-id \$NODE_ID\" || true; \
                 screen -S nexus -X quit; \
                 exit 0" SIGTERM SIGINT SIGQUIT SIGKILL; \
        echo >>> Screen \"nexus\" session started. Logging to ${NODE_LOG_PATH}; \
        while true; do \
            nexus-network start --node-id \$NODE_ID &>> '${NODE_LOG_PATH}'; \
            if [ \$? -eq 0 ]; then \
                echo >>> Nexus network start successful, running...; \
                # 暂停一段时间确保 screen session 持久运行，但防止 Nexus 自动退出后马上又启动一个导致日志混乱。
                # 如果Nexus需要一直活跃，此处可调整或移除睡眠，让nexus自行管理。
                sleep 60; \
            else \
                echo >>> Nexus network start failed or exited abnormally. Retrying in 30 seconds...; \
                sleep 30; \
            fi; \
        done '

    # 稍作等待，确保 screen 和 nexus 有时间启动
    sleep 5 
fi

# 使用 tail -f 持续显示日志
echo ">>> Container: Nexus 日志将持续显示（按 Ctrl+C 退出）。"
tail -f "${NODE_LOG_PATH}"
EOF

    # --- 执行 Docker 构建 ---
    # 使用 --build-arg 可以更灵活地传递变量，但在这里我们直接将变量嵌入了 Dockerfile。
    # 如果直接在 Dockerfile 中硬编码版本号，就不需要 --build-arg。
    if docker build -t "$IMAGE_NAME" . ; then
        echo ">>> Docker 镜像 '$IMAGE_NAME' 构建成功！"
    else
        echo ">>> ERROR: Docker 镜像构建失败。请检查以上输出获取详细原因。" >&2
        # 直接退出，由 EXIT trap 清理
        return 1 
    fi
    
    # Docker 构建成功，此处将 EXIT trap 置为 no-op，以免构建成功后又触发清理
    # 实际清理会由在函数开头设置的 `trap 'rm -rf -- "$WORKDIR"' EXIT` 来执行
    trap - EXIT # 取消当前函数的 EXIT trap
    trap - INT TERM # 取消中断信号 trap

    # 返回到脚本执行前的目录
    cd - &> /dev/null
    # 由于 WORKDIR 被声明为函数内的 local 变量，且在函数开始时设置了 EXIT trap，
    # 所以 $WORKDIR 最终会被清理。我们不需要在这里手动删除。
}

# 启动 Nexus Docker 容器
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo ">>> 正在准备启动节点 '$node_id' (容器: '$container_name')..."

    # 检查并删除可能存在的旧容器
    if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        echo ">>> 检测到旧容器 '$container_name'，正在停止并删除..."
        docker rm -f "$container_name" &> /dev/null || echo ">>> 警告: 停止或删除容器 '$container_name' 时出现问题。"
        echo ">>> 旧容器 '$container_name' 已处理。"
    fi

    # 确保宿主机的日志目录存在
    mkdir -p "$LOG_DIR" || { echo ">>> ERROR: 创建日志目录 '$LOG_DIR' 失败。"; return 1; }
    
    # 确保宿主机的日志文件存在且具有写权限
    if [ ! -f "$log_file" ]; then
        touch "$log_file" || { echo ">>> ERROR: 创建日志文件 '$log_file' 失败。"; return 1; }
        chmod 644 "$log_file" || { echo ">>> ERROR: 修改日志文件 '$log_file' 权限失败。"; return 1; }
        echo ">>> 已创建日志文件: '$log_file'"
    fi

    echo ">>> 正在启动容器 '$container_name' (Node ID: $node_id)，并将日志挂载到 '$log_file'..."
    # 执行 docker run 命令
    if docker run -d \
        --name "$container_name" \
        -v "$log_file":/root/nexus.log \
        -e NODE_ID="$node_id" \
        "$IMAGE_NAME" ; then
        echo ">>> 容器 '$container_name' (Node ID: $node_id) 已成功启动。"
    else
        echo ">>> ERROR: 启动容器 '$container_name' 时发生问题。请检查 Docker 日志或手动排查。" >&2
        return 1 # 返回失败状态
    fi
}

# 停止并卸载指定节点的容器，并删除其日志文件
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo ">>> 正在停止并删除节点 '$node_id' (容器: '$container_name')..."
    
    # 检查容器是否存在，然后强制删除
    if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        docker rm -f "$container_name" &> /dev/null || echo ">>> 警告: 尝试删除容器 '$container_name' 时出现问题，可能已删除。"
        echo ">>> 容器 '$container_name' 已移除。"
    else
        echo ">>> 节点 '$node_id' 对应的容器未找到，可能已被卸载或从未创建过。"
    fi

    # 删除日志文件（如果存在）
    if [ -f "$log_file" ]; then
        echo ">>> 正在删除节点 '$node_id' 的日志文件: '$log_file'..."
        rm -f "$log_file" || echo ">>> 警告: 删除日志文件 '$log_file' 失败。"
        echo ">>> 日志文件 '$log_file' 已移除。"
    else
        echo ">>> 节点 '$node_id' 的日志文件 '$log_file' 不存在，无需删除。"
    fi

    echo ">>> 节点 '$node_id' (容器: '$container_name') 的卸载操作完成。"
}

# 显示所有 Nexus 节点的（容器）状态信息
function list_nodes() {
    echo "------------------------------------------------------------------------------------------------------------------------"
    echo "                                           Nexus 节点状态概览"
    echo "------------------------------------------------------------------------------------------------------------------------"
    printf "%-6s %-38s %-12s %-20s %-12s %-20s\n" "序号" "节点ID (容器名)" "CPU使用率" "内存使用/限制" "容器状态" "启动时间"
    echo "------------------------------------------------------------------------------------------------------------------------"
    
    # 获取所有相关的 Docker 容器，包括运行中和已停止的
    local containers_list
    containers_list=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format '{{.Names}}' | sort)

    if [ -z "$containers_list" ]; then
        echo ">>> 未找到任何 Nexus 节点（Docker 容器）。"
    else
        local i=0
        # 使用 'while read' 来迭代处理容器列表
        while IFS= read -r container_name; do
            # 提取 Node ID，移除容器名前缀 `${BASE_CONTAINER_NAME}-`
            local node_id="${container_name#${BASE_CONTAINER_NAME}-}"
            
            local status="未知"
            local started_at_formatted="-"
            local cpu_usage="N/A"
            local mem_usage="N/A"

            # 使用 docker container inspect 获取容器状态和启动时间
            local container_inspect_output
            container_inspect_output=$(docker container inspect --format='{{.State.Status}} {{.State.StartedAt}}' "$container_name" 2>/dev/null)
            
            if [ -n "$container_inspect_output" ]; then
                status=$(echo "$container_inspect_output" | awk '{print $1}')
                # 仅当容器处于运行状态时才获取启动时间，否则 StartedAt 可能为 "0001-01-01T00:00:00Z"
                if [ "$status" == "running" ]; then
                    local started_at_raw=$(echo "$container_inspect_output" | awk '{$1=""; print $0}' | xargs) # 去掉状态字段
                    # 尝试将 UTC 时间格式转换为本地可读的 ISO 8601 格式
                    # 使用GNU date for more options
                    started_at_formatted=$(date -d "$started_at_raw" --iso-8601=seconds 2>/dev/null || echo "$started_at_raw")
                else
                    started_at_formatted="-" # 对于已停止的容器，显示为 '-'
                fi
            else
                status="未检测到" # 容器不存在或检查失败
            fi

            # 仅当容器运行时，才尝试获取其资源使用情况 (CPU, 内存)
            if [ "$status" == "running" ]; then
                local stats_info
                # 使用 docker stats 获取实时统计信息。--no-stream 表示只获取一次。
                stats_info=$(docker stats --no-stream --format "{{.CPUPerc}}|{{.MemUsage}}" "$container_name" 2>/dev/null)
                if [ -n "$stats_info" ]; then
                    cpu_usage=$(echo "$stats_info" | cut -d '|' -f 1)
                    mem_usage=$(echo "$stats_info" | cut -d '|' -f 2)
                fi
            fi

            # 格式化节点名称以适应表格宽度
            local display_name="${node_id} (${container_name})"
            if (( ${#display_name} > 38 )); then
                display_name="${display_name:0:35}..." # 截断过长的显示名
            fi
            
            printf "%-6d %-38s %-12s %-20s %-12s %-20s\n" \
                $((i+1)) \
                "$display_name" \
                "$cpu_usage" \
                "$mem_usage" \
                "$status" \
                "$started_at_formatted"
            ((i++)) # 增加序号
        done <<< "$containers_list" # 将列表传递给 while 循环
    fi

    echo "------------------------------------------------------------------------------------------------------------------------"
    echo "提示："
    echo "- CPU使用率以百分比显示 (例如: 0.5%)。"
    echo "- 内存使用格式为：已用 / 容量 (例如: 15.8MiB / 1.954GiB)。"
    echo "- 容器状态如：running, exited。"
    echo "- 如果容器未运行，CPU和内存使用率将显示为 N/A。"
    read -p "按任意键返回主菜单..."
}

# 获取当前所有已启动的节点的 Node ID 列表
function get_running_nodes() {
    docker ps --filter "name=${BASE_CONTAINER_NAME}" --filter "status=running" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 获取所有 Nexus 节点（包括运行中和已停止）的 Node ID 列表
function get_all_nodes() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort
}

# 查看指定节点的日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    echo ">>> 正在查找容器 '$container_name' 以便查看日志..."
    # 检查容器是否存在
    if ! docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        echo ">>> 未找到容器 '$container_name'。请先使用选项 1 启动节点。"
        read -p "按任意键返回菜单..."
        return
    fi

    echo "请选择日志查看模式:"
    echo "  1. 实时日志 (FOLLOW模式，Ctrl+C 退出)"
    echo "  2. 获取所有现有日志 (输出一次后退出)"
    echo "  3. 清理后实时日志 (去除 ANSI 颜色码，FOLLOW模式，Ctrl+C 退出)"
    echo "  0. 返回主菜单"
    
    local log_mode
    read -rp "请输入您的选择 (0-3): " log_mode

    case "$log_mode" in
        1)
            echo ">>> 打开 '$container_name' 的实时日志流... (按 Ctrl+C 退出)"
            docker logs -f "$container_name"
            ;;
        2)
            echo ">>> 获取 '$container_name' 的所有现有日志..."
            docker logs "$container_name"
            read -p ">>> 日志已显示。按任意键继续..."
            ;;
        3)
            echo ">>> 打开 '$container_name' 的清理后实时日志... (按 Ctrl+C 退出)"
            # 使用 sed 清理 ANSI escape sequences，如 \x1b[...m
            # 也清理 Windows CRLF 中的 \r，这在某些终端上可能是个问题。
            docker logs -f "$container_name" | sed -E 's/\x1b\[[0-9;]*m//g; s/\r//g'
            ;;
        0)
            echo ">>> 返回主菜单。"
            ;;
        *)
            echo ">>> 无效的日志模式选择。"
            read -p "按任意键继续..."
            ;;
    esac
}

# 批量启动多个节点 (支持手动输入多个 Node ID)
function batch_start_nodes() {
    echo ">>> 请依次输入需要启动的 Nexus 节点的 Node ID，每行一个。"
    echo ">>> 输入空行或按 Ctrl+D 结束输入。"
    
    local node_ids=() # 用于存储输入的 Node ID
    # 读取用户输入，直到用户输入空行或 Ctrl+D
    while IFS= read -r line; do
        # 去除行首行尾的空格
        line=$(echo "$line" | xargs) 
        if [ -n "$line" ]; then
            # 确保 Node ID 不会太长或包含不当字符，但这里不严格校验，只录入非空值
            node_ids+=("$line")
        else
            # 如果用户输入了空行，并且已经收集到至少一个 Node ID，则退出输入循环
            if [ ${#node_ids[@]} -gt 0 ]; then
                break
            fi
        fi
    done < /dev/stdin

    # 如果用户没有输入任何 Node ID
    if [ ${#node_ids[@]} -eq 0 ]; then
        echo ">>> 未输入任何 Node ID，将返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    # 确认并构建 Docker 镜像（如果需要）
    echo ">>> 开始构建 Docker 镜像 '$IMAGE_NAME'，这将可能需要一些时间..."
    check_docker
    build_image 

    # 批量启动容器
    echo ">>> 共收集到 ${#node_ids[@]} 个节点 ID，开始尝试启动..."
    local success_count=0
    for node_id in "${node_ids[@]}"; do
        echo ">>> 正在尝试启动节点 '$node_id'..."
        if run_container "$node_id"; then
            success_count=$((success_count + 1))
            # 为避免瞬时高负载，每个启动后间隔一点时间
            sleep 2 
        else
            echo ">>> 节点 '$node_id' 启动失败。"
        fi
    done

    echo "---------------------------------------------------"
    echo ">>> 批量节点启动操作已完成。"
    echo ">>> 成功启动了 ${success_count} / ${#node_ids[@]} 个节点。"
    echo ">>> 您可以使用选项 '2' 查看所有节点状态。"
    read -p "按任意键返回主菜单..."
}

# 通用函数：选择一个节点进行操作 (例如查看日志)
# 返回值：选中的节点的 Node ID，如果取消则返回空字符串
function select_node_for_action() {
    local action_desc=$1 # 描述当前操作的字符串，例如 "查看日志"
    local all_nodes
    all_nodes=($(get_all_nodes)) # 获取所有节点 ID
    
    # 如果当前没有任何节点
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo ">>> 当前没有已知的 Nexus 节点。"
        read -p "按任意键返回主菜单..."
        echo "" # 返回空，表示未选择
        return
    fi

    echo ">>> 请选择一个节点以进行 '${action_desc}' 操作:"
    echo "  0. 返回主菜单"
    # 遍历所有节点并显示它们的状态
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        
        # 检查容器的运行状态
        if docker ps -a --format '{{.Status}}' --filter "name=${container_name}" 2>/dev/null | grep -q "running"; then
            printf "%3d. 节点 %-20s [运行中]\n" $((i+1)) "$node_id"
        else
            printf "%3d. 节点 %-20s [已停止/不存在]\n" $((i+1)) "$node_id"
        fi
    done

    local choice
    read -rp "请输入您的选择 (0-${#all_nodes[@]}): " choice

    # 处理用户输入
    if [[ "$choice" =~ ^[0-9]+$ ]]; then
        if [ "$choice" = "0" ]; then
            echo ">>> 已取消操作。"
            echo "" # 返回空字符串表示取消
            return
        elif [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
            # 获取选中的节点 ID
            local selected_node_id=${all_nodes[$((choice-1))]}
            echo "$selected_node_id" # 返回选中的 Node ID
            return
        else
            echo ">>> 无效的选项编号。请输入 '0' 到 '${#all_nodes[@]}' 之间的数字。"
        fi
    else
        echo ">>> 无效的输入。请输入数字。"
    fi
    
    echo "请按任意键返回主菜单..."
    read -p ""
    echo "" # 返回空字符串表示选择失败
    return
}

# 批量停止并卸载选定的节点
function batch_uninstall_nodes() {
    local all_nodes
    all_nodes=($(get_all_nodes)) # 获取所有节点 ID
    
    # 如果没有节点可卸载
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo ">>> 当前没有已知的 Nexus 节点可供卸载。"
        read -p "按任意键返回主菜单..."
        return
    fi

    # 显示节点列表并让用户选择要卸载的节点
    echo "---------------------------------------------------"
    echo "节点列表 (选择要卸载的节点，空格分隔多个序号):"
    echo "---------------------------------------------------"
    echo "序号  节点ID               状态"
    echo "---------------------------------------------------"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status="未知"
        # 检查容器状态
        if docker ps -a --format '{{.Status}}' --filter "name=${container_name}" 2>/dev/null | grep -q "running"; then
            status="运行中"
        elif docker ps -a --format '{{.Status}}' --filter "name=${container_name}" 2>/dev/null | grep -q "exited"; then
            status="已停止"
        else
            status="不存在"
        fi
        printf "%-6d %-20s [%s]\n" $((i+1)) "$node_id" "$status"
    done
    echo "---------------------------------------------------"
    echo "请输入要卸载的节点序号 (例如: 1 3 5)，输入 '0' 返回主菜单。"
    
    local choices_input
    read -rp "请输入您的选择 (0 或 序号，空格分隔): " choices_input

    # 处理用户的选择输入
    if [ "$choices_input" == "0" ]; then
        echo ">>> 已取消卸载操作。"
        read -p "按任意键返回主菜单..."
        return
    fi

    # 将输入的分隔的数字解析成一个数组
    local selected_indices=()
    # 使用 IFS 来确保正确处理空格分隔的输入
    IFS=' ' read -r -a selected_indices <<< "$choices_input"
    
    local nodes_to_uninstall=() # 存储要卸载的节点 ID
    local valid_choice=true # 标志位，用于记录输入是否有效
    for choice_str in "${selected_indices[@]}"; do
        # 验证每个选择的序号是否有效
        if [[ "$choice_str" =~ ^[0-9]+$ ]] && [ "$choice_str" -ge 1 ] && [ "$choice_str" -le ${#all_nodes[@]} ]; then
            local node_index=$((choice_str - 1))
            nodes_to_uninstall+=("${all_nodes[node_index]}") # 添加对应的 Node ID
        else
            echo ">>> 警告: 输入了无效的序号 '$choice_str'，将忽略此选项。"
            valid_choice=false
        fi
    done

    # 如果没有有效选择的节点
    if [ ${#nodes_to_uninstall[@]} -eq 0 ]; then
        echo ">>> 没有选择任何节点进行卸载。"
        read -p "按任意键返回主菜单..."
        return
    fi

    # 再次确认卸载操作
    echo ">>> 您已选择卸载以下节点:"
    for node_id in "${nodes_to_uninstall[@]}"; do
        echo "  - $node_id"
    done
    read -rp ">>> 确定要继续卸载这些节点吗? (输入 'YES' 确认): " confirm_uninstall
    if [ "$confirm_uninstall" != "YES" ]; then
        echo ">>> 已取消卸载操作。"
        read -p "按任意键返回主菜单..."
        return
    fi

    # 执行卸载操作
    echo ">>> 开始批量卸载节点..."
    local uninstalled_count=0
    for node_id in "${nodes_to_uninstall[@]}"; do
        # 在执行前再次确认容器是否存在
        if docker ps -a --format '{{.Names}}' | grep -qxF "${BASE_CONTAINER_NAME}-${node_id}"; then
            uninstall_node "$node_id"
            uninstalled_count=$((uninstalled_count + 1))
        else
            echo ">>> 节点 '$node_id' 在卸载前已不存在，跳过。"
        fi
    done

    echo ">>> 批量节点卸载操作完成。共卸载了 ${uninstalled_count} 个节点。"
    read -p "按任意键返回主菜单..."
}

# 批量节点轮换启动：配置并运行一个定时脚本，每隔一段时间自动替换一组节点运行。
function batch_rotate_nodes() {
    # 检查依赖工具
    check_pm2

    # --- 收集 Node ID ---
    echo ">>> 请依次输入参与节点轮换的 Node ID，每行一个。"
    echo ">>> 输入空行或按 Ctrl+D 结束输入。"
    
    local node_ids=()
    while IFS= read -r line; do
        line=$(echo "$line" | xargs)
        if [ -n "$line" ]; then
            node_ids+=("$line")
        else
            # 用户输入了空行，并且已经输入了节点ID，则停止收集
            if [ ${#node_ids[@]} -gt 0 ]; then
                break
            fi
        fi
    done < /dev/stdin

    # 如果没有收集到 Node ID
    if [ ${#node_ids[@]} -eq 0 ]; then
        echo ">>> 未输入任何 Node ID，返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    local total_nodes=${#node_ids[@]}

    # --- 确定每轮启动的节点数量 ---
    # 计算默认值：节点的总数除以2取整，至少为1个。
    local default_nodes_per_round=$(( (total_nodes + 1) / 2 ))
    if [ "$default_nodes_per_round" -lt 1 ]; then default_nodes_per_round=1; fi
    if [ "$default_nodes_per_round" -gt "$total_nodes" ]; then default_nodes_per_round=$total_nodes; fi # 如果总数少于默认值

    local nodes_per_round
    read -rp ">>> 请输入每轮次要启动的节点数量 (每隔 2 小时轮换，默认: ${default_nodes_per_round}): " nodes_per_round
    nodes_per_round=${nodes_per_round:-$default_nodes_per_round} # 使用默认值如果输入为空

    # 验证用户输入
    if ! [[ "$nodes_per_round" =~ ^[0-9]+$ ]] || [ "$nodes_per_round" -lt 1 ] || [ "$nodes_per_round" -gt "$total_nodes" ]; then
        echo ">>> ERROR: 输入的节点数量无效。请确保输入值为 1 到 ${total_nodes} 之间的整数。"
        read -p "按任意键返回菜单..."
        return
    fi

    # 计算需要多少个分组（轮次）
    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    echo ">>> 您配置的总节点数为 ${total_nodes}，将分为 ${num_groups} 轮次，每轮启动 ${nodes_per_round} 个节点。"

    # --- 准备轮换脚本 ---
    echo ">>> 停止并删除旧的 'nexus-rotate' PM2 进程（如果存在）..."
    pm2 stop nexus-rotate &> /dev/null || true # 尝试停止，忽略错误
    pm2 delete nexus-rotate &> /dev/null || true # 尝试删除，忽略错误
    pm2 save # 保存 PM2 的当前状态

    echo ">>> 开始构建（或更新）Nexus Docker 镜像 '$IMAGE_NAME'..."
    build_image

    # 创建用于轮换脚本的目录和主脚本文件
    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir" || { echo ">>> ERROR: 创建脚本目录 '$script_dir' 失败。"; return 1; }
    local rotate_script="$script_dir/rotate_nodes.sh"

    # --- 生成轮换启动脚本 `rotate_nodes.sh` 的内容 ---
    echo "#!/bin/bash" > "$rotate_script"
    echo "set -e" >> "$rotate_script"
    echo "set -o pipefail" >> "$rotate_script"
    # 将需要的变量和配置传递给脚本
    echo "IMAGE_NAME=\"${IMAGE_NAME}\"" >> "$rotate_script"
    echo "BASE_CONTAINER_NAME=\"${BASE_CONTAINER_NAME}\"" >> "$rotate_script"
    echo "LOG_DIR=\"${LOG_DIR}\"" >> "$rotate_script"
    echo "ALL_NODE_IDS=(\"${node_ids[@]}\")" >> "$rotate_script" # 传递所有节点 ID
    echo "NODES_PER_ROUND=${nodes_per_round}" >> "$rotate_script"
    echo "TOTAL_NODES=${total_nodes}" >> "$rotate_script"
    echo "NUM_GROUPS=${num_groups}" >> "$rotate_script"

    # 生成定义每轮次需要启动的节点的数组
    echo 'declare -A rounds_nodes' >> "$rotate_script" # 声明一个关联数组
    for ((g=0; g<num_groups; g++)); do
        local start_index=$(( g * nodes_per_round ))
        local current_round_nodes=()
        # 收集当前轮次对应的 Node IDs
        for ((i=start_index; i<start_index + nodes_per_round && i < TOTAL_NODES; i++)); do
            current_round_nodes+=("${ALL_NODE_IDS[i]}")
        done
        # 将节点 ID 数组转换为bash能够解析的字符串格式并存储到关联数组中
        local nodes_string
        printf -v nodes_string '"%s" ' "${current_round_nodes[@]}"
        echo "rounds_nodes[$g]=(${nodes_string})" >> "$rotate_script"
    done

    # 生成执行轮换逻辑的主循环
    echo 'echo "[$(date "+%Y-%m-%d %H:%M:%S")] Nexus 节点轮换脚本启动..."' >> "$rotate_script"
    echo 'while true; do' >> "$rotate_script" # 使用while true 实现无限循环
    echo 'for ((round=0; round<NUM_GROUPS; round++)); do' >> "$rotate_script"
    echo '    echo ""' >> "$rotate_script"
    echo '    echo "[$(date "+%Y-%m-%d %H:%M:%S")] === 开始第 $((round+1))/${NUM_GROUPS} 轮次节点轮换 ===" ' >> "$rotate_script"
    
    echo '    echo "[$(date "+%Y-%m-%d %H:%M:%S")] 停止并删除所有正在运行或已停止的 Nexus 节点容器..." ' >> "$rotate_script"
    echo '    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f' >> "$rotate_script" # 使用 xargs -r 安全处理无匹配项的情况
    
    # 获取当前轮次的节点 ID
    echo '    current_round_node_ids=("${rounds_nodes[round]}")' >> "$rotate_script"
    echo '    echo "[$(date "+%Y-%m-%d %H:%M:%S")] 本轮次将启动的节点 (${#current_round_node_ids[@]}个): ${current_round_node_ids[*]}" ' >> "$rotate_script"

    # 处理可能没有节点需要启动的情况 (虽然配置时已尽量避免，但作为健壮性检查)
    echo '    if [ ${#current_round_node_ids[@]} -eq 0 ]; then ' >> "$rotate_script"
    echo '        echo "[$(date "+%Y-%m-%d %H:%M:%S")] 警告: 当前轮次没有节点需要启动。" ' >> "$rotate_script"
    echo '        # 如果是最后一轮后的下一个轮次，执行完所有轮次，继续到下一轮循环的开始' >> "$rotate_script"
    echo '        sleep 10 # 短暂暂停，以便用户注意到消息 ' >> "$rotate_script"
    echo '        continue # 继续下一个轮次 ' >> "$rotate_script"
    echo '    fi' >> "$rotate_script"
    
    # 逐个启动本轮次的节点
    echo '    for node_id in "${current_round_node_ids[@]}"; do' >> "$rotate_script"
    echo '        CONTAINER_NAME="'"${BASE_CONTAINER_NAME}"'-\${node_id}"' >> "$rotate_script" # 定义容器名变量
    echo '        LOG_FILE="${LOG_DIR}/nexus-\${node_id}.log"' >> "$rotate_script" # 定义日志文件变量
    echo '        echo "[$(date "+%Y-%m-%d %H:%M:%S")]   - 尝试启动节点 \${node_id} (容器: \${CONTAINER_NAME})..." ' >> "$rotate_script"
    # 启动容器前确保日志文件/目录存在
    echo '        mkdir -p "$LOG_DIR" && touch "$LOG_FILE"' >> "$rotate_script"
    # 执行 docker run 命令
    echo '        if docker run -d \
            --name "\${CONTAINER_NAME}" \
            -v "$LOG_FILE":/root/nexus.log \
            -e NODE_ID="\${node_id}" \
            "$IMAGE_NAME"; then ' >> "$rotate_script"
    echo '            echo "[$(date "+%Y-%m-%d %H:%M:%S")]     成功启动节点 \${node_id}。" ' >> "$rotate_script"
    echo '            sleep 30 # 启动后暂停，避免资源瞬间占满，也可根据情况调整 ' >> "$rotate_script"
    echo '        else ' >> "$rotate_script"
    echo '            echo "[$(date "+%Y-%m-%d %H:%M:%S")]     启动节点 \${node_id} 失败！" ' >> "$rotate_script"
    echo '        fi ' >> "$rotate_script"
    echo '    done' >> "$rotate_script"
    
    echo '    echo "[$(date "+%Y-%m-%d %H:%M:%S")] 第 $((round+1))/${NUM_GROUPS} 轮次节点启动完毕。" ' >> "$rotate_script"
    
    # 根据是否是最后一轮决定等待时间
    echo '    if [ $((round + 1)) -lt ${NUM_GROUPS} ]; then ' >> "$rotate_script"
    echo '        echo "[$(date "+%Y-%m-%d %H:%M:%S")] 等待 2 小时 (7200 秒) 进行下一轮次切换..."' >> "$rotate_script"
    echo '        sleep 7200' >> "$rotate_script"
    echo '    else' >> "$rotate_script" # 最后一轮结束后，脚本会自然循环到下一次启动（回到 round=0）
    echo '        echo "[$(date "+%Y-%m-%d %H:%M:%S")] 所有配置的轮次已执行完毕，将在 2 小时后重新开始新一轮的节点轮换。" ' >> "$rotate_script"
    echo '        echo "[$(date "+%Y-%m-%d %H:%M:%S")] 如果需要停止轮换，请执行: pm2 stop nexus-rotate。" ' >> "$rotate_script"
    echo '        sleep 7200' >> "$rotate_script"
    echo '    fi' >> "$rotate_script"
    echo 'done' >> "$rotate_script" # 结束主循环 (当 TOTAL_NODES / NODES_PER_ROUND < 1 的情况) - 原本写成了 for, 改成 while true + for
    echo 'echo "[$(date "+%Y-%m-%d %H:%M:%S")] Nexus 节点轮换脚本执行完毕（或循环已继续）。"' >> "$rotate_script"

    # 为轮换脚本添加执行权限
    chmod +x "$rotate_script" || { echo ">>> ERROR: 为轮换脚本 '$rotate_script' 添加执行权限失败。"; return 1; }
    echo ">>> 已成功生成节点轮换启动脚本: '$rotate_script'"

    # --- 使用 PM2 启动轮换脚本 ---
    echo ">>> 使用 PM2 启动轮换脚本 'nexus-rotate'..."
    # 尝试启动脚本并命名为 'nexus-rotate'
    if pm2 start "$rotate_script" --name "nexus-rotate" --watch --restart-delay 5000 --max-memory-restart 1G; then
        echo ">>> 节点轮换管理进程 'nexus-rotate' 已成功启动！"
        echo ">>> 你可以使用以下命令监控和管理:"
        echo "    pm2 list                 # 查看所有 pm2 管理的进程"
        echo "    pm2 logs nexus-rotate    # 查看轮换脚本的日志"
        echo "    pm2 show nexus-rotate    # 查看轮换脚本的详细信息"
        echo "    pm2 stop nexus-rotate    # 停止轮换进程"
        echo "    pm2 restart nexus-rotate # 重启轮换进程"
        echo "    pm2 delete nexus-rotate  # 移除轮换进程"
    else
        echo ">>> ERROR: 使用 PM2 启动轮换脚本失败。请检查 PM2 安装及脚本执行权限。" >&2
        return 1
    fi
    pm2 save # 保存 PM2 配置，以便重启后能自动恢复

    echo ">>> 节点轮换配置完成。"
    read -p "按任意键返回主菜单..."
}

# 设置 cronjob 来清理旧的 Nexus 日志文件 (保留最近2天的)
function setup_log_cleanup_cron() {
    # cron 表达式：0 3 */2 * * 表示：每天凌晨3点，每两天执行一次
    # find ${LOG_DIR} -type f -name 'nexus-*.log' -mtime +2 -delete
    #   -mtime +2 表示查找修改时间大于2天的文件 (即，第3天及更早的文件)
    local log_cleanup_cron_job="0 3 */2 * * find \"${LOG_DIR}\" -type f -name 'nexus-*.log' -mtime +2 -delete"
    
    # 检查当前用户的 crontab 是否已包含此作业，避免重复添加
    # crontab -l 获取所有用户 cron 设置, grep -Fq 进行固定字符串匹配查找
    # 加上 || true 避免因 crontab 命令失败而导致脚本退出
    if crontab -l 2>/dev/null | grep -Fq "$log_cleanup_cron_job"; then
        echo ">>> 日志清理定时任务已存在，无需重复设置。"
    else
        # 将新作业添加到 crontab，如果原先有内容则合并，没有则新建
        # 使用 eval 以确保命令中的引号和变量正确展开
        (eval "crontab -l 2>/dev/null"; echo "$log_cleanup_cron_job") | eval "crontab -"
        echo ">>> 已设置日志清理定时任务 (每两天删除超过2天的 Nexus 日志)。"
    fi
}

# 显示主菜单并获取用户选择
function display_menu() {
    clear # 清屏
    echo "============================================"
    echo "      Nexus 多节点管理脚本 (v1.2.0)"
    echo "============================================"
    echo " 作者: 哈哈哈哈 (Twitter: @ferdie_jhovie)"
    echo ""
    echo " 提示: 本脚本完全免费开源，请勿相信任何收费行为。"
    echo "--------------------------------------------"
    echo "  操作选项:"
    echo "    1. 启动新节点 (输入单个或多个 Node ID)"
    echo "    2. 显示所有节点状态 (列表)"
    echo "    3. 批量卸载节点 (选择要移除的节点)"
    echo "    4. 查看节点日志 (选择要查看日志的节点)"
    echo "    5. 节点轮换启动 (自动交替运行多批节点)"
    echo "    6. 删除所有节点 (!!! 慎用 !!! 且不可逆)"
    echo "    0. 退出脚本"
    echo "============================================"
}

# --- 脚本主入口 ---

# 初始化设置：设置日志清理的定时任务
setup_log_cleanup_cron

# 主循环：持续显示菜单并处理用户选择
while true; do
    display_menu # 显示菜单
    
    local choice # 存储用户选择的变量
    read -rp "请输入您的选择(0-6): " choice

    case "$choice" in
        1) # 启动节点
            check_docker # 确保 Docker 已准备好
            batch_start_nodes # 调用批量启动函数
            ;;
        2) # 显示节点状态
            list_nodes # 调用列表函数
            ;;
        3) # 批量卸载节点
            batch_uninstall_nodes # 调用批量卸载函数
            ;;
        4) # 查看节点日志
            local selected_node_id
            # 使用通用函数选择要查看日志的节点
            selected_node_id=$(select_node_for_action "查看日志") 
            # 如果用户选择了节点 (而不是返回或取消)
            if [ -n "$selected_node_id" ]; then
                view_node_logs "$selected_node_id" # 调用查看日志函数
            fi
            ;;
        5) # 节点轮换启动
            batch_rotate_nodes # 调用轮换启动函数
            ;;
        6) # 删除所有节点
            echo ">>> 您即将执行'删除所有节点'的操作！"
            echo ">>> 所有已部署的 Nexus 节点容器及其日志文件都将被永久清除。"
            echo ">>> 这是一个不可逆的操作，请务必确认。"
            # 再次警告和确认
            read -rp ">>> 如果您确实要继续，请输入大写字母 'YES' 来确认: " confirm_all_delete
            if [ "$confirm_all_delete" == "YES" ]; then
                local all_nodes
                all_nodes=($(get_all_nodes)) # 获取当前所有节点的 ID
                
                # 如果没有节点
                if [ ${#all_nodes[@]} -eq 0 ]; then
                    echo ">>> 当前没有已知的 Nexus 节点可供删除。"
                else
                    echo ">>> 正在开始删除所有 ${#all_nodes[@]} 个 Nexus 节点..."
                    # 遍历所有节点并卸载
                    for node_id in "${all_nodes[@]}"; do
                        echo ">>> 卸载节点: $node_id ..."
                        uninstall_node "$node_id" # 调用卸载函数
                    done
                    echo ">>> 所有 Nexus 节点已全部卸载。"
                    
                    # 可选：如果想连同日志目录也一起清理
                    # echo ">>> 正在清理 Nexus 日志目录: '$LOG_DIR'..."
                    # rm -rf "$LOG_DIR" &> /dev/null
                    # echo ">>> 日志目录已清理。"
                fi
            else
                echo ">>> 已取消删除所有节点的操作。"
            fi
            read -p "按任意键返回主菜单..." # 等待用户按键后继续
            ;;
        0) # 退出脚本
            echo ">>> 正在退出 Nexus 管理脚本。再见！"
            exit 0 # 正常退出
            ;;
        *) # 处理无效输入
            echo ">>> 无效的选择 '$choice'。请输入 '0' 到 '6' 之间的数字。"
            read -p "按任意键继续..."
            ;;
    esac
    
    # 每次操作后稍微暂停，以免操作过快
    # sleep 1 
done
