#!/bin/bash
set -e

# ================================================================================================
# Nexus 多节点管理脚本 (ARM64 Docker) - v4.1.12 Buildx 极度健壮/诊断增强版
#
# 改版者: AI & 社区智慧
#
# 【V4.1.12 更新】:
#   - 【Buildx 创建极端健壮性】: setup_buildx 函数经过深度重构，
#     增加了更多校验、更强制的清理、重试逻辑（尽管直接创建时重试较少），
#     以及对 binfmt 支持的反复确认。
#   - 【Builder 状态确认】: 在尝试移除 Builder 前后，都会有明确的检查，确保操作的影响。
#   - 【BuildxLs 检查】: 增强了 `docker buildx ls` 命令的输出读取，以获取更清晰的状态。
#   - 【修复 docker stats 解析】: 修复了 list_nodes 中 docker stats 在子shell中执行导致变量不生效的问题。
#   - 【优化菜单对齐】: 修复了菜单中带颜色文字的对齐问题。
#   - 【增强错误诊断】: 增加了更多错误检查点和诊断信息，特别是关于Docker和Buildx的初始化。
#
# ... (保留之前的 V4.1.11, V4.1.10, V4.1.9, V4.1.8, V4.1.7, V4.1.6, V4.1.5, V4.1.4, V4.1.3, V4.1.2, V4.1.1, V4.0 更新说明) ...
# ================================================================================================

# --- 配置项 (可在此处自定义) ---
SCRIPT_VERSION="v4.1.12 Buildx 极度健壮/诊断增强版"
# --- 此处已更新 nexus-cli 版本 ---
NEXUS_CLI_VERSION="v0.10.7"
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest-arm64"
LOG_DIR="/root/nexus_logs"
BUILDER_NAME="nexus_builder"

# --- 颜色定义 ---
COLOR_RESET='\033[0m'
COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[0;33m'
COLOR_BLUE='\033[0;34m'
COLOR_CYAN='\033[0;36m'
COLOR_BOLD='\033[1m' # 增加加粗颜色

# --- 辅助函数 ---
print_color() { echo -e "${2}${1}${COLOR_RESET}"; }
print_success() { print_color "$1" "$COLOR_GREEN"; }
print_error() { print_color "$1" "$COLOR_RED"; }
print_warning() { print_color "$1" "$COLOR_YELLOW"; }
print_info() { print_color "$1" "$COLOR_CYAN"; }
print_bold() { print_color "$1" "${COLOR_BOLD}${COLOR_CYAN}"; }

confirm_action() {
    local prompt_message="$1"
    read -rp "${COLOR_YELLOW}>>> ${prompt_message} (y/N): ${COLOR_RESET}" confirm
    [[ "$confirm" =~ ^[yY]([eE][sS])?$ ]]
}

# Initialize TMP_WORKDIR outside trap to ensure it's always set before mktemp is called
TMP_WORKDIR=""
# Robust trap handler for cleanup.
trap 'EXITCODE=$?; printf "\n"; print_info "Executing cleanup operations..."; if [ -n "$TMP_WORKDIR" ] && [ -d "$TMP_WORKDIR" ]; then rm -rf "$TMP_WORKDIR"; fi; exit $EXITCODE' EXIT HUP INT QUIT TERM

# --- Core Functions ---
check_docker_daemon() {
    print_info "正在检查 Docker 服务状态..."
    if ! docker info >/dev/null 2>&1; then
        print_error "!! 致命错误: Docker 服务未运行或当前用户无权访问 !!"
        if ! systemctl is-active docker >/dev/null 2>&1; then
            print_error "    Docker 服务 (${COLOR_YELLOW}docker${COLOR_RESET}) 状态: ${COLOR_RED} inactive/dead${COLOR_RESET}."
            print_error "    请尝试启动 Docker: ${COLOR_CYAN}sudo systemctl start docker${COLOR_RESET}"
            print_error "    并设为开机自启: ${COLOR_CYAN}sudo systemctl enable docker${COLOR_RESET}"
        else
            print_error "    Docker 服务 (${COLOR_YELLOW}docker${COLOR_RESET}) 正在运行，但当前用户可能没有权限访问。"
            print_error "    请确保脚本以 root 用户运行 (${COLOR_CYAN}sudo su${COLOR_RESET} 或 ${COLOR_CYAN}sudo ./your_script.sh${COLOR_RESET})。"
        fi
        exit 1
    fi
    print_success "Docker 服务已成功运行。"
}

check_docker() {
    print_info "正在检查 Docker CLI 和 Buildx 插件..."
    if ! command -v docker >/dev/null 2>&1; then
        print_warning "未检测到 Docker 命令, 正在尝试自动安装..."
        if ! dpkg --print-architecture | grep -q "arm64"; then
            print_error "!! 警告: 当前系统不是 ARM64 架构, 脚本主要为 ARM64 设计。安装可能失败或运行不兼容。!!"
        fi

        print_info "正在执行 Docker 安装准备步骤..."
        if ! apt-get update -qq; then
            print_warning "apt update 失败，尝试继续安装。请检查网络连接或软件源配置。"
        fi
        
        print_info "正在安装 Docker 所需的依赖包..."
        if ! apt-get install -y --no-install-recommends apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release >/dev/null 2>&1; then
            print_warning "部分依赖安装失败，Docker 安装可能受影响。脚本将继续尝试。"
        fi

        print_info "正在添加 Docker 的 GPG 签名密钥..."
        mkdir -p /etc/apt/keyrings
        if ! curl -fsSL --fail https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg; then
             print_error "!! Docker GPG key 下载或处理失败 !! 这是安装 Docker 的关键步骤，无法继续。"
             exit 1
        fi
        if [ ! -s /etc/apt/keyrings/docker.gpg ]; then 
             print_error "!! Docker GPG key 文件 '/etc/apt/keyrings/docker.gpg' 创建失败或为空 !! 无法继续。"
             exit 1
        fi
        print_success "Docker GPG 密钥已成功添加到 /etc/apt/keyrings/。"

        print_info "正在配置 Docker 的 APT 软件源..."
        echo \
          "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
          $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
        print_success "Docker APT 源配置完成。"

        print_info "正在更新 APT 软件包列表..."
        if ! apt-get update -qq; then
            print_warning "apt update 失败，可能影响 Docker CE 的安装。"
        fi
        
        print_info "正在安装 Docker CE (Community Edition) 和 Docker Buildx 插件..."
        if ! apt-get install -y --no-install-recommends docker-ce docker-ce-cli containerd.io docker-buildx-plugin >/dev/null 2>&1; then
            print_error "!! Docker CE 或 Buildx 插件安装失败 !! 脚本将终止，请检查以上错误信息。"
            exit 1
        fi
        print_success "Docker CE 及相关插件安装完成。"

        print_info "正在启动并启用 Docker 服务..."
        if ! systemctl is-active docker >/dev/null 2>&1; then
            if ! systemctl start docker; then
                print_error "Docker 服务启动失败！"
                print_error "请尝试手动启动: ${COLOR_CYAN}sudo systemctl start docker${COLOR_RESET}"
                exit 1
            fi
        fi
        if ! systemctl is-enabled docker >/dev/null 2>&1; then
             if ! systemctl enable docker; then
                print_warning "Docker 服务开机自启设置失败。请检查 systemctl 状态。"
             fi
        fi
        print_success "Docker 服务已准备就绪。"
    fi

    # Verify docker buildx plugin after ensuring Docker CLI is present.
    if ! docker buildx version >/dev/null 2>&1; then
        print_error "错误：未找到 Docker buildx 插件或无法使用。这是构建多架构镜像的关键组件。"
        print_warning "正在尝试安装 'docker-buildx-plugin' (如果之前安装失败或未安装)..."
        if ! apt-get update -qq >/dev/null; then
            print_warning "apt update 失败，可能影响 buildx 插件安装。"
        fi
        if ! apt-get install -y --no-install-recommends docker-buildx-plugin >/dev/null 2>&1; then
             print_error "!! Docker buildx 插件安装失败 !! "
             print_error "   请尝试手动安装: ${COLOR_CYAN}sudo apt-get install docker-buildx-plugin${COLOR_RESET}"
             exit 1
        fi
        # Re-check after attempt to install.
        if ! docker buildx version >/dev/null 2>&1; then
            print_error "!! Docker buildx 插件安装后仍然无法使用。!! 脚本将无法继续。"
            exit 1
        fi
        print_success "Docker buildx 插件已成功安装。"
    else
        print_success "Docker CLI 和 Buildx 插件均已就绪。"
    fi
}

# Helper to get builder status and default flag
get_builder_info() {
    local builder_name="$1"
    local builder_line=""
    if docker buildx ls >/dev/null 2>&1; then
        builder_line=$(docker buildx ls | grep -w "^${builder_name}")
    fi

    if [ -z "$builder_line" ]; then
        echo "NOT_FOUND" # Builder not found
        return
    fi

    # Extract status (e.g., "running", "stopped")
    local status=""
    if echo "$builder_line" | grep -q "running"; then
        status="running"
    elif echo "$builder_line" | grep -q "stopped"; then
        status="stopped"
    fi

    # Check if it's the default builder (has an asterisk)
    local is_default="false"
    if echo "$builder_line" | grep -q "^\s*${builder_name}\s\+\*\s"; then
        is_default="true"
    fi

    echo "$status $is_default" # Return "status is_default_flag"
}


# --- SETUP BUILDX - EXTREME ROBUSTNESS FOR CREATE FAILURES (此函数已被修改和增强) ---
setup_buildx() {
    print_info "正在检查和配置 Buildx builder '$BUILDER_NAME'..."

    # 1. 【核心优化】确保 binfmt 支持，这是多架构构建的基石，且应在创建 builder 前完成。
    print_info "正在检查和配置多架构构建所需的 binfmt 支持..."
    
    # Pre-pull binfmt image to avoid 'not found' issues during run
    if ! docker image inspect tonistiigi/binfmt:latest >/dev/null 2>&1; then
        print_info "正在拉取 'tonistiigi/binfmt:latest' 镜像..."
        if ! docker pull tonistiigi/binfmt:latest >/dev/null 2>&1; then
            print_error "!! 致命错误: 无法拉取 'tonistiigi/binfmt:latest' 镜像。请检查网络连接。!!"
            exit 1
        fi
    fi

    local binfmt_activated="false"
    local retry_count=0
    local max_retries=3
    while [ "$binfmt_activated" == "false" ] && [ "$retry_count" -lt "$max_retries" ]; do
        if docker run --rm --privileged tonistiigi/binfmt:latest --print 2>/dev/null | grep -q "supported"; then
            print_success "Binfmt 支持已正确配置，跳过安装。"
            binfmt_activated="true"
        else
            if [ "$retry_count" -eq 0 ]; then
                print_warning "Binfmt 支持未被确认为已激活状态。尝试安装或更新 'tonistiigi/binfmt' 映像以确保支持..."
                if ! docker run --rm --privileged tonistiigi/binfmt:latest --install all >/dev/null 2>&1; then
                    print_warning "首次执行 binfmt 安装命令可能遇到问题，尝试再次执行..."
                fi
            fi
            retry_count=$((retry_count + 1))
            if [ "$binfmt_activated" == "false" ] && [ "$retry_count" -lt "$max_retries" ]; then
                print_info "Binfmt 检查失败，等待 2 秒后重试 ($retry_count/$max_retries)..."
                sleep 2
            fi
        fi
    done

    if [ "$binfmt_activated" == "false" ]; then
        print_error "!! 致命错误: binfmt support 安装或激活失败，无法继续。!! "
        print_error "   请确保您的系统内核支持 binfmt_misc (您可以通过 ${COLOR_CYAN}lsmod | grep binfmt_misc${COLOR_RESET} 查看)。"
        print_error "   您还可以尝试手动运行：${COLOR_CYAN}sudo docker run --rm --privileged tonistiigi/binfmt:latest --install all${COLOR_RESET} "
        exit 1 # Binfmt 安装失败是硬伤，必须退出
    fi

    # 2. 【核心优化】主动移除现有 builder，并在必要时进行强制移除。
    local current_builder_info
    IFS=' ' read -r current_status current_is_default <<< "$(get_builder_info "$BUILDER_NAME")"
    
    if [ "$current_status" != "NOT_FOUND" ]; then
        print_warning "检测到 Buildx builder '$BUILDER_NAME' 已存在。"
        print_info "其当前状态: $current_status (默认: $current_is_default)"
        
        print_info "执行强制清理：尝试移除 Buildx builder '$BUILDER_NAME'..."
        
        # First, try to stop it if it's running.
        if [ "$current_status" == "running" ]; then
            print_info "Builder '$BUILDER_NAME' 正在运行，尝试停止..."
            docker buildx stop "$BUILDER_NAME" >/dev/null 2>&1 || print_warning "停止 Buildx builder '$BUILDER_NAME' 失败，但将尝试强制移除。"
            sleep 1
        fi

        # Then, remove it.
        if ! docker buildx rm "$BUILDER_NAME" >/dev/null 2>&1; then
            print_warning "Buildx builder '$BUILDER_NAME' 正常移除失败。可能是 Builder 损坏或卡住。尝试强制移除..."
            if ! docker buildx rm --force "$BUILDER_NAME" >/dev/null 2>&1; then
                print_error "!! 致命错误: 强制移除 Buildx builder '$BUILDER_NAME' 失败。!!"
                print_error "    此问题无法自动解决。请检查 Docker 日志，并尝试手动执行："
                print_error "    ${COLOR_CYAN}sudo docker buildx rm --force ${BUILDER_NAME}${COLOR_RESET}"
                exit 1 # 如果无法清理旧的，就无法创建新的，因此必须退出
            fi
        fi
        sleep 1 # 暂停以确保 Docker Daemon 有时间处理移除操作
        
        # Verify removal
        IFS=' ' read -r post_removal_status _ <<< "$(get_builder_info "$BUILDER_NAME")"
        if [ "$post_removal_status" != "NOT_FOUND" ]; then
            print_error "!! 致命错误: 移除 Buildx builder '$BUILDER_NAME' 失败，Builder 仍然存在。!!"
            print_error "    此问题无法自动解决。请参考上述错误信息和手动排查步骤。"
            exit 1 
        else
            print_success "Buildx builder '$BUILDER_NAME' 已被成功清理（或之前就不存在）。"
        fi
    else
        print_info "未检测到现有 Buildx builder '$BUILDER_NAME'，准备创建新 builder。"
    fi
    
    # 3. 创建新的 Builder
    print_info "正在创建新的 Buildx builder '$BUILDER_NAME'..."
    # The --bootstrap option makes it start and verify. The --use option makes it default.
    if ! docker buildx create --name "$BUILDER_NAME" --driver docker-container --bootstrap --use >/dev/null 2>&1; then
        print_error "!! Buildx builder '$BUILDER_NAME' 创建失败！!!"
        print_error "    这是构建镜像的关键前置条件，脚本无法继续。\n"
        print_error "    可能原因及排查步骤：\n"
        print_error "    1. Docker Daemon 状态异常。请检查：${COLOR_CYAN}sudo systemctl status docker${COLOR_RESET}"
        print_error "    2. ${COLOR_YELLOW}docker buildx create${COLOR_RESET} 详细日志：${COLOR_CYAN}sudo journalctl -u docker.service -f${COLOR_RESET} (在另一个终端运行此命令，然后再次执行本脚本尝试创建)"
        print_error "    3. 系统资源不足或Docker配置问题。\n"
        exit 1 # 无法创建 Builder 是灾难性的，无法继续
    fi
    
    # Verify builder is running and set as default.
    local created_builder_status_final=""
    local created_builder_is_default_final=""
    IFS=' ' read -r created_builder_status_final created_builder_is_default_final <<< "$(get_builder_info "$BUILDER_NAME")"

    if [ "$created_builder_status_final" == "running" ] && [ "$created_builder_is_default_final" == "true" ]; then
        print_success "Buildx builder '$BUILDER_NAME' 已成功创建并设置为默认 (状态: running, 默认: true)。"
    else
        print_error "!! Buildx builder '$BUILDER_NAME' 创建成功，但状态异常或未设置为默认。!!"
        print_error "    当前状态: ${created_builder_status_final:-'未知'} (默认: ${created_builder_is_default_final:-'未知'})"
        print_error "    请尝试手动运行: ${COLOR_CYAN}sudo docker buildx use ${BUILDER_NAME}${COLOR_RESET} 并检查状态。"
        exit 1 # Still critical, as build might fail.
    fi
}

build_image() {
    local force_build=${1:-""}
    if [[ -z "$force_build" ]] && docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        print_info "镜像 '$IMAGE_NAME' 已存在，跳过构建。如需强制构建，请在主菜单中选择更新选项。"
        return
    fi
    
    setup_buildx # Ensure builder is ready before build. setup_buildx will handle errors.
    
    # Create temporary directory for Docker build context.
    TMP_WORKDIR=$(mktemp -d -t nexus_docker_build_XXXXXX)
    # The global trap handler will clean up TMP_WORKDIR.
    
    cd "$TMP_WORKDIR" || { print_error "无法进入临时目录 '$TMP_WORKDIR'。"; exit 1; }
    
    local cli_url="https://github.com/nexus-xyz/nexus-cli/releases/download/${NEXUS_CLI_VERSION}/nexus-network-linux-arm64"
    
    print_info "正在生成 Dockerfile 及 entrypoint 脚本..."
    
    # Dockerfile setup: Essential for building the image.
    cat <<EOF > Dockerfile
ARG TARGETPLATFORM=linux/arm64
FROM --platform=\$TARGETPLATFORM ubuntu:24.04
ENV DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y --no-install-recommends curl screen netcat-openbsd ca-certificates && rm -rf /var/lib/apt/lists/*
RUN mkdir -p /usr/local/bin && curl --cacert /etc/ssl/certs/ca-certificates.crt -L -o /usr/local/bin/nexus-network ${cli_url} && chmod +x /usr/local/bin/nexus-network
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
VOLUME /root/.nexus
EXPOSE 8080
EOF

    # Entrypoint script for running Nexus network.
    cat <<EOF > entrypoint.sh
#!/bin/bash
set -e
if [ -z "\$NODE_ID" ]; then echo "错误: NODE_ID 环境变量未设置！" >&2; exit 1; fi
if ! command -v nexus-network >/dev/null 2>&1; then echo "错误: nexus-network 命令不存在!" >&2; exit 1; fi
echo "准备 Nexus 节点 (NODE_ID: \$NODE_ID)..."
mkdir -p /root/.nexus && echo "\$NODE_ID" > /root/.nexus/node-id
LOG_FILE="/root/nexus.log"
SCREEN_SESSION_NAME="nexus_\$NODE_ID"
# Clean up previous screen sessions for the same node if they exist
if screen -list | grep -q "\. N:\$SCREEN_SESSION_NAME"; then
  echo "正在停止现有的 Nexus 进程 (Screen session: \$SCREEN_SESSION_NAME)..."
  screen -S "\$SCREEN_SESSION_NAME" -X quit || true
  sleep 1
fi
echo "正在后台启动 Nexus 节点 (NODE_ID: \$NODE_ID)..."
screen -dmS "\$SCREEN_SESSION_NAME" bash -c "exec nexus-network start --node-id \$NODE_ID | tee -a \$LOG_FILE"
sleep 2
if ! screen -list | grep -q "\. N:\$SCREEN_SESSION_NAME"; then
  echo "!! Nexus 节点启动失败 (Screen session: \$SCREEN_SESSION_NAME), 请检查日志: \$LOG_FILE !! " >&2
  cat \$LOG_FILE >&2 || true
  exit 1
fi
echo "Nexus 节点 \${NODE_ID} 启动成功，屏幕会话 '\${SCREEN_SESSION_NAME}'。"
# Keep the container running indefinitely by tailing a file.
tail -f /dev/null
EOF

    print_info "正在构建节点镜像 '$IMAGE_NAME' (Nexus CLI: ${NEXUS_CLI_VERSION})，此过程可能需要几分钟..."
    # Build using the builder. Redirecting stderr of docker buildx to better capture potential build-time errors.
    # Add --progress=plain for more verbose output on errors if needed, or remove >/dev/null 2>&1 temporarily.
    if ! docker buildx build --builder "$BUILDER_NAME" --platform linux/arm64 -t "$IMAGE_NAME" . --load >/dev/null 2>&1; then
        print_error "!! Docker buildx build 过程中出错！构建镜像失败。!!\n"
        print_error "    构建失败是灾难性的，无法继续。请检查 Docker buildx 和 Daemon 日志。\n"
        print_error "    您可以通过运行以下命令查看构建的详细输出（临时移除上述命令中的 '> /dev/null 2>&1'）："
        print_error "    ${COLOR_CYAN}docker buildx build --builder ${BUILDER_NAME} --platform linux/arm64 -t ${IMAGE_NAME} . --load${COLOR_RESET}"
        exit 1 
    fi
    
    print_success "镜像 '$IMAGE_NAME' 构建完成。"
}

run_container() {
    local node_id="$1"
    if [ -z "$node_id" ]; then print_error "错误: 未提供 Node ID"; return 1; fi
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    # Manage existing container: stop and remove it.
    if docker ps -a -q -f name="${container_name}" | grep -q .; then
        print_info "容器 '$container_name' 已存在。正在停止并移除旧容器..."
        docker stop "$container_name" > /dev/null 2>&1 || print_warning "停止容器 '$container_name' 失败（可能已停止）。"
        if ! docker rm "$container_name" > /dev/null 2>&1; then
            print_warning "移除容器 '$container_name' 失败。可能是容器正忙或存在卷问题。"
        fi
    fi

    # Prepare log directory and file. Ensure it exists and has correct permissions.
    mkdir -p "$LOG_DIR"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"
    # Create or truncate the log file and set permissions.
    if ! touch "$log_file" >/dev/null 2>&1 || ! chmod 644 "$log_file" >/dev/null 2>&1; then
        print_error "!! 无法创建或设置日志文件 '$log_file' 的权限。 !!\n    请检查 '$LOG_DIR' 目录的权限。"
        return 1 
    fi
    
    print_info "正在启动节点 ${node_id} (容器名: ${container_name})..."
    # Execute docker run, with careful error checking.
    if ! docker run -d --name "$container_name" \
        -v "${log_file}:/root/nexus.log:rw" \
        -e NODE_ID="$node_id" \
        --restart unless-stopped \
        "$IMAGE_NAME" >/dev/null 2>&1; then
        
        print_error "!! Docker run 命令执行失败 !! 容器 '${container_name}' 未能启动。\n"
        print_error "    请检查 Docker Daemon 日志 (${COLOR_CYAN}sudo journalctl -u docker.service${COLOR_RESET}) 以及镜像 '$IMAGE_NAME' 的有效性。"
        # Attempt to show logs for diagnosis from the *container's perspective* via `docker logs`.
        # The /root/nexus.log inside the container won't exist immediately on failure, so better check `docker logs`.
        print_error "--- Trying to get container logs for diagnosis: ---"
        docker logs "$container_name" 2>&1 || print_error "Could not retrieve container logs. It might not have started at all."
        print_error "-----------------------------------------------"
        return 1 # Container start failure is critical, return 1 to indicate failure.
    fi
    
    sleep 3 # Allow time for container and its entrypoint to initialize.
    
    # Final check: ensure container is running after 'run' command.
    if ! docker ps -q -f name="${container_name}" | grep -q .; then
        print_error "节点 ${node_id} (${container_name}) 启动后未在运行！\n    这是一个严重问题。请仔细检查容器日志 (通过菜单选项 2 查看日志)。"
        return 1 # Indicate failure.
    else
        print_success "节点 $node_id ($container_name) 已成功启动。日志路径: $log_file"
        return 0 # Indicate success.
    fi
}

stop_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    # Check if container exists at all (running or stopped).
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_error "未找到容器 '$container_name'。"
        return 1
    fi

    # Check if container is running.
    if docker ps --format '{{.Names}}' | grep -qw "$container_name"; then
        print_info "正在停止节点 $node_id ($container_name)..."
        if ! docker stop "$container_name" > /dev/null 2>&1; then
             print_error "!! Docker stop 命令失败 !! 容器 '${container_name}' 可能未能停止。"
             return 1
        else
             print_success "节点 $node_id ($container_name) 已停止。"
             return 0
        fi
    else # Container exists but is already stopped.
        print_info "节点 $node_id ($container_name) 已停止。无需再次停止。"
        return 0
    }

start_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    # Check if container exists (even if stopped).
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_info "正在启动节点 $node_id ($container_name)..."
        if ! docker start "$container_name" > /dev/null 2>&1; then
            print_error "!! Docker start 命令失败 !! 容器 '${container_name}' 未能启动。"
            return 1
        fi
        sleep 3
        if docker ps -q -f name="${container_name}" | grep -q .; then
            print_success "节点 $node_id ($container_name) 已启动。"
            return 0
        else
            print_error "节点 $node_id ($container_name) 启动后状态异常，请检查日志 (菜单选项 2)。"
            return 1 # Indicate failure.
        fi
    else
        print_error "未找到容器 '$container_name'。请先使用安装功能。"
        return 1 # Indicate failure.
    fi
}

restart_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_info "正在重启节点 $node_id ($container_name)..."
        if ! docker restart "$container_name" > /dev/null 2>&1; then
            print_error "!! Docker restart 命令失败 !! 容器 '${container_name}' 未能重启。"
            return 1
        fi
        sleep 3
        if docker ps -q -f name="${container_name}" | grep -q .; then
            print_success "节点 $node_id ($container_name) 已重启。"
            return 0
        else
            print_error "节点 $node_id ($container_name) 重启后状态异常，请检查日志 (菜单选项 2)。"
            return 1 # Indicate failure.
        fi
    else
        print_error "未找到容器 '$container_name'。"
        return 1 # Indicate failure.
    fi
}

uninstall_node() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    print_info "正在卸载节点 $node_id (容器名: ${container_name})..."
    
    # Check if container exists before trying to stop/remove.
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        docker stop "$container_name" > /dev/null 2>&1 || print_warning "停止容器 '$container_name' 失败（可能已停止或不存在）。"
        if ! docker rm "$container_name" > /dev/null 2>&1; then
            print_warning "移除容器 '$container_name' 失败。可能因为它正在使用中或其他问题。"
            return 1 # Indicate failure.
        else
            print_success "容器 '$container_name' 已移除。"
        fi
    else
        print_info "容器 '$container_name' 不存在，跳过移除。"
    fi
    
    local log_file="${LOG_DIR}/nexus-${node_id}.log"
    if [ -f "$log_file" ]; then
        if ! rm -f "$log_file"; then
            print_warning "无法移除日志文件 '$log_file'。"
        else
            print_info "已移除日志文件: $log_file"
        fi
    fi
    return 0 # Indicate success.
}

get_all_node_ids() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}" | sed "s/^${BASE_CONTAINER_NAME}-//" | sort -u
}

view_node_logs() {
    local node_id="$1"
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        print_error "错误: 未找到容器 '$container_name'。"
        return 1
    fi
    
    print_info "正在查看节点 ${node_id} ($container_name) 的日志。按 Ctrl+C 退出。"
    
    if docker ps -q -f name="${container_name}" | grep -q .; then
        print_color "--- Streaming logs from running container '$container_name' ---" "$COLOR_BLUE"
        if ! docker logs -f "$container_name"; then
            print_warning "Log streaming for '$container_name' interrupted or failed. Check container status."
        fi
    else
        local log_file="${LOG_DIR}/nexus-${node_id}.log"
        if [ -f "$log_file" ]; then
            print_color "--- Showing logs from file '$log_file' (container is stopped) ---" "$COLOR_YELLOW"
            if ! cat "$log_file"; then
                print_warning "Could not display log file content for '$log_file'."
            fi
            print_color "--- End of log file ---" "$COLOR_YELLOW"
        else
            print_warning "Log file for node $node_id not found. Container is stopped and no log file exists at $log_file."
        fi
    fi
    return 0
}

# --- LIST NODES FUNCTION - PARSED STATS CORRECTLY ---
list_nodes() {
    print_color "============================== 当前 Nexus 节点状态 ===============================" "$COLOR_BLUE"
    printf "%-40s %-28s %-12s %-18s %s\n" \
        "$(print_bold "节点 ID (容器名)")" \
        "$(print_bold "状态")" \
        "$(print_bold "CPU %")" \
        "$(print_bold "内存使用")" \
        "$(print_bold "镜像")"
    print_color "--------------------------------------------------------------------------------------" "$COLOR_BLUE"
    
    local all_node_info=() # Stores node_id:container_name pairs
    
    # 1. Gather all potential nodes by listing containers matching our naming pattern.
    while IFS= read -r container_name; do
        local node_id
        node_id=$(echo "$container_name" | sed "s/^${BASE_CONTAINER_NAME}-//")
        all_node_info+=("$node_id:$container_name")
    done < <(docker ps -a --filter "name=${BASE_CONTAINER_NAME}-" --format "{{.Names}}")

    if [ ${#all_node_info[@]} -eq 0 ]; then
        print_warning "未找到任何 Nexus 节点容器。"
    else
        local running_container_names=()
        while IFS= read -r cname; do
            running_container_names+=("$cname")
        done < <(docker ps -f name="${BASE_CONTAINER_NAME}-" --format "{{.Names}}")

        declare -A stats_map # Associative array for stats: container_name -> "CPU%\tMemUsage"
        
        if [ ${#running_container_names[@]} -gt 0 ]; then
            local stats_output=""
            # Use `docker stats` command, ensuring it doesn't fail.
            # Only run if there are actual running containers to get stats for.
            if ! stats_output=$(docker stats --no-stream --format "{{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" "${running_container_names[@]}" 2>/dev/null); then
                print_warning "无法获取运行中容器的统计信息 (docker stats 命令可能失败)。"
            else
                # Parse stats_output line by line using here string to avoid subshell issues with stats_map.
                while IFS=$'\t' read -r name cpu_perc_raw mem_usage_raw; do
                    if [[ "$name" == "NAME" ]]; then # Skip header
                        continue
                    fi
                    
                    # Remove ANSI escape codes (colors) and trim whitespace
                    local cpu_perc=$(echo "$cpu_perc_raw" | sed 's/\x1b\[[0-9;]*m//g' | xargs)
                    local mem_usage=$(echo "$mem_usage_raw" | sed 's/\x1b\[[0-9;]*m//g' | xargs)

                    [ -z "$cpu_perc" ] && cpu_perc="N/A"
                    [ -z "$mem_usage" ] && mem_usage="N/A"
                    
                    stats_map["$name"]="$cpu_perc"$'\t'"$mem_usage"
                done <<< "$stats_output" # <-- THIS IS THE KEY FIX
            fi
        fi
        
        for item in "${all_node_info[@]}"; do
            IFS=':' read -r node_id container_name <<< "$item"
            
            local status_raw="Unknown"
            local formatted_status
            local cpu_perc="N/A" 
            local mem_usage="N/A"  
            local image_name="<none>"
            local display_node_info="$node_id ($container_name)" 

            local container_details
            container_details=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}\t{{.Image}}")

            if [ -n "$container_details" ]; then
                status_raw=$(echo "$container_details" | cut -f1)
                image_name=$(echo "$container_details" | cut -f2)
                
                if [[ "$status_raw" == *"Up"* ]]; then
                    formatted_status=$(print_color "$status_raw" "$COLOR_GREEN")
                    # Retrieve stats from the map if available
                    if [[ -v stats_map["$container_name"] ]]; then
                        IFS=$'\t' read -r cpu_perc mem_usage <<< "${stats_map["$container_name"]}"
                    else
                        cpu_perc="N/A" 
                        mem_usage="N/A" 
                    fi
                elif [[ "$status_raw" == *"Exited"* ]]; then
                    formatted_status=$(print_color "$status_raw" "$COLOR_YELLOW")
                else 
                    formatted_status=$(print_color "$status_raw" "$COLOR_RED")
                fi
            else
                formatted_status="$(print_color "Not Found" "$COLOR_RED")"
                image_name="-"
                display_node_info="$node_id ($container_name - Stale)"
            fi
            
            if [ ${#image_name} -gt 25 ]; then image_name="${image_name:0:22}..."; fi

            printf "%-40s %-28s %-12s %-18s %s\n" "$display_node_info" "$formatted_status" "$cpu_perc" "$mem_usage" "$image_name"
        done
    fi
    print_color "======================================================================================" "$COLOR_BLUE"
}


# --- Menu Handling Functions ---
select_node_action() {
    local action_callback="$1"
    local prompt_message="$2"
    
    local available_nodes=()
    while IFS= read -r node_id; do
        # Only add nodes that actually have a container (running or stopped)
        if docker ps -a --filter "name=${BASE_CONTAINER_NAME}-${node_id}" --format '{{.Names}}' | grep -q .; then
            available_nodes+=("$node_id")
        fi
    done < <(get_all_node_ids)

    if [ ${#available_nodes[@]} -eq 0 ]; then
        print_warning "当前无任何节点可操作。"
        read -n 1 -s -r -p "按任意键返回..."
        return 1 # Indicate no nodes found
    fi
    
    echo "请选择要'${prompt_message}'的节点:"
    
    for i in "${!available_nodes[@]}"; do
        local node_id="${available_nodes[$i]}"
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status="Not Found"
        local container_info
        container_info=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}")
        if [ -n "$container_info" ]; then status="$container_info"; fi
        
        local color="$COLOR_RED"
        if [[ "$status" == *"Up"* ]]; then color="$COLOR_GREEN"; elif [[ "$status" == *"Exited"* ]]; then color="$COLOR_YELLOW"; fi
        
        printf "  ${COLOR_CYAN}%2d.${COLOR_RESET} %-30s " "$((i+1))" "$node_id ($container_name)"
        print_color "[$status]" "$color" # Print status with color separately to avoid alignment issues
    done

    echo "   0. 返回主菜单"
    
    read -rp "${COLOR_YELLOW}请输入选项 (0-${#available_nodes[@]}): ${COLOR_RESET}" choice
    
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 0 ] || [ "$choice" -gt ${#available_nodes[@]} ]; then
        print_error "无效输入。"
        sleep 1
        return 1
    fi
    
    [ "$choice" -eq 0 ] && return 0
    
    local selected_node_id="${available_nodes[$((choice-1))]}"
    if ! "$action_callback" "$selected_node_id"; then
        print_error "Action '$action_callback' for node '$selected_node_id' failed."
        return 1
    fi
    
    read -n 1 -s -r -p "按任意键返回..."
    return 0
}

select_multiple_nodes_action() {
    local action_callback="$1"
    local prompt_message="$2"
    
    local available_nodes=()
    while IFS= read -r node_id; do
        if docker ps -a --filter "name=${BASE_CONTAINER_NAME}-${node_id}" --format '{{.Names}}' | grep -q .; then
            available_nodes+=("$node_id")
        fi
    done < <(get_all_node_ids)

    if [ ${#available_nodes[@]} -eq 0 ]; then
        print_warning "当前无任何节点可操作。"
        read -n 1 -s -r -p "按任意键返回..."
        return 1 # Indicate no nodes found
    fi
    
    echo "请选择要'${prompt_message}'的节点 (输入数字, 可多选, 用空格隔开; 输入 'all' 全选):"
    
    for i in "${!available_nodes[@]}"; do
        local node_id="${available_nodes[$i]}"
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status="Not Found"
        local container_info
        container_info=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}")
        if [ -n "$container_info" ]; then status="$container_info"; fi

        local color="$COLOR_RED"
        if [[ "$status" == *"Up"* ]]; then color="$COLOR_GREEN"; elif [[ "$status" == *"Exited"* ]]; then color="$COLOR_YELLOW"; fi
        
        printf "  ${COLOR_CYAN}%2d.${COLOR_RESET} %-30s " "$((i+1))" "$node_id ($container_name)"
        print_color "[$status]" "$color" # Print status with color separately
    done
    echo "   0. 返回主菜单"

    read -rp "${COLOR_YELLOW}请输入选项: ${COLOR_RESET}" choices_str
    if [[ -z "$choices_str" ]] || [[ "$choices_str" == "0" ]]; then return 0; fi

    local selected_nodes=()
    if [[ "$choices_str" == "all" ]]; then
        selected_nodes=("${available_nodes[@]}")
    else
        local cleaned_choices=$(echo "$choices_str" | tr ',' ' ' | xargs)
        local choices_array=($cleaned_choices)
        
        for choice in "${choices_array[@]}"; do
            if [[ "$choice" =~ ^[1-9][0-9]*$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#available_nodes[@]} ]; then
                selected_nodes+=("${available_nodes[$((choice-1))]}")
            else
                print_warning "输入 '$choice' 无效, 已忽略。"
            在菜单中选择更新/维护选项 (11) 进行构建。"
    fi

    # Main application loop.
    while true; do
        clear
        # Menu header.
        print_color "================================================================================" "$COLOR_BLUE"
        print_color "           Nexus 管理脚本 (ARM64 Docker) - ${SCRIPT_VERSION}" "$COLOR_CYAN"
        print_color "================================================================================" "$COLOR_BLUE"
        
        list_nodes # Display the current status of all nodes.

        echo # Blank line for spacing.
        # Menu options with consistent formatting.
        print_info "\n--- 节点管理 ---"
        echo "  ${COLOR_CYAN}1${COLOR_RESET}. 安装/启动单个节点        ${COLOR_CYAN}4${COLOR_RESET}. 停止指定节点"
        echo "  ${COLOR_CYAN}2${COLOR_RESET}. 查看指定节点日志         ${COLOR_CYAN}5${COLOR_RESET}. 启动已停止的节点"
        echo "  ${COLOR_CYAN}3${COLOR_RESET}. 卸载指定节点             ${COLOR_CYAN}6${COLOR_RESET}. 重启指定节点"

        print_info "\n--- 批量操作 ---"
        echo "  ${COLOR_CYAN}7${COLOR_RESET}. 批量安装/启动新节点      ${COLOR_CYAN}10${COLOR_RESET}. 批量卸载节点"
        echo "  ${COLOR_CYAN}8${COLOR_RESET}. 批量停止节点             "
        echo "  ${COLOR_CYAN}9${COLOR_RESET}. 批量启动节点             "

        print_info "\n--- 系统维护 ---"
        # Direct mapping to system maintenance sub-menu.
        echo "  ${COLOR_CYAN}11${COLOR_RESET}. 系统更新与维护"
        echo "   ${COLOR_CYAN}0${COLOR_RESET}. 退出脚本"
        echo
        
        # Prompt for user input.
        read -rp "${COLOR_YELLOW}请输入选项: ${COLOR_RESET}" choice
        
        # Process user choice.
        case $choice in
            1) menu_install_single ;;
            2) select_node_action "view_node_logs" "查看日志" ;;
            3) select_node_action "uninstall_node" "卸载" ;;
            4) select_node_action "stop_node" "停止" ;;
            5) select_node_action "start_node" "启动" ;;
            6) select_node_action "restart_node" "重启" ;;
            
            7) menu_batch_install ;;
            8) select_multiple_nodes_action "stop_node" "停止" ;;
            9) select_multiple_nodes_action "start_node" "启动" ;;
            10) select_multiple_nodes_action "uninstall_node" "卸载" ;;

            11) menu_update ;; # Call the sub-menu for updates and maintenance.
            
            0) print_info "感谢使用 Nexus 管理脚本，再见！"; exit 0 ;; # Graceful exit.
            *) print_error "无效选项，请重新输入。" && sleep 1 ;; # Handle invalid input.
        esac
    done
}

# --- Script Entry Point ---
main_menu
