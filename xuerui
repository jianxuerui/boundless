#!/bin/bash

# 脚本名称：MyAwesomeScript - 通用管理模板
# 作者：你的名字/你的推特账号
# 版本：1.0
# 描述：这是一个多功能 Bash 脚本模板，用于展示脚本的结构和交互模式。
#      你可以基于此模板创建你自己的个性化管理脚本，例如管理自定义服务、
#      运行定期任务、或者作为某个应用程序的启动/停止/更新器。

# 设置脚本在遇到错误时退出
set -e

# =========================================================================
# 常量定义 - 根据你的脚本用途修改这些路径和名称
# =========================================================================
# 你的应用程序或任务的主目录
MY_APP_DIR="$HOME/my_awesome_app"
# 应用程序或任务的主要执行文件（例如：一个可执行文件或另一个脚本）
# 如果你的程序在 MY_APP_DIR 内部有复杂启动逻辑，这里可以留空或指向 start.sh
MY_APP_EXEC_PATH="$MY_APP_DIR/run_app.sh"
# 后台进程的 PID 文件，用于管理周期性任务
PERIODIC_TASK_PID_FILE="/tmp/my_awesome_script_periodic.pid"
# 脚本自身的日志文件
SCRIPT_LOG_FILE="$HOME/my_awesome_script.log"
# Screen 会话的名称，用于在后台运行你的程序
SCREEN_SESSION_NAME="my_awesome_session"
# 你的应用程序可能用到的额外数据目录（例如：配置、日志、数据）
MY_APP_DATA_DIR="$MY_APP_DIR/data"
MY_APP_CONFIG_FILE="$MY_APP_DIR/config.conf"

# =========================================================================
# 颜色定义 - 用于在终端输出中增加可读性
# =========================================================================
RED='\033[0;31m'    # 红色
GREEN='\033[0;32m'  # 绿色
YELLOW='\033[0;33m' # 黄色
BLUE='\033[0;34m'   # 蓝色
PURPLE='\033[0;35m' # 紫色
CYAN='\033[0;36m'   # 青色
NC='\033[0m'        # No Color - 重置颜色

# =========================================================================
# 辅助函数 - 封装常用操作，提高代码复用性
# =========================================================================

# 辅助函数：输出日志到文件并同时打印到控制台
log_message() {
    echo -e "[$(date +'%Y-%m-%d %H:%M:%S')] $1" | tee -a "$SCRIPT_LOG_FILE"
}

# 辅助函数：暂停并等待用户按下 Enter 键
pause_and_return() {
    echo -e "${YELLOW}按 Enter 键返回菜单...${NC}"
    read -r
}

# 辅助函数：启动你的应用程序在一个新的 screen 会话中
start_app_in_screen() {
    log_message "${YELLOW}正在尝试启动应用程序 '$SCREEN_SESSION_NAME' 会话...${NC}"

    if [ ! -d "$MY_APP_DIR" ]; then
        log_message "${RED}错误：无法找到应用程序目录 ($MY_APP_DIR)。请确保已执行选项 1 初始化。${NC}"
        return 1
    fi

    # 切换到应用程序目录 (如果你的执行脚本需要上下文路径)
    # cd "$MY_APP_DIR" || { log_message "${RED}错误：无法切换到 $MY_APP_DIR 目录。${NC}"; return 1; }

    # 终止现有的 screen 会话（如果存在）
    if screen -list | grep -q "$SCREEN_SESSION_NAME"; then
        log_message "${YELLOW}检测到现有 screen 会话 '$SCREEN_SESSION_NAME'，正在终止...${NC}"
        screen -S "$SCREEN_SESSION_NAME" -X quit || true # `|| true` 防止因为没有会话而退出
        sleep 1 # 稍微等待 screen 进程结束
    fi

    log_message "${GREEN}正在新的 screen 会话 '$SCREEN_SESSION_NAME' 中启动应用程序...${NC}"
    # 在这里，MY_APP_EXEC_PATH 应该是一个可执行文件或者可被 bash 执行的脚本
    # 如果 MY_APP_EXEC_PATH 需要在特定目录下运行，请使用 cd $MY_APP_DIR && 完整路径
    screen -dmS "$SCREEN_SESSION_NAME" bash -c "cd '$MY_APP_DIR' && '$MY_APP_EXEC_PATH' >> '$MY_APP_DIR/app.log' 2>&1"
    
    if [ $? -ne 0 ]; then
        log_message "${RED}错误：启动应用程序失败。请检查 $MY_APP_EXEC_PATH 脚本或权限。${NC}"
        return 1
    else
        log_message "${GREEN}应用程序已在 screen 会话 '$SCREEN_SESSION_NAME' 中成功启动！${NC}"
        log_message "您可以通过选项 2 或运行 '${YELLOW}screen -r $SCREEN_SESSION_NAME${NC}' 进入会话查看实时状态。"
        log_message "按 ${YELLOW}Ctrl+A${NC} 然后按 ${YELLOW}D${NC} 退出 screen 会话而不终止程序。"
        return 0
    fi
}

# 辅助函数：停止周期性后台进程（通用）
disable_periodic_task() {
    log_message "${YELLOW}正在检查并禁用周期性后台进程...${NC}"
    if [ -f "$PERIODIC_TASK_PID_FILE" ]; then
        PID=$(cat "$PERIODIC_TASK_PID_FILE")
        if ps -p "$PID" > /dev/null 2>&1; then # 检查 PID 是否仍然活跃
            kill "$PID" 2>/dev/null || true # 尝试终止进程
            log_message "${GREEN}已终止 PID $PID 对应的周期性后台进程。${NC}"
        else
            log_message "${YELLOW}周期性任务 PID 文件 ($PID) 存在，但进程已不存在。${NC}"
        fi
        rm -f "$PERIODIC_TASK_PID_FILE" || true
    else
        log_message "${YELLOW}未找到周期性任务的 PID 文件，无需禁用。${NC}"
    fi
}

# =========================================================================
# 主要功能函数 - 对应主菜单的各项选择
# =========================================================================

# 功能：初始化并运行你的应用程序/服务
init_and_run_app() {
    echo -e "${YELLOW}=== 初始化并运行您的应用程序 ===${NC}"
    echo -e "${GREEN}请输入您的应用程序或服务的唯一标识符/名称 (例如: 您的用户ID或项目名): ${NC}"
    read -r APP_ID

    if [ -z "$APP_ID" ]; then
        log_message "${RED}错误：应用程序标识符不能为空。${NC}"
        return 1
    fi

    log_message "${GREEN}正在为应用程序 '$APP_ID' 设置环境...${NC}"

    # 1. 创建必要的目录
    mkdir -p "$MY_APP_DIR" "$MY_APP_DATA_DIR" || { log_message "${RED}错误：无法创建应用程序目录。${NC}"; return 1; }
    log_message "应用程序主目录已创建：$MY_APP_DIR"
    log_message "应用程序数据目录已创建：$MY_APP_DATA_DIR"

    # 2. 模拟下载或生成核心应用程序文件
    log_message "${YELLOW}模拟：正在下载或生成核心应用程序文件到 $MY_APP_DIR...${NC}"
    echo "#!/bin/bash" > "$MY_APP_EXEC_PATH"
    echo "echo 'My Awesome App is running for $APP_ID! Time: \$(date)'" >> "$MY_APP_EXEC_PATH"
    echo "sleep 30" # 模拟程序运行一段时间
    echo "echo 'My Awesome App finished its task.'" >> "$MY_APP_EXEC_PATH"
    chmod +x "$MY_APP_EXEC_PATH" || { log_message "${RED}错误：无法设置执行权限。${NC}"; return 1; }
    log_message "核心执行脚本已创建并设置权限：$MY_APP_EXEC_PATH"

    # 3. 模拟配置文件的生成或更新
    log_message "${YELLOW}模拟：正在创建或更新应用程序配置文件：$MY_APP_CONFIG_FILE...${NC}"
    echo "APP_IDENTIFIER=$APP_ID" > "$MY_APP_CONFIG_FILE"
    echo "LAST_INIT_TIME=$(date)" >> "$MY_APP_CONFIG_FILE"
    log_message "配置文件已生成。"

    log_message "${YELLOW}环境设置完成，尝试启动应用程序...${NC}"
    sleep 3 # 给文件系统一点时间同步

    start_app_in_screen
    if [ $? -eq 0 ]; then
        log_message "${GREEN}应用程序已初始化并启动完成。${NC}"
        echo -e "${BLUE}请根据您的实际应用程序需求修改此函数内部的命令和逻辑。${NC}"
        echo -e "${CYAN}您可以通过选项 2 查看 'app.log' 或 screen 会话来检查程序的运行状况。${NC}"
    fi
}

# 功能：查看 screen 会话日志或脚本日志
view_logs() {
    log_message "${YELLOW}=== 查看日志文件 ===${NC}"
    echo -e "${GREEN}1. 查看脚本自身管理日志 ($SCRIPT_LOG_FILE)${NC}"
    echo -e "${GREEN}2. 进入应用程序 Screen 会话 ($SCREEN_SESSION_NAME) 查看实时输出${NC}"
    echo -e "${YELLOW}请输入您的选择（1-2）：${NC}"
    read -r log_choice

    case $log_choice in
        1)
            if [ -f "$SCRIPT_LOG_FILE" ]; then
                log_message "${CYAN}正在显示脚本日志，按 Ctrl+C 停止。${NC}"
                tail -f "$SCRIPT_LOG_FILE"
            else
                log_message "${RED}错误：脚本日志文件 ($SCRIPT_LOG_FILE) 不存在。${NC}"
            fi
            ;;
        2)
            if screen -list | grep -q "$SCREEN_SESSION_NAME"; then
                log_message "${GREEN}找到 screen 会话 '$SCREEN_SESSION_NAME'。${NC}"
                echo -e "您将进入 screen 会话查看实时输出，命令为：${YELLOW}screen -r $SCREEN_SESSION_NAME${NC}"
                echo -e "按 ${YELLOW}Ctrl+A${NC} 然后按 ${YELLOW}D${NC} 退出 screen 会话而不终止程序。"
                screen -r "$SCREEN_SESSION_NAME"
            else
                log_message "${RED}错误：未找到名为 '$SCREEN_SESSION_NAME' 的 screen 会话。${NC}"
                log_message "${YELLOW}请确保已通过选项 1 或 3 启动应用程序。${NC}"
            fi
            ;;
        *)
            log_message "${RED}无效的选择。${NC}"
            ;;
    esac
}

# 功能：管理应用程序/服务
manage_app_service() {
    while true; do
        clear
        echo -e "=== ${GREEN}应用程序服务管理子菜单${NC} ==="
        echo "1. 手动启动/重启应用程序服务"
        echo "2. 启用周期性自动检查并启动应用程序（每小时）"
        echo "3. 禁用周期性自动检查任务"
        echo "4. 返回主菜单"
        echo -e "${YELLOW}请输入您的选择（1-4）：${NC}"
        read -r sub_choice

        case $sub_choice in
            1)
                log_message "${YELLOW}正在尝试手动启动/重启应用程序...${NC}"
                disable_periodic_task # 确保手动连接时不会有旧的自动连接在干扰
                start_app_in_screen
                pause_and_return
                ;;
            2)
                log_message "${YELLOW}启用周期性自动检查并启动应用程序（每小时）...${NC}"
                disable_periodic_task # 确保只运行一个实例

                log_message "周期性任务日志将记录在 ${YELLOW}$SCRIPT_LOG_FILE${NC}"
                # 启动后台循环
                (
                    log_message "--- 周期性服务监控任务已启动 on $(date) ---"
                    while true; do
                        log_message "[$(date)] ${YELLOW}尝试自动检查并启动应用程序...${NC}"
                        if ! screen -list | grep -q "$SCREEN_SESSION_NAME"; then # 检查 screen 会话是否还在
                            if start_app_in_screen; then # 如果会话不在，尝试启动
                                log_message "[$(date)] ${GREEN}自动启动成功。${NC}"
                            else
                                log_message "[$(date)] ${RED}自动启动失败。${NC}"
                            fi
                        else
                            log_message "[$(date)] ${CYAN}应用程序 '$SCREEN_SESSION_NAME' 正在运行中，跳过启动。${NC}"
                        fi
                        log_message "[$(date)] ${YELLOW}等待 1 小时后再次检查...${NC}"
                        sleep 3600 # 每小时（3600秒）执行一次
                    done
                ) &
                PID=$!
                echo "$PID" > "$PERIODIC_TASK_PID_FILE"
                log_message "${GREEN}周期性服务监控已在后台启用 (PID: $PID)。${NC}"
                pause_and_return
                ;;
            3)
                disable_periodic_task
                pause_and_return
                ;;
            4)
                return 0
                ;;
            *)
                log_message "${RED}无效的选择，请输入 1-4。${NC}"
                pause_and_return
                ;;
        esac
    done
}

# 功能：更新你的应用程序或脚本
update_my_app() {
    echo -e "=== ${GREEN}更新我的应用程序/脚本${NC} ==="
    # 1. 检查应用程序是否已安装
    if [ ! -d "$MY_APP_DIR" ]; then
        log_message "${RED}错误：应用程序目录 ($MY_APP_DIR) 不存在。请先选择选项 1 初始化。${NC}"
        return 1
    fi

    echo -e "${YELLOW}警告：更新操作将${RED}终止${YELLOW}当前运行的应用程序，${RED}下载/替换最新版本${YELLOW}并可能${RED}修改配置文件${YELLOW}。${NC}"
    echo -e "如果已启用周期性任务，它将被临时禁用并随新版本启动后重新激活。"
    echo -e "${YELLOW}是否继续？（y/n）${NC}"
    read -r confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        log_message "${YELLOW}更新操作已取消。${NC}"
        return 0
    fi

    # 禁用周期性任务，防止更新时其启动旧版本
    disable_periodic_task

    # 停止 screen 会话
    if screen -list | grep -q "$SCREEN_SESSION_NAME"; then
        log_message "${YELLOW}正在终止 '$SCREEN_SESSION_NAME' screen 会话...${NC}"
        screen -S "$SCREEN_SESSION_NAME" -X quit || true
        sleep 1
    fi

    log_message "${YELLOW}进入应用程序目录 ($MY_APP_DIR)...${NC}"
    cd "$MY_APP_DIR" || { log_message "${RED}错误：无法切换到 $MY_APP_DIR 目录。${NC}"; return 1; }

    # === 在这里添加你的具体更新逻辑 ===
    log_message "${YELLOW}模拟：正在删除旧的应用程序文件和数据...${NC}"
    rm -f "run_app.sh" || true # 删除模拟的执行文件
    rm -rf "$MY_APP_DATA_DIR" || true # 删除数据目录，如果需要完全刷新
    log_message "${YELLOW}模拟：正在下载或替换新的应用程序文件...${NC}"
    # 例如：curl -L "你的应用程序新版本下载URL" -o new_app_binary
    # cp /path/to/new_version/run_app.sh . # 如果新版本在你本地
    echo "#!/bin/bash" > "$MY_APP_EXEC_PATH"
    echo "echo 'My Awesome App is running (UPDATED!)! Time: \$(date)'" >> "$MY_APP_EXEC_PATH"
    echo "sleep 30"
    chmod +x "$MY_APP_EXEC_PATH" || { log_message "${RED}错误：无法设置新的执行文件权限。${NC}"; return 1; }
    log_message "${YELLOW}模拟：更新 config.conf 文件 (例如：更改 API 端点)...${NC}"
    # 例如：sed -i 's#old_api_endpoint#new_api_endpoint#' config.conf
    # 为本示例添加一个更新标记
    echo "LAST_UPDATE_TIME=$(date)" >> "$MY_APP_CONFIG_FILE"
    # ==================================

    log_message "${GREEN}应用程序文件已成功更新。现在重新启动...${NC}"
    start_app_in_screen

    log_message "${GREEN}我的应用程序更新并重新启动完成。${NC}"
    echo -e "请使用选项 2 查看日志确认运行状态。"
}

# 功能：卸载并清理你的应用程序/服务
uninstall_my_app() {
    echo -e "${RED}警告：此操作将终止 '$SCREEN_SESSION_NAME' screen 会话，删除所有周期性任务，并删除 $MY_APP_DIR 目录下的所有文件！${NC}"
    echo -e "${YELLOW}这是${RED}不可逆${YELLOW}的操作。请务必确认！${NC}"
    echo -e "${YELLOW}是否继续？（y/n）${NC}"
    read -r confirm
    if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
        disable_periodic_task # 禁用所有周期性任务

        # 检查并终止 screen 会话
        if screen -list | grep -q "$SCREEN_SESSION_NAME"; then
            screen -S "$SCREEN_SESSION_NAME" -X quit || true
            log_message "${GREEN}已终止 '$SCREEN_SESSION_NAME' screen 会话。${NC}"
        else
            log_message "${YELLOW}未找到 '$SCREEN_SESSION_NAME' screen 会话，跳过终止步骤。${NC}"
        fi

        # 删除应用程序主目录
        if [ -d "$MY_APP_DIR" ]; then
            log_message "${YELLOW}正在删除 $MY_APP_DIR 目录...${NC}"
            rm -rf "$MY_APP_DIR"
            if [ $? -eq 0 ]; then
                log_message "${GREEN}已成功删除 $MY_APP_DIR 目录。${NC}"
            else
                log_message "${RED}错误：删除 $MY_APP_DIR 目录失败，请检查权限或目录状态。${NC}"
                return 1
            fi
        else
            log_message "${YELLOW}未找到 $MY_APP_DIR 目录，跳过删除步骤。${NC}"
        fi
        
        # 删除脚本自身的日志文件（可选）
        if [ -f "$SCRIPT_LOG_FILE" ]; then
            log_message "${YELLOW}正在删除脚本日志文件 ($SCRIPT_LOG_FILE)...${NC}"
            rm -f "$SCRIPT_LOG_FILE" || true
            log_message "${GREEN}已删除脚本日志文件。${NC}"
        fi

        log_message "${GREEN}卸载操作完成。${NC}"
    else
        log_message "${YELLOW}操作已取消，未删除任何内容。${NC}"
    fi
}

# =========================================================================
# 主菜单循环 - 程序的入口点
# =========================================================================
while true; do
    clear
    echo -e "============================================"
    echo -e "${GREEN}=== 脚本由你的名字免费开源，分享自由 ===${NC}"
    echo -e "${YELLOW}=== MyAwesomeScript 通用管理菜单 ===${NC}"
    echo -e "============================================"
    echo -e "${BLUE}1. 初始化并运行应用程序/服务${NC}"
    echo -e "${BLUE}2. 查看应用程序/脚本日志${NC}"
    echo -e "${BLUE}3. 管理应用程序服务（手动启动/周期性检查）${NC}"
    echo -e "${BLUE}4. 更新我的应用程序/脚本${NC}"
    echo -e "${BLUE}5. 卸载/清理应用程序数据${NC}"
    echo -e "${RED}6. 退出脚本${NC}"
    echo -e "============================================"
    echo -e "${YELLOW}请输入您的选择（1-6）：${NC}"
    read -r choice

    case $choice in
        1)
            init_and_run_app
            pause_and_return
            ;;
        2)
            view_logs
            pause_and_return # 在tail -f返回后会等待
            ;;
        3)
            manage_app_service
            ;;
        4)
            update_my_app
            pause_and_return
            ;;
        5)
            uninstall_my_app
            pause_and_return
            ;;
        6)
            log_message "${YELLOW}退出脚本...${NC}"
            exit 0
            ;;
        *)
            log_message "${RED}无效的选择，请输入 1-6。${NC}"
            pause_and_return
            ;;
    esac
done
