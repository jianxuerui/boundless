#!/bin/bash
set -e

BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs"

# --- 内存自动分配相关配置 ---
# 容器内存分配比例（例如，占宿主机总内存的比例，例如 0.25 代表 1/4）
CONTAINER_MEM_RATIO=0.25
# 容器内存最大限制 (MB)，避免单个节点占用过多资源
CONTAINER_MEM_MAX_MB=8192  # 8GB
# 容器内存最小限制 (MB)，确保节点至少有基础运行内存
CONTAINER_MEM_MIN_MB=2048  # 2GB
# --- 配置结束 ---

# --- 检查 jq 和 bc 工具是否安装 ---
function install_utility_if_not_exists() {
    local utility=$1
    local package_name=$utility
    if ! command -v "$utility" >/dev/null 2>&1; then
        echo "检测到未安装 $utility，正在安装..."
        if command -v apt >/dev/null 2>&1; then # Debian/Ubuntu
            apt update -qq && apt install -y -qq "$package_name"
        elif command -v yum >/dev/null 2>&1; then # CentOS/RHEL
            yum install -y "$package_name"
        elif command -v dnf >/dev/null 2>&1; then # Fedora
            dnf install -y "$package_name"
        else
            echo "无法自动安装 $utility。请手动安装。"
            return 1
        fi
        if ! command -v "$utility" >/dev/null 2>&1; then
            echo "安装 $utility 失败！"
            return 1
        else
            echo "$utility 已成功安装。"
            return 0
        fi
    fi
    return 0
}

# 检查 Docker 是否安装
function check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "检测到未安装 Docker，正在安装..."
        apt update -qq
        apt install -y -qq apt-transport-https ca-certificates curl software-properties-common
        # 检查 /usr/share/keyrings 是否存在，这是 GPG 密钥存储的推荐位置
        if [ ! -d /usr/share/keyrings ]; then
            mkdir -p /usr/share/keyrings
        fi
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
        # 使用 LSB Release 获取 Ubuntu 代号，适配不同版本的 Ubuntu
        echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
        apt update -qq
        apt install -y -qq docker-ce
        systemctl enable docker
        systemctl start docker
        echo "Docker 已安装并启动。"
    fi
}

# 检查 Node.js/npm/pm2 是否安装 (PM2 在本脚本中未直接使用，但作为检查保留)
function check_pm2() {
    if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
        echo "检测到未安装 Node.js/npm，正在安装..."
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
        apt update -qq
        apt install -y -qq nodejs
    fi
    if ! command -v pm2 >/dev/null 2>&1; then
        echo "检测到未安装 pm2，正在安装..."
        npm install -g pm2
    fi
}

# 构建docker镜像函数
function build_image() {
    echo "开始构建 Nexus Docker 镜像 (Image Name: ${IMAGE_NAME})..."
    local WORKDIR
    WORKDIR=$(mktemp -d)
    cd "$WORKDIR" || { echo "创建临时目录失败！"; exit 1; }

    # 创建 Dockerfile
    cat > Dockerfile <<EOF
FROM ubuntu:24.04

LABEL author="哈哈哈哈 <哈哈哈哈@example.com>"

ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id

RUN apt-get update && apt-get install -y \
    curl \
    screen \
    bash \
    && rm -rf /var/lib/apt/lists/*

# 自动下载安装最新版 nexus-network
RUN curl -sSL https://cli.nexus.xyz/ | NONINTERACTIVE=1 sh \
    && ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network \
    && echo "Nexus network installed."

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh \
    && echo "Entrypoint script prepared."

ENTRYPOINT ["/entrypoint.sh"]
EOF

    # 创建 entrypoint.sh
    cat > entrypoint.sh <<EOF
#!/bin/bash
set -e

PROVER_ID_FILE="/root/.nexus/node-id"

if [ -z "\$NODE_ID" ]; then
    echo "错误：未设置 NODE_ID 环境变量"
    exit 1
fi

# 确保 .nexus 目录存在
mkdir -p /root/.nexus

echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo "设置 Node ID: \$NODE_ID"

if ! command -v nexus-network >/dev/null 2>&1; then
    echo "错误：nexus-network 命令未找到。请确保 Nexus 已正确安装在容器内。"
    exit 1
fi

# 查找并停止名为 'nexus' 的 screen 会话，如果存在
screen -S nexus -X quit >/dev/null 2>&1 || true

echo "启动 nexus-network 节点..."
# 使用 screen 后台运行 nexus-network，并将日志输出到 /root/nexus.log
# 允许其自由运行（&>>），并在屏幕会话内后台执行
screen -dmS nexus bash -c "nexus-network start --node-id \$NODE_ID &>> /root/nexus.log"

sleep 3

# 检查 screen 会话是否成功启动
if screen -list | grep -q "nexus"; then
    echo "节点已在后台 screen 会话 'nexus' 中启动。"
    echo "Nexus 节点日志文件在容器内的路径是: /root/nexus.log"
    echo "可以通过 'docker logs <container_name>' 或 'docker attach <container_name>' 来查看日志。"
else
    echo "节点启动失败！请检查 /root/nexus.log 文件中的错误信息："
    cat /root/nexus.log
    exit 1
fi

# 此处不应执行 tail -f /root/nexus.log，因为 Docker 的 entrypoint
# 在返回后应该退出，否则容器会一直保持运行，直到 Docker 检测到异常。
# 日志应该由 docker logs 命令来捕获。
# 我们只是为了确认启动状态而 cat 一下，然后正常退出。
# 为了保持脚本执行完成的效果，我们可以输出一个成功提示然后正常退出。
echo "Nexus 节点启动流程已完成。请通过 docker logs 查看实时日志。"
exit 0
EOF

    # 执行 Docker 构建命令
    if ! docker build -t "$IMAGE_NAME" .; then
        echo "Docker 镜像构建失败！"
        cd - > /dev/null
        rm -rf "$WORKDIR"
        exit 1
    fi

    cd - > /dev/null
    rm -rf "$WORKDIR"
    echo "Nexus Docker 镜像构建成功！ (Image Name: ${IMAGE_NAME})"
}

# 获取宿主机总内存和可用内存 (单位 MB)
function get_host_memory() {
    local total_mem_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    local available_mem_kb=$(grep MemAvailable /proc/meminfo | awk '{print $2}') # MemAvailable 是更准确的可用内存

    # 如果MemAvailable不存在，则尝试使用MemFree作为后备 (但不推荐)
    if [ -z "$available_mem_kb" ]; then
        available_mem_kb=$(grep MemFree /proc/meminfo | awk '{print $2}')
    fi

    local total_mem_mb=$((total_mem_kb / 1024))
    local available_mem_mb=$((available_mem_kb / 1024))

    echo "$total_mem_mb $available_mem_mb"
}

# 启动容器（挂载宿主机日志文件）
# 返回 0 表示成功, 1 表示失败
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "检测到旧容器 '$container_name'，先停止并删除..."
        if ! docker rm -f "$container_name"; then
            echo "删除旧容器 '$container_name' 失败，请检查。"
            # 即使删除失败，也尝试继续创建新容器，但这是一个潜在的问题
        fi
    fi

    # 确保日志目录存在
    mkdir -p "$LOG_DIR"
    
    # 确保宿主机日志文件存在并有写权限
    if [ ! -f "$log_file" ]; then
        touch "$log_file"
        chmod 644 "$log_file"
    fi

    # --- 计算容器内存限制 ---
    local host_total_mem_mb
    local host_available_mem_mb
    read host_total_mem_mb host_available_mem_mb <<< $(get_host_memory)

    # 确保获取到内存信息
    if [ -z "$host_total_mem_mb" ] || [ -z "$host_available_mem_mb" ]; then
        echo "错误：无法获取宿主机内存信息。"
        return 1
    fi

    echo "宿主机总内存: ${host_total_mem_mb} MB, 可用内存: ${host_available_mem_mb} MB"

    # 使用 bc 进行浮点数计算，然后四舍五入并转换为整数
    # 确保 bc 已经安装
    if ! install_utility_if_not_exists "bc"; then
        echo "错误：没有 bc 工具无法进行浮点数内存计算。"
        return 1
    fi

    local allocated_mem_float=$(echo "$host_total_mem_mb * $CONTAINER_MEM_RATIO" | bc)
    local allocated_mem_mb=$(printf "%.0f" "$allocated_mem_float") # 四舍五入到整数

    # 确保分配的内存不会超过最大限制
    if [ "$allocated_mem_mb" -gt "$CONTAINER_MEM_MAX_MB" ]; then
        allocated_mem_mb="$CONTAINER_MEM_MAX_MB"
    fi

    # 确保分配的内存不小于最小限制
    if [ "$allocated_mem_mb" -lt "$CONTAINER_MEM_MIN_MB" ]; then
        allocated_mem_mb="$CONTAINER_MEM_MIN_MB"
    fi

    # 再次校验：确保分配的内存不大于宿主机的可用内存
    # 如果计算出的值大于可用内存，则按可用内存的 90% 进行调整
    if [ "$allocated_mem_mb" -gt "$host_available_mem_mb" ]; then
        echo "警告：根据配置的内存比例计算出的 ${allocated_mem_mb}MB 可能大于当前可用内存 ${host_available_mem_mb}MB。"
        echo "将尝试为节点 '$node_id' 分配可用内存的 90%."
        local available_adjusted_float=$(echo "$host_available_mem_mb * 0.9" | bc)
        allocated_mem_mb=$(printf "%.0f" "$available_adjusted_float")

        # 再次确保不小于最小限制
        if [ "$allocated_mem_mb" -lt "$CONTAINER_MEM_MIN_MB" ]; then
            allocated_mem_mb="$CONTAINER_MEM_MIN_MB"
        fi

        # 最后一次检查：如果连最小内存都无法满足，则报错并退出
        if [ "$allocated_mem_mb" -gt "$host_available_mem_mb" ]; then
            echo "错误：宿主机可用内存 (${host_available_mem_mb}MB) 不足以满足调整后的最小内存要求 (${allocated_mem_mb}MB)。无法启动节点 '$node_id'。"
            return 1 # 返回错误码
        fi
    fi
    
    echo "为容器 '$container_name' (Node ID: $node_id) 分配内存: ${allocated_mem_mb}MB"

    # 使用 docker run 命令，并添加 -m 参数
    # 注意：Docker 的内存限制 `-m` 值后面需要跟单位，如 'm' for MB, 'g' for GB
    if ! docker run -d --name "$container_name" -m "${allocated_mem_mb}m" -v "$log_file":/root/nexus.log -e NODE_ID="$node_id" "$IMAGE_NAME"; then
        echo "启动容器 '$container_name' 失败。"
        return 1 # 返回错误码
    fi

    echo "容器 '$container_name' 已启动！ (Node ID: $node_id)"
    return 0 # 返回成功码
}

# 显示所有运行中的节点
function list_nodes() {
    if ! install_utility_if_not_exists "jq"; then
        echo "警告：没有 jq 工具，部分内存信息可能无法准确显示。"
    fi
    
    echo "当前节点状态："
    echo "----------------------------------------------------------------------------------------------------------------------------------"
    # 稍微调整列宽以适应更多信息
    printf "%-6s %-20s %-10s %-15s %-15s %-15s %-20s %-20s\n" "序号" "节点ID" "CPU使用率" "内存使用" "内存限制" "状态" "启动时间" "容器名"
    echo "----------------------------------------------------------------------------------------------------------------------------------"
    
    local all_nodes=($(get_all_nodes)) # 获取所有节点ID，无论运行与否
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "未发现任何 Nexus 节点。"
        echo "----------------------------------------------------------------------------------------------------------------------------------"
        read -p "按任意键返回菜单"
        return
    fi

    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        
        # 获取容器基础信息
        local container_status
        container_status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}" 2>/dev/null || echo "NOTFOUND")
        local created_time
        created_time=$(docker ps -a --filter "name=$container_name" --format "{{.CreatedAt}}" 2>/dev/null || echo "N/A")

        if [ "$container_status" = "NOTFOUND" ]; then
             printf "%-6d %-20s %-10s %-15s %-15s %-15s %-20s %-20s\n" \
                $((i+1)) \
                "$node_id" \
                "N/A" \
                "N/A" \
                "N/A" \
                "未运行" \
                "$created_time" \
                "$container_name (不存在)"
            continue # 跳过本轮循环
        fi
        
        local cpu_usage="N/A"
        local mem_usage="N/A"
        local memory_limit_mb="N/A"

        # 如果容器状态不是 Exited, 则尝试获取 stat 和 inspect 信息
        if [[ ! "$container_status" == Exited* ]]; then
            # 获取当前 CPU 和内存使用情况 (使用 docker stats)
            local container_stats=$(docker stats --no-stream --format "{{.CPUPerc}},{{.MemUsage}}" "$container_name" 2>/dev/null)
            
            if [ -n "$container_stats" ]; then
                # 解析 STATS 信息
                local cpu_usage_raw mem_usage_raw
                IFS=',' read -r cpu_usage_raw mem_usage_raw <<< "$container_stats"
                
                cpu_usage=$(echo "$cpu_usage_raw" | awk '{print $1 "%"}')
                mem_usage=$(echo "$mem_usage_raw" | awk '{print $1 "/" $3}') # 例如 10.2MiB / 7.86GiB

                # 获取容器的内存限制 (使用 docker inspect)
                if command -v jq >/dev/null 2>&1; then
                    local memory_limit_bytes
                    memory_limit_bytes=$(docker inspect "$container_name" | jq '.[0].HostConfig.Memory')
                    
                    if [ -n "$memory_limit_bytes" ] && [ "$memory_limit_bytes" != "null" ]; then
                        # Docker inspect 返回的是字节，需要转换为 MB
                        memory_limit_mb=$((memory_limit_bytes / 1024 / 1024))
                    fi
                else
                    # 如果没有 jq, 尝试用 grep/cut, 但 JSON 解析不准确时易出错
                    memory_limit_mb="?" # 表示无法获取或 jq 未安装
                fi
            else
                # docker stats 失败 (容器可能刚启动或停止太快)
                cpu_usage="-"
                mem_usage="-"
            fi
        else
            # 如果容器是 Exited 状态
            cpu_usage="-"
            mem_usage="-"
            # 即使容器停止，也尝试显示内存限制，因为它可能是之前设定的值
            if command -v jq >/dev/null 2>&1; then
                local memory_limit_bytes
                memory_limit_bytes=$(docker inspect "$container_name" | jq '.[0].HostConfig.Memory')
                if [ -n "$memory_limit_bytes" ] && [ "$memory_limit_bytes" != "null" ]; then
                    memory_limit_mb=$((memory_limit_bytes / 1024 / 1024))
                fi
            fi
        fi
        
        # 格式化内存限制显示
        local mem_limit_display="N/A"
        if [ "$memory_limit_mb" != "N/A" ]; then
            mem_limit_display="${memory_limit_mb}MB"
        fi

        # 显示节点信息
        printf "%-6d %-20s %-10s %-15s %-15s %-15s %-20s %-20s\n" \
            $((i+1)) \
            "$node_id" \
            "$cpu_usage" \
            "$mem_usage" \
            "$mem_limit_display" \
            "$(echo "$container_status" | cut -d' ' -f1)" \
            "$created_time" \
            "$container_name"
    done
    echo "----------------------------------------------------------------------------------------------------------------------------------"
    echo "提示："
    echo "- CPU使用率：显示容器CPU占用百分比。"
    echo "- 内存使用：显示容器当前实际占用的内存（使用率/总量）。"
    echo "- 内存限制：显示容器设定的最大内存限制值。"
    echo "- 状态：显示容器的运行状态（如 Up, Exited）。"
    echo "- 启动时间：显示容器的创建时间。"
    read -p "按任意键返回菜单"
}

# 启动容器（挂载宿主机日志文件）
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "检测到旧容器 '$container_name'，先停止并删除..."
        if ! docker rm -f "$container_name"; then
            echo "删除旧容器 '$container_name' 失败，请检查。"
            # 即使删除失败，也尝试继续创建新容器，但这是一个潜在的问题
        fi
    fi

    # 确保日志目录存在
    mkdir -p "$LOG_DIR"
    
    # 确保宿主机日志文件存在并有写权限
    if [ ! -f "$log_file" ]; then
        touch "$log_file"
        chmod 644 "$log_file"
    fi

    # --- 计算容器内存限制 ---
    local host_total_mem_mb
    local host_available_mem_mb
    read host_total_mem_mb host_available_mem_mb <<< $(get_host_memory)

    # 确保获取到内存信息
    if [ -z "$host_total_mem_mb" ] || [ -z "$host_available_mem_mb" ]; then
        echo "错误：无法获取宿主机内存信息。"
        return 1
    fi

    echo "宿主机总内存: ${host_total_mem_mb} MB, 可用内存: ${host_available_mem_mb} MB"

    # 确保 bc 已经安装
    if ! install_utility_if_not_exists "bc"; then
        echo "错误：没有 bc 工具无法进行浮点数内存计算。"
        return 1
    fi

    # 使用 bc 进行浮点数计算，然后四舍五入并转换为整数
    local allocated_mem_float=$(echo "$host_total_mem_mb * $CONTAINER_MEM_RATIO" | bc)
    local allocated_mem_mb=$(printf "%.0f" "$allocated_mem_float") # 四舍五入到整数

    # 确保分配的内存不会超过最大限制
    if [ "$allocated_mem_mb" -gt "$CONTAINER_MEM_MAX_MB" ]; then
        allocated_mem_mb="$CONTAINER_MEM_MAX_MB"
    fi

    # 确保分配的内存不小于最小限制
    if [ "$allocated_mem_mb" -lt "$CONTAINER_MEM_MIN_MB" ]; then
        allocated_mem_mb="$CONTAINER_MEM_MIN_MB"
    fi

    # 再次校验：确保分配的内存不大于宿主机的可用内存
    # 如果计算出的值大于可用内存，则按可用内存的 90% 进行调整
    if [ "$allocated_mem_mb" -gt "$host_available_mem_mb" ]; then
        echo "警告：根据配置的内存比例计算出的 ${allocated_mem_mb}MB 可能大于当前可用内存 ${host_available_mem_mb}MB。"
        echo "将尝试为节点 '$node_id' 分配可用内存的 90%。"
        local available_adjusted_float=$(echo "$host_available_mem_mb * 0.9" | bc)
        allocated_mem_mb=$(printf "%.0f" "$available_adjusted_float")

        # 再次确保不小于最小限制
        if [ "$allocated_mem_mb" -lt "$CONTAINER_MEM_MIN_MB" ]; then
            allocated_mem_mb="$CONTAINER_MEM_MIN_MB"
        fi

        # 最后一次检查：如果连最小内存都无法满足，则报错并退出
        if [ "$allocated_mem_mb" -gt "$host_available_mem_mb" ]; then
            echo "错误：宿主机可用内存 (${host_available_mem_mb}MB) 不足以满足调整后的最小内存要求 (${allocated_mem_mb}MB)。无法启动节点 '$node_id'。"
            return 1 # 返回错误码
        fi
    fi
    
    echo "为容器 '$container_name' (Node ID: $node_id) 分配内存: ${allocated_mem_mb}MB"

    # 使用 docker run 命令，并添加 -m 参数
    if ! docker run -d --name "$container_name" -m "${allocated_mem_mb}m" -v "$log_file":/root/nexus.log -e NODE_ID="$node_id" "$IMAGE_NAME"; then
        echo "启动容器 '$container_name' 失败。"
        return 1 # 返回错误码
    fi

    echo "容器 '$container_name' 已启动！ (Node ID: $node_id)"
    return 0 # 返回成功码
}


# 停止并卸载容器和镜像、删除日志
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo "停止并删除容器 '$container_name'..."
    # 仅在容器存在时删除
    if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        if ! docker rm -f "$container_name"; then
            echo "删除容器 '$container_name' 失败。"
        else
            echo "容器 '$container_name' 已停止并删除。"
        fi
    else
        echo "容器 '$container_name' 不存在或已停止。"
    fi

    if [ -f "$log_file" ]; then
        echo "删除日志文件 '$log_file' ..."
        rm -f "$log_file"
    else
        echo "日志文件不存在: '$log_file'"
    fi

    echo "节点 '$node_id' 的清理完成。"
}

# 显示所有节点信息（包括未运行的），并提供选择操作
function list_and_select_operation() {
    echo "当前节点列表 (包括已停止的):"
    echo "----------------------------------------"
    echo "序号  节点ID                状态"
    echo "----------------------------------------"
    
    local all_nodes=($(get_all_nodes))
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "未发现任何 Nexus 节点。"
        echo "----------------------------------------"
        read -p "按任意键返回菜单"
        return
    fi

    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status
        if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
            status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}")
            if [[ "$status" == Up* ]]; then
                printf "%-6d %-20s [运行中]\n" $((i+1)) "$node_id"
            else
                printf "%-6d %-20s [%s]\n" $((i+1)) "$node_id" "$status"
            fi
        else
            printf "%-6d %-20s [不存在]\n" $((i+1)) "$node_id"
        fi
    done
    echo "----------------------------------------"
}

# 批量停止并卸载指定节点
function batch_uninstall_nodes() {
    list_and_select_operation # 显示节点列表以便选择

    if [ $(echo "${all_nodes[*]}" | wc -w) -eq 0 ]; then return; fi # 如果上面显示列表时返回了，就退出

    echo "" # 空行分隔
    echo "请输入要卸载的节点的序号，多个请用空格分隔（例如: 1 3 5）。输入 'all' 卸载所有节点，或 '0' 返回主菜单："
    
    read -rp "请输入选项: " choices

    # 处理返回主菜单的选项
    if [ "$choices" == "0" ]; then
        echo "已取消操作，返回主菜单。"
        read -p "按任意键继续"
        return
    fi

    # 处理卸载所有节点的选项
    if [ "$choices" == "all" ]; then
        echo "您选择了卸载所有节点！"
        read -rp "确定要卸载所有节点吗？(y/N): " confirm_all
        if [[ ! "$confirm_all" =~ ^[Yy]$ ]]; then
            echo "已取消操作。"
            read -p "按任意键继续"
            return
        fi
        
        echo "开始卸载所有节点..."
        for node_id in "${all_nodes[@]}"; do
            uninstall_node "$node_id"
        done
        echo "所有节点卸载完成！"
        read -p "按任意键返回菜单"
        return
    fi

    # 将输入的选项（序号）转换为对应的 Node ID
    read -ra selected_choices <<< "$choices"
    
    # 验证输入并执行卸载
    local processed_nodes=() # 用于存储实际执行了卸载操作的节点ID
    for choice_str in "${selected_choices[@]}"; do
        # 移除可能的前后空格
        choice_str=$(echo "$choice_str" | xargs)
        
        if [[ "$choice_str" =~ ^[0-9]+$ ]]; then # 检查是否是数字
            local choice_num=$((choice_str))
            if [ "$choice_num" -ge 1 ] && [ "$choice_num" -le ${#all_nodes[@]} ]; then
                local selected_node=${all_nodes[$((choice_num-1))]}
                
                # 检查是否已处理过这个节点
                if [[ " ${processed_nodes[@]} " =~ " ${selected_node} " ]]; then
                    echo "节点 '$selected_node' (序号 $choice_num) 已重复选择，跳过。"
                else
                    echo "正在卸载节点 '$selected_node' (序号 $choice_num)..."
                    uninstall_node "$selected_node"
                    processed_nodes+=("$selected_node")
                fi
            else
                echo "警告：无效的序号 '$choice_str'。请选择 1 到 ${#all_nodes[@]} 之间的数字。"
            fi
        else
            echo "警告：输入的 '$choice_str' 不是有效的序号，已忽略。"
        fi
    done

    if [ ${#processed_nodes[@]} -eq 0 ]; then
        echo "未选择任何有效节点进行卸载。"
    else
        echo "指定节点的卸载完成！"
    fi
    read -p "按任意键返回菜单"
}

# 选择要查看的节点
function select_node_to_view() {
    local all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo "当前没有节点"
        read -p "按任意键返回菜单"
        return
    fi

    echo "请选择要查看日志的节点："
    echo "0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status
        if docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
             status=$(docker ps -a --filter "name=$container_name" --format "{{.Status}}")
             if [[ "$status" == Up* ]]; then
                 echo "$((i+1)). 节点 '$node_id' [运行中]"
             else
                 echo "$((i+1)). 节点 '$node_id' [已停止:$status]"
             fi
        else
             echo "$((i+1)). 节点 '$node_id' [不存在]"
        fi
    done

    read -rp "请输入选项(0-${#all_nodes[@]}): " choice

    if [ "$choice" = "0" ]; then
        return
    fi

    if [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
        local selected_node=${all_nodes[$((choice-1))]}
        view_node_logs "$selected_node"
    else
        echo "无效的选项"
        read -p "按任意键继续"
    fi
}

# 查看节点日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    # 检查容器是否存在
    if ! docker ps -a --format '{{.Names}}' | grep -qw "$container_name"; then
        echo "容器 '$container_name' 不存在。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "正在连接到容器 '$container_name' 查看日志。"
    echo "按 Ctrl+C 退出日志查看。"
    echo "--------------------------------------------------------------------------"
    
    # 提供原始日志和清理后的日志选项
    echo "请选择日志查看模式："
    echo "1. 原始日志（包含颜色代码）"
    echo "2. 清理后的日志（移除 ANSI 颜色代码）"
    read -rp "请选择(1-2): " log_mode

    if [ "$log_mode" = "2" ]; then
        # 移除 ANSI 转义序列
        docker logs -f "$container_name" | sed -e 's/\x1b\[[0-9;]*m//g' -e 's/\x1b\[?25h//g' -e 's/\x1b\[?25l//g'
    else
        docker logs -f "$container_name"
    fi
}

# 批量启动多个节点
function batch_start_nodes() {
    echo "请输入多个 node-id，每行一个，输入空行并按回车键结束："
    echo "例如:"
    echo "node_id_1"
    echo "node_id_2"
    echo "..."
    echo "(输入完成后按回车键，然后按 Ctrl+D 结束输入)"
    
    local node_ids=()
    while IFS= read -r line; do
        # 清除行首尾空白字符
        local trimmed_line=$(echo "$line" | xargs)
        if [ -n "$trimmed_line" ]; then
            node_ids+=("$trimmed_line")
        fi
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 node-id，返回主菜单。"
        read -p "按任意键继续"
        return
    fi

    echo "将启动 ${#node_ids[@]} 个节点..."
    echo "开始构建镜像..."
    build_image
    if [ $? -ne 0 ]; then
        echo "镜像构建失败，无法启动节点。请检查上面的错误信息。"
        read -p "按任意键返回菜单"
        return
    fi

    echo "开始启动节点..."
    local started_count=0
    for node_id in "${node_ids[@]}"; do
        echo "尝试启动节点 '$node_id'..."
        if run_container "$node_id"; then
            started_count=$((started_count + 1))
            echo "节点 '$node_id' 已提交启动申请。"
        else
            echo "节点 '$node_id' 启动失败，请检查上述错误信息。"
        fi
        sleep 3 # 添加短暂延迟，避免一次性触发过多 Docker 进程和网络请求
    done

    echo "完成了对 ${#node_ids[@]} 个节点启动的尝试，成功启动了 $started_count 个节点。"
    read -p "按任意键返回菜单"
}

# 批量节点轮换启动
function batch_rotate_nodes() {
    check_pm2 # 确保 pm2 可用（尽管脚本本身不直接依赖 pm2 管理，但备用）
    
    echo "请输入需要进行轮换的节点 node-id，每行一个，输入空行并按回车键结束："
    echo "（输入完成后按回车键，然后按 Ctrl+D 结束输入）"
    
    local node_ids=()
    while IFS= read -r line; do
        local trimmed_line=$(echo "$line" | xargs)
        if [ -n "$trimmed_line" ]; then
            node_ids+=("$trimmed_line")
        fi
    done

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo "未输入任何 node-id，返回主菜单。"
        read -p "按任意键继续"
        return
    fi

    local total_nodes=${#node_ids[@]}
    echo "将对 $total_nodes 个节点进行轮换启动。"

    # 设置每批次启动的节点数量
    # 默认取总节点数的一半向上取整
    local nodes_per_round=$(( (total_nodes + 1) / 2 ))
    read -rp "请输入每轮要启动的节点数量 (默认: $nodes_per_round): " input_nodes_per_round
    if [[ "$input_nodes_per_round" =~ ^[0-9]+$ ]] && [ "$input_nodes_per_round" -ge 1 ] && [ "$input_nodes_per_round" -le "$total_nodes" ]; then
        nodes_per_round=$input_nodes_per_round
    elif [ -n "$input_nodes_per_round" ]; then
        echo "无效的节点数量。使用默认值 $nodes_per_round。"
    fi
    
    # 计算需要多少组
    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    echo "节点将分为 $num_groups 组进行轮换，每组约 $nodes_per_round 个节点。"

    # 提前获取宿主机内存信息用于生成脚本
    local host_total_mem_mb_rotate
    local host_available_mem_mb_rotate
    read host_total_mem_mb_rotate host_available_mem_mb_rotate <<< $(get_host_memory)
    if [ -z "$host_total_mem_mb_rotate" ] || [ -z "$host_available_mem_mb_rotate" ]; then
        echo "无法获取宿主机内存信息，轮换启动的内存计算可能不准确。"
        # 可以选择退出或继续，此处选择继续并可能因计算失败而报错
    fi

    # 清理旧的轮换脚本和数据
    echo "清理旧的轮换启动脚本目录..."
    local script_dir="/root/nexus_scripts"
    if [ -d "$script_dir" ]; then
        rm -rf "$script_dir"
    fi
    mkdir -p "$script_dir"

    # 确保 log 目录存在
    mkdir -p "$LOG_DIR"

    # 检查 pm2 状态并停止旧任务
    echo "尝试停止可能正在运行的旧的轮换进程..."
    pm2 delete nexus-rotate 2>/dev/null || echo "没有发现名为 nexus-rotate 的 pm2 任务，继续执行。"

    echo "开始生成节点启动脚本..."
    # 为每组创建启动脚本
    for ((group=1; group<=num_groups; group++)); do
        cat > "$script_dir/start_group${group}.sh" <<EOF
#!/bin/bash
set -e
echo "[\`date '+%Y-%m-%d %H:%M:%S'\`] ----- 开始执行第${group}组节点启动 ----- "
EOF
    done

    # 将节点分配到对应的启动脚本，并计算每个节点的内存分配
    for i in "${!node_ids[@]}"; do
        local node_id=${node_ids[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local log_file="${LOG_DIR}/nexus-${node_id}.log"
        
        # 计算节点所属的组号
        local group_num=$(( i / nodes_per_round + 1 ))
        if [ $group_num -gt $num_groups ]; then group_num=$num_groups; fi # 防止越界

        # 计算此节点应该分配的内存（参考 run_container 的逻辑）
        local allocated_mem_mb_for_script=0
        if [ -n "$host_total_mem_mb_rotate" ] && [ -n "$host_available_mem_mb_rotate" ]; then
            local allocated_mem_float=$(echo "$host_total_mem_mb_rotate * $CONTAINER_MEM_RATIO" | bc)
            allocated_mem_mb_for_script=$(printf "%.0f" "$allocated_mem_float")

            if [ "$allocated_mem_mb_for_script" -gt "$CONTAINER_MEM_MAX_MB" ]; then allocated_mem_mb_for_script="$CONTAINER_MEM_MAX_MB"; fi
            if [ "$allocated_mem_mb_for_script" -lt "$CONTAINER_MEM_MIN_MB" ]; then allocated_mem_mb_for_script="$CONTAINER_MEM_MIN_MB"; fi
            if [ "$allocated_mem_mb_for_script" -gt "$host_available_mem_mb_rotate" ]; then
                echo "警告：为轮换节点 '$node_id' (第${group_num}组) 计算的内存 ${allocated_mem_mb_for_script}MB 可能大于当前可用内存 ${host_available_mem_mb_rotate}MB。将尝试分配可用内存的 90%。"
                local available_adjusted_float=$(echo "$host_available_mem_mb_rotate * 0.9" | bc)
                allocated_mem_mb_for_script=$(printf "%.0f" "$available_adjusted_float")
                if [ "$allocated_mem_mb_for_script" -lt "$CONTAINER_MEM_MIN_MB" ]; then allocated_mem_mb_for_script="$CONTAINER_MEM_MIN_MB"; fi
                if [ "$allocated_mem_mb_for_script" -gt "$host_available_mem_mb_rotate" ]; then allocated_mem_mb_for_script="$host_available_mem_mb_rotate"; fi # 最后一次安全措施
            fi
        else
            # 如果内存信息不可用，则不设置内存限制，或设置一个固定值（例如，避免容器过大）
            # 这里我们决定不设置限制，以防影响主循环
            echo "内存信息不可用，跳过节点 '$node_id' 的内存限制设置。"
        fi
        
        # 如果calculated_mem_mb_for_script 为 0，说明有错误或者没有设置
        local mem_param=""
        if [ "$allocated_mem_mb_for_script" -gt 0 ]; then
            mem_param="-m ${allocated_mem_mb_for_script}m"
        fi

        # 生成 Docker 启动命令，追加到对应的组脚本
        echo "echo \"[\`date '+%Y-%m-%d %H:%M:%S'\`] 启动节点 '$node_id' ${mem_param:+(内存: ${allocated_mem_mb_for_script}MB)}\(...\"" >> "$script_dir/start_group${group_num}.sh"
        # 需要确保启动命令在生成脚本时被正确转义
        # 使用 sed 进行简单转义，以防止引号等特殊字符引起问题
        local quoted_container_name=$(printf "%q" "$container_name")
        local quoted_log_file=$(printf "%q" "$log_file")
        local quoted_node_id=$(printf "%q" "$node_id")
        
        # 构建 docker run 命令，确保 `-m` 参数被正确处理
        local docker_run_cmd="docker run -d --name $quoted_container_name $mem_param -v $quoted_log_file:/root/nexus.log -e NODE_ID=$quoted_node_id $IMAGE_NAME"
        
        echo "$docker_run_cmd" >> "$script_dir/start_group${group_num}.sh"
        echo "echo \"[\`date '+%Y-%m-%d %H:%M:%S'\`] 节点 '$node_id' 已提交启动指令.\"" >> "$script_dir/start_group${group_num}.sh"
        echo "sleep 30" >> "$script_dir/start_group${group_num}.sh" # 避免同时启动过快
    done

    # 生成主轮换脚本
    cat > "$script_dir/rotate.sh" <<EOF
#!/bin/bash
set -e
echo "启动 Nexus 节点轮换脚本..."

while true; do
EOF

    # 每次循环开始前，先清理掉之前的所有 Nexus 节点容器
    echo "echo \"[\`date '+%Y-%m-%d %H:%M:%S'\`] 开始本次轮换: 清理所有旧的 Nexus 节点容器...\"" >> "$script_dir/rotate.sh"
    # 这里要注意，如果在执行清理时正好有节点启动失败，清理会稍微慢一点
    echo "docker ps -a --filter \"name=${BASE_CONTAINER_NAME}\" --format \"{{.Names}}\" | xargs -r docker rm -f" >> "$script_dir/rotate.sh"
    echo "echo \"[\`date '+%Y-%m-%d %H:%M:%S'\`] 旧的 Nexus 节点容器已清理完毕.\"" >> "$script_dir/rotate.sh"
    echo "" >> "$script_dir/rotate.sh"

    # 将每组的启动脚本命令追加到主轮换脚本
    for ((group=1; group<=num_groups; group++)); do
        local current_group_nodes=$(( total_nodes / num_groups ))
        if [ $group -le $(( total_nodes % num_groups )) ]; then
            current_group_nodes=$(( current_group_nodes + 1 ))
        fi
        if [ $total_nodes -eq 0 ]; then current_group_nodes=0; fi
        
        # 计算当前组的实际节点数（防止num_groups计算不精确导致最后组少于预期）
        local start_idx=$(( (group-1) * nodes_per_round ))
        local end_idx=$(( group * nodes_per_round ))
        if [ $end_idx -gt $total_nodes ]; then end_idx=$total_nodes; fi
        local actual_group_node_count=$((end_idx - start_idx))

        echo "echo \"[\`date '+%Y-%m-%d %H:%M:%S'\`] ========================== 开始启动第 ${group}/${num_groups} 组 (${actual_group_node_count} 个节点) ==========================\"" >> "$script_dir/rotate.sh"
        # 追加启动脚本的内容，注意 shell 命令的重定向
        cat "$script_dir/start_group${group}.sh" >> "$script_dir/rotate.sh"
        
        echo "echo \"[\`date '+%Y-%m-%d %H:%M:%S'\`] ----- 第 ${group}/${num_groups} 组节点启动命令执行完毕 ----- \"" >> "$script_dir/rotate.sh"
        echo "" >> "$script_dir/rotate.sh"

        # 检查是否是最后一组
        if [ "$group" -lt "$num_groups" ]; then
            # 等待轮换间隔 (默认两小时)
            echo "echo \"[\`date '+%Y-%m-%d %H:%M:%S'\`] 完成第 ${group}/${num_groups} 组节点启动。等待 2 小时继续下一轮...\"" >> "$script_dir/rotate.sh"
            echo "sleep 7200" >> "$script_dir/rotate.sh" # 7200 seconds = 2 hours
            echo "" >> "$script_dir/rotate.sh"
        else
            echo "echo \"[\`date '+%Y-%m-%d %H:%M:%S'\`] 所有节点组的启动指令已生成并执行完毕，轮换周期完成。\"" >> "$script_dir/rotate.sh"
            # 最后一轮完成后，是否继续循环还是等待下次被触发，取决于这个脚本的行为
            # 为了简单起见，这里让它等待，但可以根据需求修改
            echo "echo \"[\`date '+%Y-%m-%d %H:%M:%S'\`] 本次轮换周期完成。等待 2 小时再次循环（如果 script 是不停地运行的）...\"" >> "$script_dir/rotate.sh"
            echo "sleep 7200" >> "$script_dir/rotate.sh"
        fi
    done

    # 标记轮换脚本执行完成
    cat >> "$script_dir/rotate.sh" <<EOF
echo "[\`date '+%Y-%m-%d %H:%M:%S'\`] 节点轮换脚本结束本次循环执行."
echo ""
EOF

    # 设置脚本权限
    chmod +x "$script_dir"/*.sh

    echo "镜像构建和节点启动脚本准备完成。"
    echo "现在使用 pm2 启动轮换进程。"
    
    # 启动轮换脚本作为 pm2 服务
    # --cron "*/2 * * * *" 是一个例子，表示每 2 分钟运行一次脚本
    # 如果我们要脚本内部自己控制等待 2 小时，就不需要 pm2 cron
    # 我们是要让 pm2 持续运行 rotate.sh，并在脚本内部控制循环和等待
    if ! pm2 start "$script_dir/rotate.sh" --name "nexus-rotate" --interpreter "/bin/bash"; then
        echo "启动 pm2 任务 'nexus-rotate' 失败。请检查 pm2 是否正确安装，或者脚本路径是否正确。"
        echo "手动执行 '$script_dir/rotate.sh' 进行测试。"
        read -p "按任意键返回菜单"
        return
    fi

    pm2 save # 保存 pm2 配置，使其在系统重启后也能恢复
    
    echo "节点轮换已配置并启动！"
    echo "当前设置: 总共 $total_nodes 个节点，每轮启动 $nodes_per_round 个，每轮间隔 2 小时。"
    echo "你可以使用以下 pm2 命令管理："
    echo "  pm2 status            - 查看所有 pm2 进程状态"
    echo "  pm2 logs nexus-rotate - 查看轮换脚本日志"
    echo "  pm2 stop nexus-rotate - 停止轮换进程"
    echo "  pm2 restart nexus-rotate - 重启轮换进程"
    echo "  pm2 delete nexus-rotate - 删除此 pm2 任务"
    read -p "按任意键返回菜单"
}

# 设置定时清理日志任务（每2天清理一次，只保留最近2天的日志）
function setup_log_cleanup_cron() {
    # crontab 的格式是: 分 时 天 月 周 命令
    # "0 3 */2 * *" 表示：每天的 3 点 0 分，每隔两天执行一次
    # find ... -mtime +2 -delete 表示：查找 'nexus-*.log' 文件，并且是两天之前创建的 (-mtime +2)，然后删除
    local cron_job="0 3 */2 * * find $LOG_DIR -type f -name 'nexus-*.log' -mtime +2 -delete"
    local crontab_exists=0
    
    # 检查是否已存在相同的定时任务
    if crontab -l 2>/dev/null | grep -qF "$cron_job"; then
        echo "检测到日志清理定时任务已存在，跳过添加。"
        crontab_exists=1
    fi

    if [ "$crontab_exists" -eq 0 ]; then
        # 将新任务添加到 crontab，并移除重复行 (如果添加过程中意外创建了重复项)
        (crontab -l 2>/dev/null; echo "$cron_job") | sort -u | crontab -
        echo "已设置每2天在凌晨3点自动清理，只保留最近2天的 Nexus 日志文件。"
        echo "您可以使用 'crontab -e' 来编辑您的 cron 任务列表。"
    fi
}

# 主菜单
function display_menu() {
    clear
    echo "**************************************************"
    echo "**            Nexus 多节点管理脚本            **"
    echo "**************************************************"
    echo "脚本作者: 哈哈哈哈 (Github/Twitter @ferdie_jhovie)"
    echo "版本: 1.2.0 (增加内存自动分配)"
    echo "**************************************************"
    echo "1. 安装并启动新节点"
    echo "2. 显示所有节点状态 (包含已停止的)"
    echo "3. 批量停止并卸载指定节点"
    echo "4. 查看指定节点日志"
    echo "5. 批量节点轮换启动"
    echo "6. 删除全部已创建的节点"
    echo "7. 退出脚本"
    echo "==================================="
}

# ---- 脚本主流程 ----
setup_log_cleanup_cron # 在启动时设置定时清理任务
while true; do
    display_menu
    read -rp "请输入选项(1-7): " choice

    case $choice in
        1) # 安装并启动新节点
            check_docker
            if ! install_utility_if_not_exists "bc"; then # 在需要时检查bc
                read -p "请在安装bc后按任意键继续..."
                continue
            fi
            read -rp "请输入您的节点ID (例如: my-nexus-node-01): " NODE_ID
            NODE_ID=$(echo "$NODE_ID" | xargs) # 清除输入字符串的首尾空格
            if [ -z "$NODE_ID" ]; then
                echo "错误：Node ID 不能为空！请重新输入。"
                read -p "按任意键继续"
                continue
            fi
            echo "准备构建镜像并启动容器..."
            build_image # 先构建镜像
            if [ $? -ne 0 ]; then # 检查 build_image 是否成功
                echo "镜像构建失败，请检查上面的错误信息。无法启动节点。"
                read -p "按任意键返回菜单"
                continue
            fi
            if ! run_container "$NODE_ID"; then # 启动容器，并检查run_container的返回值
                echo "节点 '$NODE_ID' 的容器启动失败，请检查上述错误信息。"
            else
                echo "节点 '$NODE_ID' 已成功启动容器。"
            fi
            read -p "按任意键返回菜单"
            ;;
        2) # 显示所有节点状态
            list_nodes
            ;;
        3) # 批量停止并卸载指定节点
            batch_uninstall_nodes
            ;;
        4) # 查看指定节点日志
            select_node_to_view
            ;;
        5) # 批量节点轮换启动
            check_docker
            if ! install_utility_if_not_exists "bc"; then # 在需要时检查bc
                read -p "请在安装bc后按任意键继续..."
                continue
            fi
            batch_rotate_nodes
            ;;
        6) # 删除全部节点
            uninstall_all_nodes # 该函数用于安全删除所有节点
            ;;
        7) # 退出脚本
            echo "正在退出 Nexus 管理脚本。"
            exit 0
            ;;
        *) # 无效选项
            echo "无效选项 '$choice'。请输入 1 到 7 之间的数字。"
            read -p "按任意键继续"
            ;;
    esac
done
