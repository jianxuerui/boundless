#!/bin/bash
#===============================================================================
# 脚本名称: nexus_manager.sh
# 作者: 哈哈哈哈 (Twitter: @ferdie_jhovie)
# 版本: 1.2.0
# 功能: 管理 Nexus 节点的部署、运行、监控、轮换和卸载。
# 特点: 支持批量部署，节点轮换，日志管理，依赖检查。
# 版权: 免费开源，请勿相信任何收费行为。
#===============================================================================

# 设置 -e 选项，确保任何命令失败时脚本会立即退出。
set -e
# 设置 -o pipefail 选项，使管道中的任何命令失败都会导致整个管道命令失败。
set -o pipefail
# 设置 -u 选项，对未设置的变量报错，提高脚本健壮性。
# set -u # 根据实际情况考虑是否启用此选项，有时在特定环境会有影响

# --- 全局配置 ---
BASE_CONTAINER_NAME="nexus-node"      # 所有 Nexus 节点的 Docker 容器名前缀
IMAGE_NAME="nexus-node:latest"       # 构建的 Docker 镜像名称和标签
LOG_DIR="/root/nexus_logs"           # 宿主机上 Nexus 日志的存储目录
# !!!!!重要: Nexus CLI 版本已更新到 1.1.23, 原 1.1.20 导致 404 错误 !!!!!
NEXUS_CLI_VERSION="1.1.23"           # 硬编码 Nexus CLI 的版本，用于下载

# --- 函数定义 ---

# 检查 Docker 是否已安装且运行
function check_docker() {
    echo ">>> 检测 Docker 状态..."
    if ! command -v docker &> /dev/null; then
        echo ">>> Docker 未安装，开始安装..."
        # 更新包列表并安装必要的依赖
        apt-get update -qq || { echo ">>> ERROR: apt update 失败，请检查网络连接或尝试手动执行 'apt update'"; exit 1; }
        apt-get install -y -qq apt-transport-https ca-certificates curl software-properties-common gnupg || { echo ">>> ERROR: 安装 Docker 所需的包失败"; exit 1; }

        # 添加 Docker 的官方 GPG 密钥
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg &> /dev/null || { echo ">>> ERROR: 下载 Docker GPG 密钥失败"; exit 1; }
        
        # 添加 Docker 的 APT 仓库
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list &> /dev/null || { echo ">>> ERROR: 添加 Docker APT 仓库失败"; exit 1; }
        
        # 更新包列表后安装 Docker CE
        apt-get update -qq
        apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-compose-plugin || { echo ">>> ERROR: 安装 docker-ce 失败"; exit 1; }
        
        # 启用并启动 Docker 服务
        systemctl enable docker || { echo ">>> ERROR: 启用 Docker 服务失败"; exit 1; }
        systemctl start docker || { echo ">>> ERROR: 启动 Docker 服务失败"; exit 1; }
        echo ">>> Docker 已成功安装并启动。"
    else
        # 检查 Docker 服务是否正在运行
        if ! systemctl is-active --quiet docker; then
            echo ">>> 检测到 Docker 服务未运行，正在尝试启动..."
            systemctl start docker || { echo ">>> ERROR: 启动 Docker 服务失败"; exit 1; }
            echo ">>> Docker 服务已启动。"
        else
            echo ">>> Docker 已安装并正在运行。"
        fi
    fi
}

# 检查 Node.js/npm/pm2 是否已安装
function check_pm2() {
    echo ">>> 检测 Node.js/npm/pm2 状态..."
    if ! command -v node &> /dev/null || ! command -v npm &> /dev/null; then
        echo ">>> 检测到未安装 Node.js/npm，开始安装..."
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash - &> /dev/null || { echo ">>> ERROR: 设置 Node.js 18.x 源失败"; exit 1; }
        apt-get update -qq
        apt-get install -y -qq nodejs || { echo ">>> ERROR: 安装 Node.js 失败"; exit 1; }
        echo ">>> Node.js 和 npm 已安装。"
    fi
    if ! command -v pm2 &> /dev/null; then
        echo ">>> 检测到未安装 pm2，开始安装..."
        npm install -g pm2 || { echo ">>> ERROR: 安装 pm2 全局模块失败"; exit 1; }
        echo ">>> pm2 已安装。"
    fi
}

# 构建docker镜像函数
function build_image() {
    echo ">>> 开始构建 Docker 镜像 '$IMAGE_NAME'..."
    
    # WORKDIR 在此声明为函数局部变量
    local WORKDIR
    WORKDIR=$(mktemp -d) 

    # 设置一个 EXIT trap 来清理 WORKDIR。此 trap 只在此函数作用域内有效。
    trap 'echo ">>> [Build Image] 清理临时目录 $WORKDIR"; rm -rf -- "$WORKDIR"' EXIT INT TERM
    
    cd "$WORKDIR" || { echo ">>> ERROR: 无法进入临时目录 '$WORKDIR'"; return 1; }

    # --- 创建 Dockerfile ---
    cat > Dockerfile <<EOF
# --- Dockerfile for Nexus Node ---
FROM ubuntu:24.04

LABEL maintainer="哈哈哈哈 <https://twitter.com/ferdie_jhovie>"

ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id
ENV NODE_LOG_PATH=/root/nexus.log

RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    tar \
    ca-certificates \
    screen \
    bash \
    jq \
    && rm -rf /var/lib/apt/lists/*

# === 下载和安装 Nexus CLI ===
# !!! 重要: NEXUS_CLI_VERSION 已更新为 1.1.23 以解决 404 错误 !!!
RUN NEXUS_CLI_VERSION="${NEXUS_CLI_VERSION}" && \
    ARCH=$(uname -m) && \
    echo ">>> Docker build: 检测到的架构为 $ARCH，将安装 Nexus CLI 版本 $NEXUS_CLI_VERSION。" && \
    case "$ARCH" in \
        "aarch64") \
            URL="https://github.com/nexus-xyz/nexus-network-services/releases/download/v${NEXUS_CLI_VERSION}/nexus-cli_${NEXUS_CLI_VERSION}_linux_arm64.tar.gz" ;; \
        "x86_64") \
            URL="https://github.com/nexus-xyz/nexus-network-services/releases/download/v${NEXUS_CLI_VERSION}/nexus-cli_${NEXUS_CLI_VERSION}_linux_amd64.tar.gz" ;; \
        *) \
            echo ">>> Docker build: 错误 - 不支持的 CPU 架构: $ARCH。仅支持 aarch64 和 x86_64。" >&2 && exit 1 ;; \
    esac && \
    echo ">>> Docker build: 将从 ${URL} 下载 Nexus CLI..." && \
    mkdir -p /root/.nexus/bin && \
    TMP_DIR=$(mktemp -d) && \
    # 提高 curl 和 tar 的健壮性
    curl -fsSL "${URL}" -o "${TMP_DIR}/nexus.tar.gz" || { echo ">>> Docker build: 下载 Nexus CLI 包失败。" >&2; exit 1; } && \
    # 增加解压的健壮性
    echo ">>> Docker build: 解压 ${TMP_DIR}/nexus.tar.gz..." && \
    tar -xzf "${TMP_DIR}/nexus.tar.gz" -C "${TMP_DIR}" || { echo ">>> Docker build: 解压 Nexus CLI 包失败。" >&2; exit 1; } && \
    mv "${TMP_DIR}/nexus-network" /root/.nexus/bin/ || { echo ">>> Docker build: 移动 nexus-network 到安装目录失败。" >&2; exit 1; } && \
    ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network || { echo ">>> Docker build: 创建 nexus-network 软链接失败。" >&2; exit 1; } && \
    rm -rf "${TMP_DIR}" && \
    echo ">>> Docker build: Nexus CLI v${NEXUS_CLI_VERSION} 安装成功。"
# === Nexus CLI 安装结束 ===

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
EOF

    # --- 创建 entrypoint.sh ---
    cat > entrypoint.sh <<EOF
#!/bin/bash
# --- Entrypoint script for Nexus Node Container ---
set -e
set -o pipefail

PROVER_ID_FILE="/root/.nexus/node-id"
NODE_LOG_PATH="/root/nexus.log"

if [ -z "\$NODE_ID" ]; then
    echo ">>> ERROR: NODE_ID 环境变量未设置。容器无法启动。请检查运行命令。" >&2
    exit 1
fi

echo "\$NODE_ID" > "\$PROVER_ID_FILE"
echo ">>> Container: Nexus 节点 ID 为: \$NODE_ID"
echo ">>> Container: Nexus 运行日志将输出到: \$NODE_LOG_PATH"

if ! command -v nexus-network &> /dev/null; then
    echo ">>> ERROR: 'nexus-network' 命令不可用。请检查镜像构建或安装。" >&2
    exit 1
fi

if screen -list | grep -q "nexus"; then
    echo ">>> Container: Nexus 进程已在运行的 'nexus' screen session 中管理。"
else
    echo ">>> Container: 启动 Nexus 进程 (使用 screen 管理)..."
    screen -dmS nexus bash -c ' \
        trap "echo >>> Screen \"nexus\" session received SIGTERM, cleaning up...; \
                 pkill -f \"nexus-network start --node-id \$NODE_ID\" || true; \
                 screen -S nexus -X quit; \
                 exit 0" SIGTERM SIGINT SIGQUIT SIGKILL; \
        echo >>> Screen \"nexus\" session started. Logging to ${NODE_LOG_PATH}; \
        while true; do \
            nexus-network start --node-id \$NODE_ID &>> '${NODE_LOG_PATH}'; \
            if [ \$? -eq 0 ]; then \
                echo >>> Nexus network start successful, running...; \
                sleep 60; \
            else \
                echo >>> Nexus network start failed or exited abnormally. Retrying in 30 seconds...; \
                sleep 30; \
            fi; \
        done '
    sleep 5 
fi

echo ">>> Container: Nexus 日志将持续显示（按 Ctrl+C 退出）。"
tail -f "${NODE_LOG_PATH}"
EOF

    # --- 执行 Docker 构建 ---
    # 使用 /bin/bash -c 来执行多行RUN指令
    # 注意：此处直接在 Dockerfile 中调用了多条 shell 命令，确保了构建过程的独立性和标准化。
    if docker build -t "$IMAGE_NAME" . ; then
        echo ">>> Docker 镜像 '$IMAGE_NAME' 构建成功！"
    else
        echo ">>> ERROR: Docker 镜像构建失败。请检查以上输出获取详细原因。" >&2
        return 1 # 返回一个错误码给调用方
    fi
    
    # Docker 构建成功，解除此函数的 trap。全局的 EXIT trap 还在。
    trap - EXIT INT TERM
    
    cd - &> /dev/null
}

# 启动 Nexus Docker 容器
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo ">>> 正在准备启动节点 '$node_id' (容器: '$container_name')..."

    if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        echo ">>> 检测到旧容器 '$container_name'，正在停止并删除..."
        docker rm -f "$container_name" &> /dev/null || echo ">>> 警告: 停止或删除容器 '$container_name' 时出现问题。"
        echo ">>> 旧容器 '$container_name' 已处理。"
    fi

    mkdir -p "$LOG_DIR" || { echo ">>> ERROR: 创建日志目录 '$LOG_DIR' 失败。"; return 1; }
    
    if [ ! -f "$log_file" ]; then
        touch "$log_file" || { echo ">>> ERROR: 创建日志文件 '$log_file' 失败。"; return 1; }
        chmod 644 "$log_file" || { echo ">>> ERROR: 修改日志文件 '$log_file' 权限失败。"; return 1; }
        echo ">>> 已创建日志文件: '$log_file'"
    fi

    echo ">>> 正在启动容器 '$container_name' (Node ID: $node_id)，并将日志挂载到 '$log_file'..."
    if docker run -d \
        --name "$container_name" \
        -v "$log_file":/root/nexus.log \
        -e NODE_ID="$node_id" \
        "$IMAGE_NAME" ; then
        echo ">>> 容器 '$container_name' (Node ID: $node_id) 已成功启动。"
    else
        echo ">>> ERROR: 启动容器 '$container_name' 时发生问题。请检查 Docker 日志或手动排查。" >&2
        return 1
    fi
}

# 停止并卸载指定节点的容器，并删除其日志文件
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo ">>> 正在停止并删除节点 '$node_id' (容器: '$container_name')..."
    
    if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        docker rm -f "$container_name" &> /dev/null || echo ">>> 警告: 尝试删除容器 '$container_name' 时出现问题，可能已删除。"
        echo ">>> 容器 '$container_name' 已移除。"
    else
        echo ">>> 节点 '$node_id' 对应的容器未找到，可能已被卸载。"
    fi

    if [ -f "$log_file" ]; then
        echo ">>> 正在删除节点 '$node_id' 的日志文件: '$log_file'..."
        rm -f "$log_file" || echo ">>> 警告: 删除日志文件 '$log_file' 失败。"
        echo ">>> 日志文件 '$log_file' 已移除。"
    else
        echo ">>> 节点 '$node_id' 的日志文件 '$log_file' 不存在，无需删除。"
    fi

    echo ">>> 节点 '$node_id' (容器: '$container_name') 的卸载操作完成。"
}

# 显示所有 Nexus 节点的（容器）状态信息
function list_nodes() {
    echo "------------------------------------------------------------------------------------------------------------------------"
    echo "                                           Nexus 节点状态概览"
    echo "------------------------------------------------------------------------------------------------------------------------"
    printf "%-6s %-38s %-12s %-20s %-12s %-20s\n" "序号" "节点ID (容器名)" "CPU使用率" "内存使用/限制" "容器状态" "启动时间"
    echo "------------------------------------------------------------------------------------------------------------------------"
    
    local containers_list
    containers_list=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format '{{.Names}}' | sort)

    if [ -z "$containers_list" ]; then
        echo ">>> 未找到任何 Nexus 节点（Docker 容器）。"
    else
        local i=0
        while IFS= read -r container_name; do
            local node_id="${container_name#${BASE_CONTAINER_NAME}-}"
            
            local status="未知"
            local started_at_formatted="-"
            local cpu_usage="N/A"
            local mem_usage="N/A"

            local container_inspect_output
            container_inspect_output=$(docker container inspect --format='{{.State.Status}} {{.State.StartedAt}}' "$container_name" 2>/dev/null)
            
            if [ -n "$container_inspect_output" ]; then
                status=$(echo "$container_inspect_output" | awk '{print $1}')
                if [ "$status" == "running" ]; then
                    local started_at_raw=$(echo "$container_inspect_output" | awk '{$1=""; print $0}' | xargs)
                    started_at_formatted=$(date -d "$started_at_raw" --iso-8601=seconds 2>/dev/null || echo "$started_at_raw")
                else
                    started_at_formatted="-"
                fi
            else
                status="未检测到"
            fi

            if [ "$status" == "running" ]; then
                local stats_info
                stats_info=$(docker stats --no-stream --format "{{.CPUPerc}}|{{.MemUsage}}" "$container_name" 2>/dev/null)
                if [ -n "$stats_info" ]; then
                    cpu_usage=$(echo "$stats_info" | cut -d '|' -f 1)
                    mem_usage=$(echo "$stats_info" | cut -d '|' -f 2)
                fi
            fi

            local display_name="${node_id} (${container_name})"
            if (( ${#display_name} > 38 )); then
                display_name="${display_name:0:35}..."
            fi
            
            printf "%-6d %-38s %-12s %-20s %-12s %-20s\n" \
                $((i+1)) \
                "$display_name" \
                "$cpu_usage" \
                "$mem_usage" \
                "$status" \
                "$started_at_formatted"
            ((i++))
        done <<< "$containers_list"
    fi

    echo "------------------------------------------------------------------------------------------------------------------------"
    echo "提示："
    echo "- CPU使用率以百分比显示 (例如: 0.5%)。"
    echo "- 内存使用格式为：已用 / 容量 (例如: 15.8MiB / 1.954GiB)。"
    echo "- 容器状态如：running, exited。"
    echo "- 如果容器未运行，CPU和内存使用率将显示为 N/A。"
    read -p "按任意键返回主菜单..."
}

# 获取当前所有已启动的节点的 Node ID 列表
function get_running_nodes() {
    docker ps --filter "name=${BASE_CONTAINER_NAME}" --filter "status=running" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 获取所有 Nexus 节点（包括运行中和已停止）的 Node ID 列表
function get_all_nodes() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort
}

# 查看指定节点的日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    echo ">>> 正在查找容器 '$container_name' 以便查看日志..."
    if ! docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        echo ">>> 未找到容器 '$container_name'。请先使用选项 1 启动节点。"
        read -p "按任意键返回菜单..."
        return
    fi

    echo "请选择日志查看模式:"
    echo "  1. 实时日志 (FOLLOW模式，Ctrl+C 退出)"
    echo "  2. 获取所有现有日志 (输出一次后退出)"
    echo "  3. 清理后实时日志 (去除 ANSI 颜色码，FOLLOW模式，Ctrl+C 退出)"
    echo "  0. 返回主菜单"
    
    local log_mode
    read -rp "请输入您的选择 (0-3): " log_mode

    case "$log_mode" in
        1)
            echo ">>> 打开 '$container_name' 的实时日志流... (按 Ctrl+C 退出)"
            docker logs -f "$container_name"
            ;;
        2)
            echo ">>> 获取 '$container_name' 的所有现有日志..."
            docker logs "$container_name"
            read -p ">>> 日志已显示。按任意键继续..."
            ;;
        3)
            echo ">>> 打开 '$container_name' 的清理后实时日志... (按 Ctrl+C 退出)"
            docker logs -f "$container_name" | sed -E 's/\x1b\[[0-9;]*m//g; s/\r//g'
            ;;
        0)
            echo ">>> 返回主菜单。"
            ;;
        *)
            echo ">>> 无效的日志模式选择。"
            read -p "按任意键继续..."
            ;;
    esac
}

# 批量启动多个节点 (支持手动输入多个 Node ID)
function batch_start_nodes() {
    echo ">>> 请依次输入需要启动的 Nexus 节点的 Node ID，每行一个。"
    echo ">>> 输入空行或按 Ctrl+D 结束输入。"
    
    local node_ids=()
    while IFS= read -r line; do
        line=$(echo "$line" | xargs)
        if [ -n "$line" ]; then
            node_ids+=("$line")
        else
            if [ ${#node_ids[@]} -gt 0 ]; then
                break
            fi
        fi
    done < /dev/stdin

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo ">>> 未输入任何 Node ID，将返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    echo ">>> 开始构建 Docker 镜像 '$IMAGE_NAME'，这将可能需要一些时间..."
    check_docker
    build_image 

    echo ">>> 共收集到 ${#node_ids[@]} 个节点 ID，开始尝试启动..."
    local success_count=0
    for node_id in "${node_ids[@]}"; do
        echo ">>> 正在尝试启动节点 '$node_id'..."
        if run_container "$node_id"; then
            success_count=$((success_count + 1))
            sleep 2
        else
            echo ">>> 节点 '$node_id' 启动失败。"
        fi
    done

    echo "---------------------------------------------------"
    echo ">>> 批量节点启动操作已完成。"
    echo ">>> 成功启动了 ${success_count} / ${#node_ids[@]} 个节点。"
    echo ">>> 您可以使用选项 '2' 查看所有节点状态。"
    read -p "按任意键返回主菜单..."
}

# 通用函数：选择一个节点进行操作 (例如查看日志)
# 返回值：选中的节点的 Node ID，如果取消则返回空字符串
function select_node_for_action() {
    local action_desc=$1
    local all_nodes
    all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo ">>> 当前没有已知的 Nexus 节点。"
        read -p "按任意键返回主菜单..."
        echo ""
        return
    fi

    echo ">>> 请选择一个节点以进行 '${action_desc}' 操作:"
    echo "  0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        
        if docker ps -a --format '{{.Status}}' --filter "name=${container_name}" 2>/dev/null | grep -q "running"; then
            printf "%3d. 节点 %-20s [运行中]\n" $((i+1)) "$node_id"
        else
            printf "%3d. 节点 %-20s [已停止/不存在]\n" $((i+1)) "$node_id"
        fi
    done

    local choice
    read -rp "请输入您的选择 (0-${#all_nodes[@]}): " choice

    if [[ "$choice" =~ ^[0-9]+$ ]]; then
        if [ "$choice" = "0" ]; then
            echo ">>> 已取消操作。"
            echo ""
            return
        elif [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
            local selected_node_id=${all_nodes[$((choice-1))]}
            echo "$selected_node_id"
            return
        else
            echo ">>> 无效的选项编号。请输入 '0' 到 '${#all_nodes[@]}' 之间的数字。"
        fi
    else
        echo ">>> 无效的输入。请输入数字。"
    fi
    
    echo "请按任意键返回主菜单..."
    read -p ""
    echo ""
    return
}

# 批量停止并卸载选定的节点
function batch_uninstall_nodes() {
    local all_nodes
    all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo ">>> 当前没有已知的 Nexus 节点可供卸载。"
        read -p "按任意键返回主菜单..."
        return
    fi

    echo "---------------------------------------------------"
    echo "节点列表 (选择要卸载的节点，空格分隔多个序号):"
    echo "---------------------------------------------------"
    echo "序号  节点ID               状态"
    echo "---------------------------------------------------"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status="未知"
        if docker ps -a --format '{{.Status}}' --filter "name=${container_name}" 2>/dev/null | grep -q "running"; then
            status="运行中"
        elif docker ps -a --format '{{.Status}}' --filter "name=${container_name}" 2>/dev/null | grep -q "exited"; then
            status="已停止"
        else
            status="不存在"
        fi
        printf "%-6d %-20s [%s]\n" $((i+1)) "$node_id" "$status"
    done
    echo "---------------------------------------------------"
    echo "请输入要卸载的节点序号 (例如: 1 3 5)，输入 '0' 返回主菜单。"
    
    local choices_input
    read -rp "请输入您的选择 (0 或 序号，空格分隔): " choices_input

    if [ "$choices_input" == "0" ]; then
        echo ">>> 已取消卸载操作。"
        read -p "按任意键返回主菜单..."
        return
    fi

    local selected_indices=()
    IFS=' ' read -r -a selected_indices <<< "$choices_input"
    
    local nodes_to_uninstall=()
    for choice_str in "${selected_indices[@]}"; do
        if [[ "$choice_str" =~ ^[0-9]+$ ]] && [ "$choice_str" -ge 1 ] && [ "$choice_str" -le ${#all_nodes[@]} ]; then
            local node_index=$((choice_str - 1))
            nodes_to_uninstall+=("${all_nodes[node_index]}")
        else
            echo ">>> 警告: 输入了无效的序号 '$choice_str'，将忽略此选项。"
        fi
    done

    if [ ${#nodes_to_uninstall[@]} -eq 0 ]; then
        echo ">>> 没有选择任何节点进行卸载。"
        read -p "按任意键返回主菜单..."
        return
    fi

    echo ">>> 您已选择卸载以下节点:"
    for node_id in "${nodes_to_uninstall[@]}"; do
        echo "  - $node_id"
    done
    read -rp ">>> 确定要继续卸载这些节点吗? (输入 'YES' 确认): " confirm_uninstall
    if [ "$confirm_uninstall" != "YES" ]; then
        echo ">>> 已取消卸载操作。"
        read -p "按任意键返回主菜单..."
        return
    fi

    echo ">>> 开始批量卸载节点..."
    local uninstalled_count=0
    for node_id in "${nodes_to_uninstall[@]}"; do
        if docker ps -a --format '{{.Names}}' | grep -qxF "${BASE_CONTAINER_NAME}-${node_id}"; then
            uninstall_node "$node_id"
            uninstalled_count=$((uninstalled_count + 1))
        else
            echo ">>> 节点 '$node_id' 在卸载前已不存在，跳过。"
        fi
    done

    echo ">>> 批量节点卸载操作完成。共卸载了 ${uninstalled_count} 个节点。"
    read -p "按任意键返回主菜单..."
}

# 批量节点轮换启动：配置并运行一个定时脚本，每隔一段时间自动替换一组节点运行。
function batch_rotate_nodes() {
    check_pm2

    echo ">>> 请依次输入参与节点轮换的 Node ID，每行一个。"
    echo ">>> 输入空行或按 Ctrl+D 结束输入。"
    
    local node_ids=()
    while IFS= read -r line; do
        line=$(echo "$line" | xargs)
        if [ -n "$line" ]; then
            node_ids+=("$line")
        else
            if [ ${#node_ids[@]} -gt 0 ]; then
                break
            fi
        fi
    done < /dev/stdin

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo ">>> 未输入任何 Node ID，返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    local total_nodes=${#node_ids[@]}
    local default_nodes_per_round=$(( (total_nodes + 1) / 2 ))
    [ "$default_nodes_per_round" -lt 1 ] && default_nodes_per_round=1
    [ "$default_nodes_per_round" -gt "$total_nodes" ] && default_nodes_per_round=$total_nodes

    local nodes_per_round
    read -rp ">>> 请输入每轮次要启动的节点数量 (每隔 2 小时轮换，默认: ${default_nodes_per_round}): " nodes_per_round
    nodes_per_round=${nodes_per_round:-$default_nodes_per_round}

    if ! [[ "$nodes_per_round" =~ ^[0-9]+$ ]] || [ "$nodes_per_round" -lt 1 ] || [ "$nodes_per_round" -gt "$total_nodes" ]; then
        echo ">>> ERROR: 输入的节点数量无效。请确保输入值为 1 到 ${total_nodes} 之间的整数。"
        read -p "按任意键返回菜单..."
        return
    fi

    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    echo ">>> 您配置的总节点数为 ${total_nodes}，将分为 ${num_groups} 轮次，每轮启动 ${nodes_per_round} 个节点。"

    echo ">>> 停止并删除旧的 'nexus-rotate' PM2 进程（如果存在）..."
    pm2 stop nexus-rotate &> /dev/null || true
    pm2 delete nexus-rotate &> /dev/null || true
    pm2 save

    echo ">>> 开始构建（或更新）Nexus Docker 镜像 '$IMAGE_NAME'..."
    build_image

    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir" || { echo ">>> ERROR: 创建脚本目录 '$script_dir' 失败。"; return 1; }
    local rotate_script="$script_dir/rotate_nodes.sh"

    echo "#!/bin/bash" > "$rotate_script"
    echo "set -e" >> "$rotate_script"
    echo "set -o pipefail" >> "$rotate_script"
    echo "IMAGE_NAME=\"${IMAGE_NAME}\"" >> "$rotate_script"
    echo "BASE_CONTAINER_NAME=\"${BASE_CONTAINER_NAME}\"" >> "$rotate_script"
    echo "LOG_DIR=\"${LOG_DIR}\"" >> "$rotate_script"
    echo "ALL_NODE_IDS=(\"${node_ids[@]}\")" >> "$rotate_script"
    echo "NODES_PER_ROUND=${nodes_per_round}" >> "$rotate_script"
    echo "TOTAL_NODES=${total_nodes}" >> "$rotate_script"
    echo "NUM_GROUPS=${num_groups}" >> "$rotate_script"

    echo 'declare -A rounds_nodes' >> "$rotate_script"
    for ((g=0; g<num_groups; g++)); do
        local start_index=$(( g * nodes_per_round ))
        local current_round_nodes=()
        for ((i=start_index; i<start_index + nodes_per_round && i < TOTAL_NODES; i++)); do
            current_round_nodes+=("${ALL_NODE_IDS[i]}")
        done
        local nodes_string
        printf -v nodes_string '"%s" ' "${current_round_nodes[@]}"
        echo "rounds_nodes[$g]=(${nodes_string})" >> "$rotate_script"
    done

    echo 'echo "[$(date "+%Y-%m-%d %H:%M:%S")] Nexus 节点轮换脚本启动..."' >> "$rotate_script"
    echo 'while true; do' >> "$rotate_script"
    echo '  for ((round=0; round<NUM_GROUPS; round++)); do' >> "$rotate_script"
    echo '    echo ""' >> "$rotate_script"
    echo '    echo "[$(date "+%Y-%m-%d %H:%M:%S")] === 开始第 $((round+1))/${NUM_GROUPS} 轮次节点轮换 ===" ' >> "$rotate_script"
    
    echo '    echo "[$(date "+%Y-%m-%d %H:%M:%S")] 停止并删除所有正在运行或已停止的 Nexus 节点容器..." ' >> "$rotate_script"
    echo '    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f' >> "$rotate_script"
    
    echo '    current_round_node_ids=("${rounds_nodes[round]}")' >> "$rotate_script"
    echo '    echo "[$(date "+%Y-%m-%d %H:%M:%S")] 本轮次将启动的节点 (${#current_round_node_ids[@]}个): ${current_round_node_ids[*]}" ' >> "$rotate_script"

    echo '    if [ ${#current_round_node_ids[@]} -eq 0 ]; then ' >> "$rotate_script"
    echo '        echo "[$(date "+%Y-%m-%d %H:%M:%S")] 警告: 当前轮次没有节点需要启动。" ' >> "$rotate_script"
    echo '        sleep 10 ' >> "$rotate_script"
    echo '        continue ' >> "$rotate_script"
    echo '    fi' >> "$rotate_script"
    
    echo '    for node_id in "${current_round_node_ids[@]}"; do' >> "$rotate_script"
    echo '        CONTAINER_NAME="'"${BASE_CONTAINER_NAME}"'-\${node_id}"' >> "$rotate_script"
    echo '        LOG_FILE="${LOG_DIR}/nexus-\${node_id}.log"' >> "$rotate_script"
    echo '        echo "[$(date "+%Y-%m-%d %H:%M:%S")]   - 尝试启动节点 \${node_id} (容器: \${CONTAINER_NAME})..." ' >> "$rotate_script"
    echo '        mkdir -p "$LOG_DIR" && touch "$LOG_FILE"' >> "$rotate_script"
    echo '        if docker run -d \
            --name "\${CONTAINER_NAME}" \
            -v "$LOG_FILE":/root/nexus.log \
            -e NODE_ID="\${node_id}" \
            "$IMAGE_NAME"; then ' >> "$rotate_script"
    echo '            echo "[$(date "+%Y-%m-%d %H:%M:%S")]     成功启动节点 \${node_id}。" ' >> "$rotate_script"
    echo '            sleep 30 ' >> "$rotate_script"
    echo '        else ' >> "$rotate_script"
    echo '            echo "[$(date "+%Y-%m-%d %H:%M:%S")]     启动节点 \${node_id} 失败！" ' >> "$rotate_script"
    echo '        fi ' >> "$rotate_script"
    echo '    done' >> "$rotate_script"
    
    echo '    echo "[$(date "+%Y-%m-%d %H:%M:%S")] 第 $((round+1))/${NUM_GROUPS} 轮次节点启动完毕。" ' >> "$rotate_script"
    
    echo '    if [ $((round + 1)) -lt ${NUM_GROUPS} ]; then ' >> "$rotate_script"
    echo '        echo "[$(date "+%Y-%m-%d %H:%M:%S")] 等待 2 小时 (7200 秒) 进行下一轮次切换..."' >> "$rotate_script"
    echo '        sleep 7200' >> "$rotate_script"
    echo '    else' >> "$rotate_script"
    echo '        echo "[$(date "+%Y-%m-%d %H:%M:%S")] 所有配置的轮次已执行完毕，将在 2 小时后重新开始新一轮的节点轮换。" ' >> "$rotate_script"
    echo '        echo "[$(date "+%Y-%m-%d %H:%M:%S")] 如果需要停止轮换，请执行: pm2 stop nexus-rotate。" ' >> "$rotate_script"
    echo '        sleep 7200' >> "$rotate_script"
    echo '    fi' >> "$rotate_script"
    echo '  done' >> "$rotate_script"
    echo 'done' >> "$rotate_script"

    echo 'echo "[$(date "+%Y-%m-%d %H:%M:%S")] Nexus 节点轮换脚本执行完毕（或循环已继续）。"' >> "$rotate_script"

    chmod +x "$rotate_script" || { echo ">>> ERROR: 为轮换脚本 '$rotate_script' 添加执行权限失败。"; return 1; }
    echo ">>> 已成功生成节点轮换启动脚本: '$rotate_script'"

    echo ">>> 使用 PM2 启动轮换脚本 'nexus-rotate'..."
    if pm2 start "$rotate_script" --name "nexus-rotate" --watch --restart-delay 5000 --max-memory-restart 1G; then
        echo ">>> 节点轮换管理进程 'nexus-rotate' 已成功启动！"
        echo ">>> 你可以使用以下命令监控和管理:"
        echo "    pm2 list"
        echo "    pm2 logs nexus-rotate"
        echo "    pm2 show nexus-rotate"
        echo "    pm2 stop nexus-rotate"
        echo "    pm2 restart nexus-rotate"
        echo "    pm2 delete nexus-rotate"
    else
        echo ">>> ERROR: 使用 PM2 启动轮换脚本失败。请检查 PM2 安装及脚本执行权限。" >&2
        return 1
    fi
    pm2 save

    echo ">>> 节点轮换配置完成。"
    read -p "按任意键返回主菜单..."
}

# 设置 cronjob 来清理旧的 Nexus 日志文件 (保留最近2天的)
function setup_log_cleanup_cron() {
    local log_cleanup_cron_job="0 3 */2 * * find \"${LOG_DIR}\" -type f -name 'nexus-*.log' -mtime +2 -delete"
    
    if eval "crontab -l 2>/dev/null" | grep -Fq "$log_cleanup_cron_job"; then
        echo ">>> 日志清理定时任务已存在，无需重复设置。"
    else
        (eval "crontab -l 2>/dev/null"; echo "$log_cleanup_cron_job") | eval "crontab -"
        echo ">>> 已设置日志清理定时任务 (每两天删除超过2天的 Nexus 日志)。"
    fi
}

# 显示主菜单并获取用户选择
function display_menu() {
    clear
    echo "============================================"
    echo "      Nexus 多节点管理脚本 (v1.2.0)"
    echo "============================================"
    echo " 作者: 哈哈哈哈 (Twitter: @ferdie_jhovie)"
    echo ""
    echo " 提示: 本脚本完全免费开源，请勿相信任何收费行为。"
    echo "--------------------------------------------"
    echo "  操作选项:"
    echo "    1. 启动新节点 (输入单个或多个 Node ID)"
    echo "    2. 显示所有节点状态 (列表)"
    echo "    3. 批量卸载节点 (选择要移除的节点)"
    echo "    4. 查看节点日志 (选择要查看日志的节点)"
    echo "    5. 节点轮换启动 (自动交替运行多批节点)"
    echo "    6. 删除所有节点 (!!! 慎用 !!! 且不可逆)"
    echo "    0. 退出脚本"
    echo "============================================"
}

# --- 脚本主入口 ---

# 初始化设置：设置日志清理的定时任务
setup_log_cleanup_cron

# 全局的 trap 用于在任何情况下清理工作目录（主要是为了 build_image）
trap 'echo ">>> [Main Script] Global EXIT trap, cleaning WORKDIR..."; rm -rf -- "$WORKDIR" || true' EXIT INT TERM

# 主循环：持续显示菜单并处理用户选择
while true; do
    display_menu
    
    # 在主流程中读取变量，不使用 local 关键字
    read -rp "请输入您的选择(0-6): " choice

    case "$choice" in
        1) # 启动节点
            check_docker
            batch_start_nodes
            ;;
        2) # 显示节点状态
            list_nodes
            ;;
        3) # 批量卸载节点
            batch_uninstall_nodes
            ;;
        4) # 查看节点日志
            # selected_node_id 的 local 声明是在函数 select_node_for_action 内部
            local selected_node_id # 这个是在 select_node_for_action 返回值赋给的变量，确保它在主循环里是本地变量
            selected_node_id=$(select_node_for_action "查看日志")
            if [ -n "$selected_node_id" ]; then
                view_node_logs "$selected_node_id"
            fi
            ;;
        5) # 节点轮换启动
            batch_rotate_nodes
            ;;
        6) # 删除所有节点
            echo ">>> 您即将执行'删除所有节点'的操作！"
            echo ">>> 所有已部署的 Nexus 节点容器及其日志文件都将被永久清除。"
            echo ">>> 这是一个不可逆的操作，请务必确认。"
            
            # 这里使用普通的变量，而不是 local，因为主循环不是函数
            read -rp ">>> 如果您确实要继续，请输入大写字母 'YES' 来确认: " confirm_all_delete
            
            if [ "$confirm_all_delete" == "YES" ]; then
                local all_nodes_to_delete # 在这里重新声明为 local，这样它只在此 case 语句的作用域内
                all_nodes_to_delete=($(get_all_nodes))

                if [ ${#all_nodes_to_delete[@]} -eq 0 ]; then
                    echo ">>> 当前没有已知的 Nexus 节点可供删除。"
                else
                    echo ">>> 正在开始删除所有 ${#all_nodes_to_delete[@]} 个 Nexus 节点..."
                    for node_id in "${all_nodes_to_delete[@]}"; do
                        echo ">>> 卸载节点: $node_id ..."
                        uninstall_node "$node_id"
                    done
                    echo ">>> 所有 Nexus 节点已全部卸载。"
                fi
            else
                echo ">>> 已取消删除所有节点的操作。"
            fi
            read -p "按任意键返回主菜单..."
            ;;
        0) # 退出脚本
            echo ">>> 正在退出 Nexus 管理脚本。再见！"
            exit 0
            ;;
        *) # 处理无效输入
            echo ">>> 无效的选择 '$choice'。请输入 '0' 到 '6' 之间的数字。"
            read -p "按任意键继续..."
            ;;
    esac
done

# 脚本结束（正常退出后此处不会被执行）
# trap - EXIT INT TERM # 如果有 EXIT trap 需要清理
