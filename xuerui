#!/bin/bash
#===============================================================================
# 脚本名称: nexus_manager.sh
# 作者: 哈哈哈哈 (Twitter: @ferdie_jhovie)
# 版本: 1.2.4  # 版本更新
# 功能: 管理 Nexus 节点的部署、运行、监控、轮换和卸载。
# 版权: 免费开源，请勿相信任何收费行为。
#===============================================================================

# 设置选项
set -e
set -o pipefail
# set -u # 根据需要启用

# --- 全局配置 ---
BASE_CONTAINER_NAME="nexus-node"
IMAGE_NAME="nexus-node:latest"
LOG_DIR="/root/nexus_logs"
NEXUS_CLI_VERSION="1.1.23" # Nexus CLI 版本 (如果这仍然不行，请手动指定一个确定的有效版本)

# --- 函数定义 ---

# 检查 Docker 是否已安装且运行
function check_docker() {
    echo ">>> 检测 Docker 状态..."
    if ! command -v docker &> /dev/null; then
        echo ">>> Docker 未安装，开始安装..."
        apt-get update -qq || { echo ">>> ERROR: apt update 失败"; exit 1; }
        apt-get install -y -qq apt-transport-https ca-certificates curl software-properties-common gnupg || { echo ">>> ERROR: 安装 Docker 所需的包失败"; exit 1; }
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg &> /dev/null || { echo ">>> ERROR: 下载 Docker GPG 密钥失败"; exit 1; }
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list &> /dev/null || { echo ">>> ERROR: 添加 Docker APT 仓库失败"; exit 1; }
        apt-get update -qq
        apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-compose-plugin || { echo ">>> ERROR: 安装 docker-ce 失败"; exit 1; }
        systemctl enable docker || { echo ">>> ERROR: 启用 Docker 服务失败"; exit 1; }
        systemctl start docker || { echo ">>> ERROR: 启动 Docker 服务失败"; exit 1; }
        echo ">>> Docker 已成功安装并启动。"
    else
        if ! systemctl is-active --quiet docker; then
            echo ">>> 检测到 Docker 服务未运行，正在尝试启动..."
            systemctl start docker || { echo ">>> ERROR: 启动 Docker 服务失败"; exit 1; }
            echo ">>> Docker 服务已启动。"
        else
            echo ">>> Docker 已安装并正在运行。"
        fi
    fi
}

# 检查 Node.js/npm/pm2 是否已安装
function check_pm2() {
    echo ">>> 检测 Node.js/npm/pm2 状态..."
    if ! command -v node &> /dev/null || ! command -v npm &> /dev/null; then
        echo ">>> 检测到未安装 Node.js/npm，开始安装..."
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash - &> /dev/null || { echo ">>> ERROR: 设置 Node.js 18.x 源失败"; exit 1; }
        apt-get update -qq
        apt-get install -y -qq nodejs || { echo ">>> ERROR: 安装 Node.js 失败"; exit 1; }
        echo ">>> Node.js 和 npm 已安装。"
    fi
    if ! command -v pm2 &> /dev/null; then
        echo ">>> 检测到未安装 pm2，开始安装..."
        npm install -g pm2 || { echo ">>> ERROR: 安装 pm2 全局模块失败"; exit 1; }
        echo ">>> pm2 已安装。"
    fi
}

# 构建docker镜像函数
function build_image() {
    echo ">>> 开始构建 Docker 镜像 '$IMAGE_NAME'..."
    
    local WORKDIR
    WORKDIR=$(mktemp -d) 
    trap 'echo ">>> [Build Image] 清理临时目录 $WORKDIR"; rm -rf -- "$WORKDIR"' EXIT INT TERM
    
    cd "$WORKDIR" || { echo ">>> ERROR: 无法进入临时目录 '$WORKDIR'"; return 1; }

    # --- 宿主机上动态决定 ARCH, CLI_ARCH, NEXUS_CLI_URL, 并打印以便调试 ---
    local ARCH=$(uname -m)
    local NEXUS_CLI_ARCH=""
    local NEXUS_CLI_URL=""

    case "$ARCH" in
        "aarch64")
            NEXUS_CLI_ARCH="arm64"
            ;;
        "x86_64")
            NEXUS_CLI_ARCH="amd64"
            ;;
        *)
            echo ">>> ERROR: 不支持的 CPU 架构: $ARCH。仅支持 aarch64 和 x86_64。" >&2
            return 1
            ;;
    esac
    
    # Construct the FINAL URL here based on validated ARCH and global version
    NEXUS_CLI_URL="https://github.com/nexus-xyz/nexus-network-services/releases/download/v${NEXUS_CLI_VERSION}/nexus-cli_${NEXUS_CLI_VERSION}_linux_${NEXUS_CLI_ARCH}.tar.gz"
    
    echo ">>> Host build: 检测到宿主机架构: '$ARCH'。"
    echo ">>> Host build: Nexus CLI 版本被设置为: '$NEXUS_CLI_VERSION'。"
    echo ">>> Host build: 为 CLI 生成的目标架构后缀为: '$NEXUS_CLI_ARCH'。"
    echo ">>> Host build: 生成的 Nexus CLI 下载 URL 是: '$NEXUS_CLI_URL'"

    # 可选：在这里先进行一次 URL 可用性检查，如果宿主机可以访问
    # (此步骤如果因为网络问题失败，还是需要返回错误)
    if ! curl --output /dev/null --silent --head --fail "$NEXUS_CLI_URL"; then
        echo ">>> ERROR: 从 '$NEXUS_CLI_URL' 检查下载链接时出错 (404 或其他错误)。请确认 Nexus CLI 版本 '$NEXUS_CLI_VERSION' 对应的二进制文件是否存在且URL正确。"
        echo ">>> 您可能需要检查 GitHub Release 页面或更新 '$NEXUS_CLI_VERSION' 到一个已知可用的版本。"
        return 1 # 指出 URL 确实是有问题的
    fi
    echo ">>> Host build: 检查发现下载链接 '$NEXUS_CLI_URL' 是可访问的。"

    # --- 安全生成 Dockerfile 内容 ---
    cat <<EOF > Dockerfile
# --- Dockerfile for Nexus Node ---
FROM ubuntu:24.04

LABEL maintainer="哈哈哈哈 (Twitter: @ferdie_jhovie)"

ENV DEBIAN_FRONTEND=noninteractive
ENV PROVER_ID_FILE=/root/.nexus/node-id
ENV NODE_LOG_PATH=/root/nexus.log

RUN apt-get update && apt-get install -y --no-install-recommends \\
    curl \\
    tar \\
    ca-certificates \\
    screen \\
    bash \\
    jq \\
    && rm -rf /var/lib/apt/lists/*

# === 下载和安装 Nexus CLI ===
RUN NEXUS_CLI_VERSION="${NEXUS_CLI_VERSION}" && \\
    # 将宿主机上确定的 Arch, CLI_ARCH, NEXUS_URL 直接嵌入到 Dockerfile 的 RUN 指令中
    ARCH="${ARCH}" && \
    CLI_ARCH="${NEXUS_CLI_ARCH}" && \
    NEXUS_URL="${NEXUS_CLI_URL}" && \
    echo ">>> Docker build: 检测到的架构为 \${ARCH}，将安装 Nexus CLI 版本 \${NEXUS_CLI_VERSION} (CLI 对应arch \${CLI_ARCH})。" && \
    echo ">>> Docker build: 将从 \${NEXUS_URL} 下载 Nexus CLI..." && \
    mkdir -p /root/.nexus/bin && \
    TMP_DIR=\$(mktemp -d) && \
    echo ">>> Docker build: 创建临时下载目录: \${TMP_DIR}" && \
    curl -fsSL "\${NEXUS_URL}" -o "\${TMP_DIR}/nexus.tar.gz" || { echo ">>> Docker build: 下载 Nexus CLI 包失败。" >&2; exit 1; } && \
    echo ">>> Docker build: 解压 \${TMP_DIR}/nexus.tar.gz..." && \
    tar -xzf "\${TMP_DIR}/nexus.tar.gz" -C "\${TMP_DIR}" || { echo ">>> Docker build: 解压 Nexus CLI 包失败。" >&2; exit 1; } && \
    mv "\${TMP_DIR}/nexus-network" /root/.nexus/bin/ || { echo ">>> Docker build: 移动 nexus-network 到安装目录失败。" >&2; exit 1; } && \
    ln -sf /root/.nexus/bin/nexus-network /usr/local/bin/nexus-network || { echo ">>> Docker build: 创建 nexus-network 软链接失败。" >&2; exit 1; } && \
    rm -rf "\${TMP_DIR}" && \
    echo ">>> Docker build: Nexus CLI v\${NEXUS_CLI_VERSION} 安装成功。"
# === Nexus CLI 安装结束 ===

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
EOF

    # --- 创建 entrypoint.sh ---
    cat <<'EOF' > entrypoint.sh
#!/bin/bash
# --- Entrypoint script for Nexus Node Container ---
set -e
set -o pipefail

PROVER_ID_FILE="/root/.nexus/node-id"
NODE_LOG_PATH="/root/nexus.log"

if [ -z "$NODE_ID" ]; then
    echo ">>> ERROR: NODE_ID 环境变量未设置。容器无法启动。请检查运行命令。" >&2
    exit 1
fi

echo "$NODE_ID" > "$PROVER_ID_FILE"
echo ">>> Container: Nexus 节点 ID 为: $NODE_ID"
echo ">>> Container: Nexus 运行日志将输出到: $NODE_LOG_PATH"

if ! command -v nexus-network &> /dev/null; then
    echo ">>> ERROR: 'nexus-network' 命令不可用。请检查镜像构建或安装。" >&2
    exit 1
fi

if screen -list | grep -q "nexus"; then
    echo ">>> Container: Nexus 进程已在运行的 'nexus' screen session 中管理。"
else
    echo ">>> Container: 启动 Nexus 进程 (使用 screen 管理)..."
    screen -dmS nexus bash -c ' 
        trap "echo >>> Screen \"nexus\" session received SIGTERM, cleaning up...; 
                 pkill -f \"nexus-network start --node-id \$NODE_ID\" || true; 
                 screen -S nexus -X quit; 
                 exit 0" SIGTERM SIGINT SIGQUIT SIGKILL; 
        echo >>> Screen \"nexus\" session started. Logging to ${NODE_LOG_PATH}; 
        while true; do 
            nexus-network start --node-id $NODE_ID &>> '${NODE_LOG_PATH}'; 
            if [ $? -eq 0 ]; then 
                echo >>> Nexus network start successful, running...; 
                sleep 60; 
            else 
                echo >>> Nexus network start failed or exited abnormally. Retrying in 30 seconds...; 
                sleep 30; 
            fi; 
        done '
    sleep 5 
fi

echo ">>> Container: Nexus 日志将持续显示（按 Ctrl+C 退出）。"
tail -f "${NODE_LOG_PATH}"
EOF

    # --- 执行 Docker 构建 ---
    if docker build -t "$IMAGE_NAME" . ; then
        echo ">>> Docker 镜像 '$IMAGE_NAME' 构建成功！"
    else
        echo ">>> ERROR: Docker 镜像构建失败。请检查以上输出获取详细原因。" >&2
        return 1 
    fi
    
    trap - EXIT INT TERM
    cd - &> /dev/null
}

# 启动 Nexus Docker 容器 (其他函数保持不变，除非涉及到上面build_image的修改)

# 启动 Nexus Docker 容器
function run_container() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo ">>> 正在准备启动节点 '$node_id' (容器: '$container_name')..."

    if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        echo ">>> 检测到旧容器 '$container_name'，正在停止并删除..."
        docker rm -f "$container_name" &> /dev/null || echo ">>> 警告: 停止或删除容器 '$container_name' 时出现问题。"
        echo ">>> 旧容器 '$container_name' 已处理。"
    fi

    mkdir -p "$LOG_DIR" || { echo ">>> ERROR: 创建日志目录 '$LOG_DIR' 失败。"; return 1; }
    
    if [ ! -f "$log_file" ]; then
        touch "$log_file" || { echo ">>> ERROR: 创建日志文件 '$log_file' 失败。"; return 1; }
        chmod 644 "$log_file" || { echo ">>> ERROR: 修改日志文件 '$log_file' 权限失败。"; return 1; }
        echo ">>> 已创建日志文件: '$log_file'"
    fi

    echo ">>> 正在启动容器 '$container_name' (Node ID: $node_id)，并将日志挂载到 '$log_file'..."
    if docker run -d \
        --name "$container_name" \
        -v "$log_file":/root/nexus.log \
        -e NODE_ID="$node_id" \
        "$IMAGE_NAME" ; then
        echo ">>> 容器 '$container_name' (Node ID: $node_id) 已成功启动。"
    else
        echo ">>> ERROR: 启动容器 '$container_name' 时发生问题。请检查 Docker 日志或手动排查。" >&2
        return 1
    fi
}

# 停止并卸载指定节点的容器，并删除其日志文件
function uninstall_node() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    local log_file="${LOG_DIR}/nexus-${node_id}.log"

    echo ">>> 正在停止并删除节点 '$node_id' (容器: '$container_name')..."
    
    if docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        docker rm -f "$container_name" &> /dev/null || echo ">>> 警告: 尝试删除容器 '$container_name' 时出现问题，可能已删除。"
        echo ">>> 容器 '$container_name' 已移除。"
    else
        echo ">>> 节点 '$node_id' 对应的容器未找到，可能已被卸载。"
    fi

    if [ -f "$log_file" ]; then
        echo ">>> 正在删除节点 '$node_id' 的日志文件: '$log_file'..."
        rm -f "$log_file" || echo ">>> 警告: 删除日志文件 '$log_file' 失败。"
        echo ">>> 日志文件 '$log_file' 已移除。"
    else
        echo ">>> 节点 '$node_id' 的日志文件 '$log_file' 不存在，无需删除。"
    fi

    echo ">>> 节点 '$node_id' (容器: '$container_name') 的卸载操作完成。"
}

# 显示所有 Nexus 节点的（容器）状态信息
function list_nodes() {
    echo "------------------------------------------------------------------------------------------------------------------------"
    echo "                                           Nexus 节点状态概览"
    echo "------------------------------------------------------------------------------------------------------------------------"
    printf "%-6s %-38s %-12s %-20s %-12s %-20s\n" "序号" "节点ID (容器名)" "CPU使用率" "内存使用/限制" "容器状态" "启动时间"
    echo "------------------------------------------------------------------------------------------------------------------------"
    
    local containers_list
    containers_list=$(docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format '{{.Names}}' | sort)

    if [ -z "$containers_list" ]; then
        echo ">>> 未找到任何 Nexus 节点（Docker 容器）。"
    else
        local i=0
        while IFS= read -r container_name; do
            local node_id="${container_name#${BASE_CONTAINER_NAME}-}"
            
            local status="未知"
            local started_at_formatted="-"
            local cpu_usage="N/A"
            local mem_usage="N/A"

            local container_inspect_output
            container_inspect_output=$(docker container inspect --format='{{.State.Status}} {{.State.StartedAt}}' "$container_name" 2>/dev/null)
            
            if [ -n "$container_inspect_output" ]; then
                status=$(echo "$container_inspect_output" | awk '{print $1}')
                if [ "$status" == "running" ]; then
                    local started_at_raw=$(echo "$container_inspect_output" | awk '{$1=""; print $0}' | xargs)
                    started_at_formatted=$(date -d "$started_at_raw" --iso-8601=seconds 2>/dev/null || echo "$started_at_raw")
                else
                    started_at_formatted="-"
                fi
            else
                status="未检测到"
            fi

            if [ "$status" == "running" ]; then
                local stats_info
                stats_info=$(docker stats --no-stream --format "{{.CPUPerc}}|{{.MemUsage}}" "$container_name" 2>/dev/null)
                if [ -n "$stats_info" ]; then
                    cpu_usage=$(echo "$stats_info" | cut -d '|' -f 1)
                    mem_usage=$(echo "$stats_info" | cut -d '|' -f 2)
                fi
            fi

            local display_name="${node_id} (${container_name})"
            if (( ${#display_name} > 38 )); then
                display_name="${display_name:0:35}..."
            fi
            
            printf "%-6d %-38s %-12s %-20s %-12s %-20s\n" \
                $((i+1)) \
                "$display_name" \
                "$cpu_usage" \
                "$mem_usage" \
                "$status" \
                "$started_at_formatted"
            ((i++))
        done <<< "$containers_list"
    fi

    echo "------------------------------------------------------------------------------------------------------------------------"
    echo "提示："
    echo "- CPU使用率以百分比显示 (例如: 0.5%)。"
    echo "- 内存使用格式为：已用 / 容量 (例如: 15.8MiB / 1.954GiB)。"
    echo "- 容器状态如：running, exited。"
    echo "- 如果容器未运行，CPU和内存使用率将显示为 N/A。"
    read -p "按任意键返回主菜单..."
}

# 获取当前所有已启动的节点的 Node ID 列表
function get_running_nodes() {
    docker ps --filter "name=${BASE_CONTAINER_NAME}" --filter "status=running" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//"
}

# 获取所有 Nexus 节点（包括运行中和已停止）的 Node ID 列表
function get_all_nodes() {
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | sed "s/${BASE_CONTAINER_NAME}-//" | sort
}

# 查看指定节点的日志
function view_node_logs() {
    local node_id=$1
    local container_name="${BASE_CONTAINER_NAME}-${node_id}"
    
    echo ">>> 正在查找容器 '$container_name' 以便查看日志..."
    if ! docker ps -a --format '{{.Names}}' | grep -qxF "$container_name"; then
        echo ">>> 未找到容器 '$container_name'。请先使用选项 1 启动节点。"
        read -p "按任意键返回菜单..."
        return
    fi

    echo "请选择日志查看模式:"
    echo "  1. 实时日志 (FOLLOW模式，Ctrl+C 退出)"
    echo "  2. 获取所有现有日志 (输出一次后退出)"
    echo "  3. 清理后实时日志 (去除 ANSI 颜色码，FOLLOW模式，Ctrl+C 退出)"
    echo "  0. 返回主菜单"
    
    local log_mode
    read -rp "请输入您的选择 (0-3): " log_mode

    case "$log_mode" in
        1)
            echo ">>> 打开 '$container_name' 的实时日志流... (按 Ctrl+C 退出)"
            docker logs -f "$container_name"
            ;;
        2)
            echo ">>> 获取 '$container_name' 的所有现有日志..."
            docker logs "$container_name"
            read -p ">>> 日志已显示。按任意键继续..."
            ;;
        3)
            echo ">>> 打开 '$container_name' 的清理后实时日志... (按 Ctrl+C 退出)"
            docker logs -f "$container_name" | sed -E 's/\x1b\[[0-9;]*m//g; s/\r//g'
            ;;
        0)
            echo ">>> 返回主菜单。"
            ;;
        *)
            echo ">>> 无效的日志模式选择。"
            read -p "按任意键继续..."
            ;;
    esac
}

# 批量启动多个节点 (支持手动输入多个 Node ID)
function batch_start_nodes() {
    echo ">>> 请依次输入需要启动的 Nexus 节点的 Node ID，每行一个。"
    echo ">>> 输入空行或按 Ctrl+D 结束输入。"
    
    local node_ids=()
    while IFS= read -r line; do
        line=$(echo "$line" | xargs)
        if [ -n "$line" ]; then
            node_ids+=("$line")
        else
            if [ ${#node_ids[@]} -gt 0 ]; then
                break
            fi
        fi
    done < /dev/stdin

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo ">>> 未输入任何 Node ID，将返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    echo ">>> 开始构建 Docker 镜像 '$IMAGE_NAME'，这将可能需要一些时间..."
    check_docker
    build_image 

    echo ">>> 共收集到 ${#node_ids[@]} 个节点 ID，开始尝试启动..."
    local success_count=0
    for node_id in "${node_ids[@]}"; do
        echo ">>> 正在尝试启动节点 '$node_id'..."
        if run_container "$node_id"; then
            success_count=$((success_count + 1))
            sleep 2
        else
            echo ">>> 节点 '$node_id' 启动失败。"
        fi
    done

    echo "---------------------------------------------------"
    echo ">>> 批量节点启动操作已完成。"
    echo ">>> 成功启动了 ${success_count} / ${#node_ids[@]} 个节点。"
    echo ">>> 您可以使用选项 '2' 查看所有节点状态。"
    read -p "按任意键返回主菜单..."
}

# 通用函数：选择一个节点进行操作 (例如查看日志)
# 返回值：选中的节点的 Node ID，如果取消则返回空字符串
function select_node_for_action() {
    local action_desc=$1
    local all_nodes
    all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo ">>> 当前没有已知的 Nexus 节点。"
        read -p "按任意键返回主菜单..."
        echo ""
        return
    fi

    echo ">>> 请选择一个节点以进行 '${action_desc}' 操作:"
    echo "  0. 返回主菜单"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        
        if docker ps -a --format '{{.Status}}' --filter "name=${container_name}" 2>/dev/null | grep -q "running"; then
            printf "%3d. 节点 %-20s [运行中]\n" $((i+1)) "$node_id"
        else
            printf "%3d. 节点 %-20s [已停止/不存在]\n" $((i+1)) "$node_id"
        fi
    done

    local choice
    read -rp "请输入您的选择 (0-${#all_nodes[@]}): " choice

    if [[ "$choice" =~ ^[0-9]+$ ]]; then
        if [ "$choice" = "0" ]; then
            echo ">>> 已取消操作。"
            echo ""
            return
        elif [ "$choice" -ge 1 ] && [ "$choice" -le ${#all_nodes[@]} ]; then
            local selected_node_id=${all_nodes[$((choice-1))]}
            echo "$selected_node_id"
            return
        else
            echo ">>> 无效的选项编号。请输入 '0' 到 '${#all_nodes[@]}' 之间的数字。"
        fi
    else
        echo ">>> 无效的输入。请输入数字。"
    fi
    
    echo "请按任意键返回主菜单..."
    read -p ""
    echo ""
    return
}

# 批量停止并卸载选定的节点
function batch_uninstall_nodes() {
    local all_nodes
    all_nodes=($(get_all_nodes))
    
    if [ ${#all_nodes[@]} -eq 0 ]; then
        echo ">>> 当前没有已知的 Nexus 节点可供卸载。"
        read -p "按任意键返回主菜单..."
        return
    fi

    echo "---------------------------------------------------"
    echo "节点列表 (选择要卸载的节点，空格分隔多个序号):"
    echo "---------------------------------------------------"
    echo "序号  节点ID               状态"
    echo "---------------------------------------------------"
    for i in "${!all_nodes[@]}"; do
        local node_id=${all_nodes[$i]}
        local container_name="${BASE_CONTAINER_NAME}-${node_id}"
        local status="未知"
        if docker ps -a --format '{{.Status}}' --filter "name=${container_name}" 2>/dev/null | grep -q "running"; then
            status="运行中"
        elif docker ps -a --format '{{.Status}}' --filter "name=${container_name}" 2>/dev/null | grep -q "exited"; then
            status="已停止"
        else
            status="不存在"
        fi
        printf "%-6d %-20s [%s]\n" $((i+1)) "$node_id" "$status"
    done
    echo "---------------------------------------------------"
    echo "请输入要卸载的节点序号 (例如: 1 3 5)，输入 '0' 返回主菜单。"
    
    local choices_input
    read -rp "请输入您的选择 (0 或 序号，空格分隔): " choices_input

    if [ "$choices_input" == "0" ]; then
        echo ">>> 已取消卸载操作。"
        read -p "按任意键返回主菜单..."
        return
    fi

    local selected_indices=()
    IFS=' ' read -r -a selected_indices <<< "$choices_input"
    
    local nodes_to_uninstall=()
    for choice_str in "${selected_indices[@]}"; do
        if [[ "$choice_str" =~ ^[0-9]+$ ]] && [ "$choice_str" -ge 1 ] && [ "$choice_str" -le ${#all_nodes[@]} ]; then
            local node_index=$((choice_str - 1))
            nodes_to_uninstall+=("${all_nodes[node_index]}")
        else
            echo ">>> 警告: 输入了无效的序号 '$choice_str'，将忽略此选项。"
        fi
    done

    if [ ${#nodes_to_uninstall[@]} -eq 0 ]; then
        echo ">>> 没有选择任何节点进行卸载。"
        read -p "按任意键返回主菜单..."
        return
    fi

    echo ">>> 您已选择卸载以下节点:"
    for node_id in "${nodes_to_uninstall[@]}"; do
        echo "  - $node_id"
    done
    read -rp ">>> 确定要继续卸载这些节点吗? (输入 'YES' 确认): " confirm_uninstall
    if [ "$confirm_uninstall" != "YES" ]; then
        echo ">>> 已取消卸载操作。"
        read -p "按任意键返回主菜单..."
        return
    fi

    echo ">>> 开始批量卸载节点..."
    local uninstalled_count=0
    for node_id in "${nodes_to_uninstall[@]}"; do
        if docker ps -a --format '{{.Names}}' | grep -qxF "${BASE_CONTAINER_NAME}-${node_id}"; then
            uninstall_node "$node_id"
            uninstalled_count=$((uninstalled_count + 1))
        else
            echo ">>> 节点 '$node_id' 在卸载前已不存在，跳过。"
        fi
    done

    echo ">>> 批量节点卸载操作完成。共卸载了 ${uninstalled_count} 个节点。"
    read -p "按任意键返回主菜单..."
}

# 批量节点轮换启动：配置并运行一个定时脚本，每隔一段时间自动替换一组节点运行。
function batch_rotate_nodes() {
    check_pm2

    echo ">>> 请依次输入参与节点轮换的 Node ID，每行一个。"
    echo ">>> 输入空行或按 Ctrl+D 结束输入。"
    
    local node_ids=()
    while IFS= read -r line; do
        line=$(echo "$line" | xargs)
        if [ -n "$line" ]; then
            node_ids+=("$line")
        else
            if [ ${#node_ids[@]} -gt 0 ]; then
                break
            fi
        fi
    done < /dev/stdin

    if [ ${#node_ids[@]} -eq 0 ]; then
        echo ">>> 未输入任何 Node ID，返回主菜单。"
        read -p "按任意键继续..."
        return
    fi

    local total_nodes=${#node_ids[@]}
    local default_nodes_per_round=$(( (total_nodes + 1) / 2 ))
    [ "$default_nodes_per_round" -lt 1 ] && default_nodes_per_round=1
    [ "$default_nodes_per_round" -gt "$total_nodes" ] && default_nodes_per_round=$total_nodes

    local nodes_per_round
    read -rp ">>> 请输入每轮次要启动的节点数量 (每隔 2 小时轮换，默认: ${default_nodes_per_round}): " nodes_per_round
    nodes_per_round=${nodes_per_round:-$default_nodes_per_round}

    if ! [[ "$nodes_per_round" =~ ^[0-9]+$ ]] || [ "$nodes_per_round" -lt 1 ] || [ "$nodes_per_round" -gt "$total_nodes" ]; then
        echo ">>> ERROR: 输入的节点数量无效。请确保输入值为 1 到 ${total_nodes} 之间的整数。"
        read -p "按任意键返回菜单..."
        return
    fi

    local num_groups=$(( (total_nodes + nodes_per_round - 1) / nodes_per_round ))
    echo ">>> 您配置的总节点数为 ${total_nodes}，将分为 ${num_groups} 轮次，每轮启动 ${nodes_per_round} 个节点。"

    echo ">>> 停止并删除旧的 'nexus-rotate' PM2 进程（如果存在）..."
    pm2 stop nexus-rotate &> /dev/null || true
    pm2 delete nexus-rotate &> /dev/null || true
    pm2 save

    echo ">>> 开始构建（或更新）Nexus Docker 镜像 '$IMAGE_NAME'..."
    build_image

    local script_dir="/root/nexus_scripts"
    mkdir -p "$script_dir" || { echo ">>> ERROR: 创建脚本目录 '$script_dir' 失败。"; return 1; }
    local rotate_script="$script_dir/rotate_nodes.sh"

    # 生成轮换脚本，确保变量正确传递给 PM2 env
    cat <<EOF > "$rotate_script"
#!/bin/bash
# --- Nexus Node Rotation Script ---
set -e
set -o pipefail

# 变量通过 PM2 env 参数传入，这里需要根据传递的值重新构造
IMAGE_NAME="$IMAGE_NAME"
BASE_CONTAINER_NAME="$BASE_CONTAINER_NAME"
LOG_DIR="$LOG_DIR"
# 宿主机的 Bash 数组在传递给 PM2 `--env` 时会转为空格分隔的字符串，
# 在目标脚本中用 IFS 解析回数组是正确的处理方式
ALL_NODE_IDS=($ALL_NODE_IDS) # 直接将传递的字符串解析为 Bash 数组
NODES_PER_ROUND=$NODES_PER_ROUND
TOTAL_NODES=$TOTAL_NODES
NUM_GROUPS=$NUM_GROUPS

declare -A rounds_nodes
start_idx=0
for ((g=0; g<NUM_GROUPS; g++)); do
    current_round_nodes=()
    end_idx=\$((start_idx + NODES_PER_ROUND))
    if [ \$end_idx -gt \$TOTAL_NODES ]; then
        end_idx=\$TOTAL_NODES
    fi
    
    for ((i=start_idx; i<end_idx; i++)); do
        current_round_nodes+=("\${ALL_NODE_IDS[i]}")
    done
    
    if [ \${#current_round_node_ids[@]} -gt 0 ]; then
        rounds_nodes[\$g]=("\${current_round_node_ids[@]}")
    fi
    start_idx=\$end_idx
done

echo "[$(date "+%Y-%m-%d %H:%M:%S")] Nexus 节点轮换脚本启动..."
while true; do
  for ((round=0; round<NUM_GROUPS; round++)); do
    echo ""
    echo "[$(date "+%Y-%m-%d %H:%M:%S")] === 开始第 $((round+1))/${NUM_GROUPS} 轮次节点轮换 ===" 
    
    echo "[$(date "+%Y-%m-%d %H:%M:%S")] 停止并删除所有 Nexus 节点容器..." 
    docker ps -a --filter "name=${BASE_CONTAINER_NAME}" --format "{{.Names}}" | xargs -r docker rm -f
    
    current_round_node_ids=("${rounds_nodes[round]}")
    echo "[$(date "+%Y-%m-%d %H:%M:%S")] 本轮次将启动的节点 (${#current_round_node_ids[@]}个): ${current_round_node_ids[*]}" 

    if [ ${#current_round_node_ids[@]} -eq 0 ]; then 
        echo "[$(date "+%Y-%m-%d %H:%M:%S")] 警告: 当前轮次没有节点需要启动。" 
        sleep 10 
        continue 
    fi
    
    for node_id in "${current_round_node_ids[@]}"; do
        CONTAINER_NAME="${BASE_CONTAINER_NAME}-${node_id}"
        LOG_FILE="${LOG_DIR}/nexus-${node_id}.log"
        echo "[$(date "+%Y-%m-%d %H:%M:%S")]   - 尝试启动节点 ${node_id} (容器: ${CONTAINER_NAME})..." 
        mkdir -p "$LOG_DIR" && touch "$LOG_FILE"
        
        if docker run -d \
            --name "${CONTAINER_NAME}" \
            -v "$LOG_FILE":/root/nexus.log \
            -e NODE_ID="${node_id}" \
            "$IMAGE_NAME"; then 
            echo "[$(date "+%Y-%m-%d %H:%M:%S")]     成功启动节点 ${node_id}。" 
            sleep 30 
        else 
            echo "[$(date "+%Y-%m-%d %H:%M:%S")]     启动节点 ${node_id} 失败！" 
        fi 
    done
    
    echo "[$(date "+%Y-%m-%d %H:%M:%S")] 第 $((round+1))/${NUM_GROUPS} 轮次节点启动完毕。" 
    
    echo "[$(date "+%Y-%m-%d %H:%M:%S")] 等待 2 小时 (7200 秒) 进行下一轮次切换..."
    sleep 7200
  done
done # End while true
echo "[$(date "+%Y-%m-%d %H:%M:%S")] Nexus 节点轮换脚本执行完毕（或循环已继续）。"
EOF

    chmod +x "$rotate_script" || { echo ">>> ERROR: 为轮换脚本 '$rotate_script' 添加执行权限失败。"; return 1; }
    echo ">>> 已成功生成节点轮换启动脚本: '$rotate_script'"

    echo ">>> 使用 PM2 启动轮换脚本 'nexus-rotate'..."
    # export ALL_NODE_IDS "${ALL_NODE_IDS[*]}" # PM2 的 env 不直接支持 export 变量，需要在调用参数中传入
    if pm2 start "$rotate_script" --name "nexus-rotate" \
       --env "IMAGE_NAME=${IMAGE_NAME}" \
       --env "BASE_CONTAINER_NAME=${BASE_CONTAINER_NAME}" \
       --env "LOG_DIR=${LOG_DIR}" \
       --env "ALL_NODE_IDS=${ALL_NODE_IDS[*]}" \
       --env "NODES_PER_ROUND=${nodes_per_round}" \
       --env "TOTAL_NODES=${TOTAL_NODES}" \
       --env "NUM_GROUPS=${num_groups}" \
       --watch --restart-delay 5000 --max-memory-restart 1G; then
        echo ">>> 节点轮换管理进程 'nexus-rotate' 已成功启动！"
        echo ">>> 你可以使用以下命令监控和管理:"
        echo "    pm2 list"
        echo "    pm2 logs nexus-rotate"
        echo "    pm2 show nexus-rotate"
        echo "    pm2 stop nexus-rotate"
        echo "    pm2 restart nexus-rotate"
        echo "    pm2 delete nexus-rotate"
    else
        echo ">>> ERROR: 使用 PM2 启动轮换脚本失败。请检查 PM2 安装及脚本执行权限。" >&2
        return 1
    fi
    pm2 save

    echo ">>> 节点轮换配置完成。"
    read -p "按任意键返回主菜单..."
}

# 设置 cronjob 来清理旧的 Nexus 日志文件 (保留最近2天的)
function setup_log_cleanup_cron() {
    local log_cleanup_cron_job="0 3 */2 * * find \"${LOG_DIR}\" -type f -name 'nexus-*.log' -mtime +2 -delete"
    
    if eval "crontab -l 2>/dev/null" | grep -Fq "$log_cleanup_cron_job"; then
        echo ">>> 日志清理定时任务已存在，无需重复设置。"
    else
        (eval "crontab -l 2>/dev/null"; echo "$log_cleanup_cron_job") | eval "crontab -"
        echo ">>> 已设置日志清理定时任务 (每两天删除超过2天的 Nexus 日志)。"
    fi
}

# 显示主菜单并获取用户选择
function display_menu() {
    clear
    echo "============================================"
    echo "      Nexus 多节点管理脚本 (v1.2.4)"
    echo "============================================"
    echo " 作者: 哈哈哈哈 (Twitter: @ferdie_jhovie)"
    echo ""
    echo " 提示: 本脚本完全免费开源，请勿相信任何收费行为。"
    echo "--------------------------------------------"
    echo "  操作选项:"
    echo "    1. 启动新节点 (输入单个或多个 Node ID)"
    echo "    2. 显示所有节点状态 (列表)"
    echo "    3. 批量卸载节点 (选择要移除的节点)"
    echo "    4. 查看节点日志 (选择要查看日志的节点)"
    echo "    5. 节点轮换启动 (自动交替运行多批节点)"
    echo "    6. 删除所有节点 (!!! 慎用 !!! 且不可逆)"
    echo "    0. 退出脚本"
    echo "============================================"
}

# --- 脚本主入口 ---

setup_log_cleanup_cron

WORKDIR="" 
trap 'echo ">>> [Main Script] Global EXIT trap, cleaning WORKDIR: $WORKDIR"; rm -rf -- "$WORKDIR" || true' EXIT INT TERM

while true; do
    display_menu
    
    read -rp "请输入您的选择(0-6): " choice

    case "$choice" in
        1) # 启动节点
            check_docker
            batch_start_nodes
            ;;
        2) # 显示节点状态
            list_nodes
            ;;
        3) # 批量卸载节点
            batch_uninstall_nodes
            ;;
        4) # 查看节点日志
            local selected_node_id 
            selected_node_id=$(select_node_for_action "查看日志")
            if [ -n "$selected_node_id" ]; then
                view_node_logs "$selected_node_id"
            fi
            ;;
        5) # 节点轮换启动
            batch_rotate_nodes
            ;;
        6) # 删除所有节点
            echo ">>> 您即将执行'删除所有节点'的操作！"
            echo ">>> 所有已部署的 Nexus 节点容器及其日志文件都将被永久清除。"
            echo ">>> 这是一个不可逆的操作，请务必确认。"
            
            read -rp ">>> 如果您确实要继续，请输入大写字母 'YES' 来确认: " confirm_all_delete
            
            if [ "$confirm_all_delete" == "YES" ]; then
                local all_nodes_to_delete 
                all_nodes_to_delete=($(get_all_nodes))

                if [ ${#all_nodes_to_delete[@]} -eq 0 ]; then
                    echo ">>> 当前没有已知的 Nexus 节点可供删除。"
                else
                    echo ">>> 正在开始删除所有 ${#all_nodes_to_delete[@]} 个 Nexus 节点..."
                    for node_id in "${all_nodes_to_delete[@]}"; do
                        echo ">>> 卸载节点: $node_id ..."
                        uninstall_node "$node_id"
                    done
                    echo ">>> 所有 Nexus 节点已全部卸载。"
                fi
            else
                echo ">>> 已取消删除所有节点的操作。"
            fi
            read -p "按任意键返回主菜单..."
            ;;
        0) # 退出脚本
            echo ">>> 正在退出 Nexus 管理脚本。再见！"
            exit 0
            ;;
        *) # 处理无效输入
            echo ">>> 无效的选择 '$choice'。请输入 '0' 到 '6' 之间的数字。"
            read -p "按任意键继续..."
            ;;
    esac
done
