#!/bin/bash

# 全局变量和路径设置
# 脚本通常以 sudo 运行，因此HOME会指向/root。
# 为确保工具在/usr/local/bin，更方便地被所有用户（包括sudo用户）访问，直接安装到该路径。
INSTALL_DIR="/usr/local/bin"
RUSTUP_HOME="/root/.rustup" # rustup默认安装到root的家目录
CARGO_HOME="/root/.cargo"   # cargo默认安装到root的家目录

# 颜色定义
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

# 检查是否以 root 权限运行
function check_root() {
    if [ "$EUID" -ne 0 ]; then
        echo -e "${RED}错误：请使用 sudo 运行此脚本。${NC}"
        echo -e "${YELLOW}示例：sudo bash $(basename "$0")${NC}"
        exit 1
    fi
}

# 检查并安装指定命令
function install_package_if_not_exists() {
    local cmd="$1"
    local package_name="$2"
    local install_cmd="$3"

    echo -e "${YELLOW}检查 ${package_name} 安装状态...${NC}"
    if ! command -v "$cmd" &> /dev/null; then
        echo -e "${GREEN}正在安装 ${package_name}...${NC}"
        eval "$install_cmd"
        if [ $? -ne 0 ]; then
            echo -e "${RED}错误：${package_name} 安装失败，请手动安装或检查网络连接。${NC}"
            exit 1
        fi
        echo -e "${GREEN}${package_name} 安装完成。${NC}"
    else
        echo -e "${GREEN}${package_name} 已安装。${NC}"
    fi
}

# 主菜单函数
function main_menu() {
    while true; do
        clear
        echo "================================================================"
        echo "脚本由哈哈哈哈编写，推特 @ferdie_jhovie，免费开源，请勿相信收费"
        echo "如有问题，可联系推特，仅此只有一个号"
        echo "================================================================"
        echo "退出脚本，请按键盘 Ctrl + C"
        echo "请选择要执行的操作:"
        echo "1) 安装部署节点"
        echo "2) 查看质押余额"
        echo "3) 查看 broker 日志"
        echo "4) 删除节点"
        echo "q) 退出脚本"
        echo "================================================================"
        read -p "请输入选项 [1/2/3/4/q]: " choice
        case $choice in
            1)
                install_node
                ;;
            2)
                check_stake_balance
                ;;
            3)
                view_broker_logs
                ;;
            4)
                remove_node
                ;;
            q|Q)
                echo -e "${GREEN}感谢使用，再见！${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}无效选项，请重新选择${NC}"
                sleep 2
                ;;
        esac
    done
}

# 安装部署节点函数
function install_node() {
    clear
    echo -e "${GREEN}开始安装部署节点...${NC}"
    check_root

    echo -e "${YELLOW}更新系统软件包列表...${NC}"
    apt-get update || { echo -e "${RED}错误：apt-get update 失败。${NC}"; exit 1; }

    # 安装 Docker
    install_package_if_not_exists "docker" "Docker" "
        apt-get install -y ca-certificates curl gnupg
        install -m 0755 -d /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
        chmod a+r /etc/apt/keyrings/docker.gpg
        echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo \"\$VERSION_CODENAME\") stable\" | tee /etc/apt/sources.list.d/docker.list > /dev/null
        apt-get update
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        usermod -aG docker $SUDO_USER || echo -e \"${YELLOW}警告：无法将当前用户添加到 docker 组，请手动添加或注销重试。${NC}\"
    "
    echo -e "${YELLOW}Docker 安装完成，请注意：为了使组成员身份生效，您可能需要注销并重新登录。${NC}"
    sleep 2

    # 安装 NVIDIA Container Toolkit
    echo -e "${YELLOW}检查 NVIDIA Docker 支持...${NC}"
    if ! command -v nvidia-smi &> /dev/null; then
        echo -e "${YELLOW}未检测到 NVIDIA GPU，跳过 NVIDIA Container Toolkit 安装。${NC}"
    else
        install_package_if_not_exists "nvidia-container-toolkit" "NVIDIA Container Toolkit" "
            distribution=$(. /etc/os-release;echo \$ID\$VERSION_ID)
            curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | gpg --dearmor -o /usr/share/keyrings/nvidia-docker-archive-keyring.gpg
            echo \"deb [signed-by=/usr/share/keyrings/nvidia-docker-archive-keyring.gpg] https://nvidia.github.io/libnvidia-container/ubuntu22.04/amd64 /\" | tee /etc/apt/sources.list.d/nvidia-container-toolkit.list
            echo \"deb [signed-by=/usr/share/keyrings/nvidia-docker-archive-keyring.gpg] https://nvidia.github.io/nvidia-container-runtime/ubuntu22.04/amd64 /\" | tee -a /etc/apt/sources.list.d/nvidia-container-toolkit.list
            apt-get update
            apt-get install -y nvidia-container-toolkit
            systemctl restart docker
        "
    fi

    # 安装 screen
    install_package_if_not_exists "screen" "screen" "apt-get install -y screen"

    # 安装 just
    install_package_if_not_exists "just" "just" "curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash -s -- --to ${INSTALL_DIR}"

    echo -e "${YELLOW}开始克隆 boundless 仓库...${NC}"
    if [ -d "boundless" ]; then
        echo -e "${YELLOW}检测到已有 boundless 目录，自动删除以保证全新克隆...${NC}"
        rm -rf boundless
    fi
    git clone https://github.com/boundless-xyz/boundless
    if [ $? -ne 0 ]; then
        echo -e "${RED}错误：克隆失败，请检查网络连接或仓库地址是否正确。${NC}"
        exit 1
    fi

    echo -e "${GREEN}当前工作目录: $(pwd)${NC}"
    echo -e "${YELLOW}检查 boundless 目录...${NC}"
    if [ ! -d "boundless" ]; then
        echo -e "${RED}错误：未找到 boundless 目录，请确保已正确克隆仓库。${NC}"
        echo -e "${YELLOW}当前目录内容:${NC}"
        ls -la
        exit 1
    fi

    echo -e "${GREEN}找到 boundless 目录，正在切换...${NC}"
    # 切换到 boundless 目录
    cd boundless || { echo -e "${RED}错误：无法切换到 boundless 目录。${NC}"; exit 1; }
    echo -e "${GREEN}已切换到 boundless 目录: $(pwd)${NC}"

    echo -e "${YELLOW}切换到 release-0.10 分支...${NC}"
    git checkout release-0.10
    if [ $? -ne 0 ]; then
        echo -e "${RED}错误：切换分支失败，请检查分支名称是否正确。${NC}"
        exit 1
    fi

    echo -e "${YELLOW}安装 Rust 和相关工具链...${NC}"
    # rustup 安装
    if ! command -v rustup &> /dev/null; then
        echo -e "${GREEN}正在安装 rustup...${NC}"
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
        # 针对当前脚本会话，确保 rustup 和 cargo 可用
        source "$CARGO_HOME/env" || { echo -e "${RED}错误：无法加载 Cargo 环境变量。${NC}"; exit 1; }
        echo -e "${GREEN}rustup 安装完成。${NC}"
    else
        echo -e "${GREEN}rustup 已安装。${NC}"
    fi

    echo -e "${YELLOW}正在更新 rustup...${NC}"
    rustup update || { echo -e "${RED}错误：rustup 更新失败。${NC}"; exit 1; }
    echo -e "${GREEN}rustup 更新完成。${NC}"

    echo -e "${YELLOW}验证 Cargo 安装...${NC}"
    cargo --version || { echo -e "${RED}错误：Cargo 验证失败，请检查安装。${NC}"; exit 1; }
    echo -e "${GREEN}Cargo 验证通过。${NC}"

    # rzup 安装
    if ! command -v rzup &> /dev/null; then
        echo -e "${GREEN}正在安装 rzup...${NC}"
        curl -L https://risczero.com/install | bash
        # 针对当前脚本会话，确保 rzup 可用
        export PATH="$HOME/.risc0/bin:$PATH" # $HOME here is /root
        echo -e "${GREEN}rzup 安装完成。${NC}"
    else
        echo -e "${GREEN}rzup 已安装。${NC}"
    fi
    
    echo -e "${YELLOW}验证 rzup 安装...${NC}"
    rzup --version || { echo -e "${RED}错误：rzup 验证失败，请检查安装。${NC}"; exit 1; }
    echo -e "${GREEN}rzup 验证通过。${NC}"

    echo -e "${YELLOW}正在安装 RISC Zero Rust 工具链...${NC}"
    if rzup toolchain list | grep -q 'risc0'; then
        echo -e "${GREEN}RISC Zero Rust 工具链已安装，跳过安装。${NC}"
    else
        rzup install rust
        if [ $? -ne 0 ]; then
            echo -e "${RED}错误：RISC Zero Rust 工具链安装失败，请手动安装。${NC}"
            echo -e "${YELLOW}如遇 GitHub API rate limit，请在 https://github.com/settings/tokens 生成 token 并 export GITHUB_TOKEN=你的token 后重试。${NC}"
            exit 1
        fi
    fi
    echo -e "${GREEN}RISC Zero Rust 工具链安装完成。${NC}"

    # cargo-risczero 安装到 /usr/local/bin
    install_package_if_not_exists "cargo-risczero" "cargo-risczero" "cargo install --root ${INSTALL_DIR} cargo-risczero && rzup install cargo-risczero"

    # bento-client 安装到 /usr/local/bin
    install_package_if_not_exists "bento_cli" "bento-client" "cargo install --root ${INSTALL_DIR} --git https://github.com/risc0/risc0 bento-client --bin bento_cli"

    echo -e "${YELLOW}再次更新 rustup...${NC}"
    rustup update || { echo -e "${RED}错误：rustup 更新失败。${NC}"; exit 1; }
    echo -e "${GREEN}rustup 更新完成。${NC}"

    echo -e "${YELLOW}执行 setup.sh 脚本...${NC}"
    chmod +x scripts/setup.sh
    ./scripts/setup.sh
    if [ $? -ne 0 ]; then
        echo -e "${RED}错误：执行 setup.sh 失败，请检查脚本权限或手动执行。${NC}"
        exit 1
    fi

    # boundless-cli 安装到 /usr/local/bin
    install_package_if_not_exists "boundless" "boundless-cli" "cargo install --root ${INSTALL_DIR} --locked boundless-cli"

    echo -e "${YELLOW}验证 boundless-cli 安装...${NC}"
    boundless -h || { echo -e "${RED}错误：boundless-cli 验证失败，请检查安装。${NC}"; exit 1; }
    echo -e "${GREEN}boundless-cli 验证通过。${NC}"

    echo -e "${GREEN}所有依赖安装完成！${NC}"
    echo -e "${YELLOW}请注意：如果您是第一次安装 Docker 或修改了用户组，可能需要注销并重新登录以使 Docker 组成员身份生效。${NC}"
    read -n 1 -s -r -p "按任意键继续配置节点资源..."
    echo

    # 检查物理内存（单位：GB）
    MEM_TOTAL=$(awk '/MemTotal/ {printf "%.0f", $2/1024/1024}' /proc/meminfo)
    # 检查CPU核数
    CPU_TOTAL=$(nproc)

    echo "----------------------------------------"
    echo -e "${YELLOW}本机检测到的最大内存为：${MEM_TOTAL} GB${NC}"
    echo -e "${YELLOW}本机检测到的最大CPU核数为：${CPU_TOTAL}${NC}"
    echo -e "${YELLOW}请根据实际情况填写要分配给节点的内存和CPU核数（建议不要填满，留给系统部分资源）${NC}"
    echo "----------------------------------------"

    # 让用户输入内存和CPU核数
    while true; do
        read -p "请输入分配给exec_agent的内存（单位GB，最大${MEM_TOTAL}）： " MEM_INPUT
        if [[ "$MEM_INPUT" =~ ^[0-9]+$ ]] && [ "$MEM_INPUT" -le "$MEM_TOTAL" ] && [ "$MEM_INPUT" -ge 1 ]; then
            break
        else
            echo -e "${RED}输入无效，请输入1-${MEM_TOTAL}之间的整数。${NC}"
        fi
    done

    while true; do
        read -p "请输入分配给exec_agent的CPU核数（最大${CPU_TOTAL}）： " CPU_INPUT
        if [[ "$CPU_INPUT" =~ ^[0-9]+$ ]] && [ "$CPU_INPUT" -le "$CPU_TOTAL" ] && [ "$CPU_INPUT" -ge 1 ]; then
            break
        else
            echo -e "${RED}输入无效，请输入1-${CPU_TOTAL}之间的整数。${NC}"
        fi
    done

    # compose.yml 路径
    COMPOSE_FILE="compose.yml"
    if [ ! -f "$COMPOSE_FILE" ]; then
        COMPOSE_FILE="docker-compose.yml"
    fi

    if [ ! -f "$COMPOSE_FILE" ]; then
        echo -e "${RED}错误：未找到 compose.yml 或 docker-compose.yml 文件，请确认路径！${NC}"
    else
        echo -e "${YELLOW}正在修改 compose.yml 中的 exec_agent 资源配置...${NC}"
        # 修改 mem_limit
        sed -i "/x-exec-agent-common: &exec-agent-common/,/cpus:/s/mem_limit: .*/mem_limit: ${MEM_INPUT}G/" "$COMPOSE_FILE"
        # 修改 cpus
        sed -i "/x-exec-agent-common: &exec-agent-common/,/environment:/s/cpus: .*/cpus: ${CPU_INPUT}/" "$COMPOSE_FILE"
        echo -e "${GREEN}compose.yml 已根据您的输入自动修改：exec_agent 内存 ${MEM_INPUT}G，CPU核数 ${CPU_INPUT}。${NC}"
    fi

    # 检查是否有nvidia-smi命令并配置GPU
    if command -v nvidia-smi &> /dev/null; then
        GPU_MEM_TOTAL=$(nvidia-smi --query-gpu=memory.total --format=csv,noheader,nounits | head -n1)
        GPU_NAME=$(nvidia-smi --query-gpu=name --format=csv,noheader | head -n1)
        echo "----------------------------------------"
        echo -e "${YELLOW}检测到GPU: $GPU_NAME${NC}"
        echo -e "${YELLOW}本机检测到的GPU 0最大显存为：${GPU_MEM_TOTAL} MB${NC}"
        echo -e "${YELLOW}请根据实际情况填写要分配给gpu_prove_agent0的显存和CPU核数（建议不要填满，留给系统部分资源）${NC}"
        echo "----------------------------------------"

        # 让用户输入GPU显存（单位GB，四舍五入）
        GPU_MEM_TOTAL_GB=$(( (GPU_MEM_TOTAL + 1023) / 1024 ))
        while true; do
            read -p "请输入分配给gpu_prove_agent0的显存（单位GB，最大${GPU_MEM_TOTAL_GB}）： " GPU_MEM_INPUT
            if [[ "$GPU_MEM_INPUT" =~ ^[0-9]+$ ]] && [ "$GPU_MEM_INPUT" -le "$GPU_MEM_TOTAL_GB" ] && [ "$GPU_MEM_INPUT" -ge 1 ]; then
                break
            else
                echo -e "${RED}输入无效，请输入1-${GPU_MEM_TOTAL_GB}之间的整数。${NC}"
            fi
        done

        # 让用户输入GPU CPU核数（建议不要填满，通常为1-4）
        GPU_CPU_TOTAL=$(nproc)
        while true; do
            read -p "请输入分配给gpu_prove_agent0的CPU核数（最大${GPU_CPU_TOTAL}，建议不要填满）： " GPU_CPU_INPUT
            if [[ "$GPU_CPU_INPUT" =~ ^[0-9]+$ ]] && [ "$GPU_CPU_INPUT" -le "$GPU_CPU_TOTAL" ] && [ "$GPU_CPU_INPUT" -ge 1 ]; then
                break
            else
                echo -e "${RED}输入无效，请输入1-${GPU_CPU_TOTAL}之间的整数。${NC}"
            fi
        done

        if [ ! -f "$COMPOSE_FILE" ]; then
            echo -e "${RED}错误：未找到 compose.yml 或 docker-compose.yml 文件，请确认路径！${NC}"
        else
            echo -e "${YELLOW}正在修改 compose.yml 中的 gpu_prove_agent0 资源配置...${NC}"
            # 修改 gpu_prove_agent0 的 mem_limit
            sed -i "/gpu_prove_agent0:/,/cpus:/s/mem_limit: .*/mem_limit: ${GPU_MEM_INPUT}G/" "$COMPOSE_FILE"
            # 修改 gpu_prove_agent0 的 cpus
            sed -i "/gpu_prove_agent0:/,/entrypoint:/s/cpus: .*/cpus: ${GPU_CPU_INPUT}/" "$COMPOSE_FILE"
            echo -e "${GREEN}compose.yml 已根据您的输入自动修改：gpu_prove_agent0 显存 ${GPU_MEM_INPUT}G，CPU核数 ${GPU_CPU_INPUT}。${NC}"
        fi
    else
        echo -e "${YELLOW}未检测到 NVIDIA GPU，跳过 GPU 相关配置。${NC}"
    fi

    read -n 1 -s -r -p "按任意键继续设置环境变量和存款..."
    echo

    # 获取用户输入并写入 .env.base-sepolia 文件
    echo "----------------------------------------"
    echo -e "${YELLOW}请设置您的环境变量：${NC}"
    echo -e "${YELLOW}提示：请使用 Base 测试网的 Alchemy RPC URL${NC}"
    echo -e "${YELLOW}格式：https://base-sepolia.g.alchemy.com/v2/YOUR-API-KEY${NC}"
    echo -e "${YELLOW}您可以在 https://www.alchemy.com/ 注册并获取 API KEY${NC}"
    echo -e "${YELLOW}注意：请确保选择 Base Sepolia 网络${NC}"
    echo "----------------------------------------"

    read -p "请输入您的 PRIVATE_KEY: " PRIVATE_KEY
    read -p "请输入您的 Base 测试网 RPC_URL: " RPC_URL

    # 检查 RPC_URL 是否包含 base-sepolia
    if [[ "$RPC_URL" != *"base-sepolia"* ]]; then
        echo -e "${YELLOW}警告：您使用的不是 Base Sepolia 网络的 RPC URL，这可能会导致连接问题。${NC}"
        read -p "是否继续使用当前 RPC URL？(y/n): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo -e "${RED}已取消设置，请重新运行脚本。${NC}"
            cd .. # 返回主脚本目录
            return
        fi
    fi

    # 验证输入是否为空
    if [ -z "$PRIVATE_KEY" ] || [ -z "$RPC_URL" ]; then
        echo -e "${RED}错误：请输入有效的 PRIVATE_KEY 和 RPC_URL。${NC}"
        cd .. # 返回主脚本目录
        return
    fi

    # 避免重复写入，移除旧的 PRIVATE_KEY 和 RPC_URL（如果存在）
    sed -i '/^export PRIVATE_KEY=/d' .env.base-sepolia 2>/dev/null
    sed -i '/^export RPC_URL=/d' .env.base-sepolia 2>/dev/null

    # 追加环境变量到 .env.base-sepolia 文件
    echo -e "${YELLOW}正在将环境变量写入 .env.base-sepolia...${NC}"
    echo "export PRIVATE_KEY=\"$PRIVATE_KEY\"" >> .env.base-sepolia
    echo "export RPC_URL=\"$RPC_URL\"" >> .env.base-sepolia

    # 验证是否写入成功
    if grep -q "export PRIVATE_KEY=\"$PRIVATE_KEY\"" .env.base-sepolia && grep -q "export RPC_URL=\"$RPC_URL\"" .env.base-sepolia; then
        echo -e "${GREEN}.env.base-sepolia 文件已成功写入！${NC}"
        # 加载环境变量 (先加载 just 默认，再用用户输入覆盖)
        echo -e "${YELLOW}正在加载 testnet 默认环境变量...${NC}"
        # just env testnet 输出的是一系列 export 命令，需要通过 source 执行
        source <(just env testnet) || { echo -e "${RED}错误：加载 just testnet 环境变量失败。${NC}"; exit 1; }
        echo -e "${YELLOW}正在加载用户自定义环境变量...${NC}"
        source .env.base-sepolia || { echo -e "${RED}错误：加载 .env.base-sepolia 文件失败，请检查文件内容。${NC}"; exit 1; }
        
        # 验证环境变量是否加载成功
        if [ -z "$PRIVATE_KEY" ] || [ -z "$RPC_URL" ]; then
            echo -e "${RED}错误：环境变量加载后仍为空，请检查文件内容。${NC}"
            exit 1
        fi
        echo -e "${GREEN}环境变量加载成功！${NC}"
    else
        echo -e "${RED}错误：写入 .env.base-sepolia 文件失败，请检查文件权限。${NC}"
        exit 1
    fi

    echo "----------------------------------------"
    echo -e "${YELLOW}请设置存款数量（USDC）：${NC}"
    echo -e "${YELLOW}注意：请确保您的账户中有足够的 USDC${NC}"
    echo -e "${YELLOW}提示：如果之前已经存过USDC，可以选择跳过此步骤${NC}"
    echo "----------------------------------------"

    read -p "是否需要存入USDC? (y/n): " NEED_DEPOSIT
    if [[ "$NEED_DEPOSIT" == "y" || "$NEED_DEPOSIT" == "Y" ]]; then
        while true; do
            read -p "请输入要存入的 USDC 数量（最低5，建议多存）：" USDC_AMOUNT
            # 检查输入是否为数字且不少于5
            if [[ "$USDC_AMOUNT" =~ ^[0-9]+(\.[0-9]+)?$ ]] && (( $(echo "$USDC_AMOUNT >= 5" | bc -l) )); then
                break
            else
                echo -e "${RED}错误：请输入不少于5的有效数字。${NC}"
            fi
        done

        echo -e "${YELLOW}正在执行存款操作...${NC}"
        echo -e "${YELLOW}存款数量: $USDC_AMOUNT USDC${NC}"
        
        # 确保 boundelss-cli 在 PATH 中
        export PATH="${INSTALL_DIR}:$PATH"
        boundless account deposit-stake "$USDC_AMOUNT"

        if [ $? -ne 0 ]; then
            echo -e "${RED}错误：存款操作失败，请检查：${NC}"
            echo -e "${RED}1. 账户余额是否充足${NC}"
            echo -e "${RED}2. 网络连接是否正常${NC}"
            echo -e "${RED}3. 环境变量是否正确设置${NC}"
            # 返回主脚本目录
            cd ..
            return
        fi

        echo -e "${GREEN}存款操作完成！${NC}"
    else
        echo -e "${YELLOW}已跳过 USDC 存款步骤。${NC}"
    fi

    read -n 1 -s -r -p "按任意键继续设置 GPU SEGMENT_SIZE..."
    echo

    # 启动 just broker 前，设置 SEGMENT_SIZE
    echo "----------------------------------------"
    echo -e "${YELLOW}请设置 GPU 的 SEGMENT_SIZE （这是分配给证明器的工作量单位）${NC}"
    echo -e "${YELLOW}推荐值：8GB GPU 填 19，16GB GPU 填 20，20GB GPU 填 21，40GB GPU 填 22${NC}"
    while true; do
        read -p "请输入 SEGMENT_SIZE（19/20/21/22）：" SEGMENT_SIZE
        if [[ "$SEGMENT_SIZE" =~ ^(19|20|21|22)$ ]]; then
            break
        else
            echo -e "${RED}输入无效，请输入 19、20、21 或 22 之一。${NC}"
        fi
    done

    # compose.yml 路径
    if [ ! -f "$COMPOSE_FILE" ]; then
        COMPOSE_FILE="docker-compose.yml"
    fi

    if [ ! -f "$COMPOSE_FILE" ]; then
        echo -e "${RED}错误：未找到 compose.yml 或 docker-compose.yml 文件，请确认路径！${NC}"
    else
        echo -e "${YELLOW}正在修改 compose.yml 中的 SEGMENT_SIZE...${NC}"
        # 修改 entrypoint 的 SEGMENT_SIZE，注意这里 sed 匹配的是 exec agent 的 entrypoint
        sed -i "/x-exec-agent-common: &exec-agent-common/,/entrypoint:/s|entrypoint: /app/agent -t exec --segment-po2 [0-9]\+|entrypoint: /app/agent -t exec --segment-po2 $SEGMENT_SIZE|" "$COMPOSE_FILE"
        echo -e "${GREEN}compose.yml 已根据您的输入自动修改 SEGMENT_SIZE: $SEGMENT_SIZE。${NC}"
    fi

    echo -e "${YELLOW}正在启动 broker 服务...${NC}"
    # 确保在 boundless 目录下启动 broker
    # just broker 会启动 docker compose 服务
    just broker &
    BROKER_PID=$! # 记录 broker 进程的 PID
    echo -e "${GREEN}broker 服务已在后台启动 (PID: $BROKER_PID)。${NC}"
    echo -e "${YELLOW}您可以使用 'just broker down' 停止服务。${NC}"
    
    # 返回主脚本目录
    cd ..

    echo -e "${GREEN}脚本执行完成！${NC}"
    read -n 1 -s -r -p "按任意键返回主菜单..."
    echo
}

# 查看质押余额函数
function check_stake_balance() {
    clear
    echo -e "${GREEN}查看质押余额${NC}"
    echo "----------------------------------------"
    
    if [ ! -d "boundless" ]; then
        echo -e "${RED}错误：未找到 boundless 目录。${NC}"
        echo -e "${YELLOW}请先运行选项 1 完成安装部署。${NC}"
        read -n 1 -s -r -p "按任意键返回主菜单..."
        echo
        return
    fi

    # 切换到 boundless 目录
    cd boundless || { echo -e "${RED}错误：无法切换到 boundless 目录。${NC}"; return; }

    # 检查环境变量文件是否存在并加载
    if [ ! -f ".env.base-sepolia" ]; then
        echo -e "${RED}错误：未找到 .env.base-sepolia 文件。${NC}"
        echo -e "${YELLOW}请先运行选项 1 完成安装部署。${NC}"
        cd .. # 返回主脚本目录
        read -n 1 -s -r -p "按任意键返回主菜单..."
        echo
        return
    fi

    echo -e "${YELLOW}正在加载环境变量...${NC}"
    # 先加载 just 默认，再用用户输入覆盖
    source <(just env testnet) || { echo -e "${RED}错误：加载 just testnet 环境变量失败。${NC}"; cd ..; return; }
    source .env.base-sepolia || { echo -e "${RED}错误：加载 .env.base-sepolia 文件失败。${NC}"; cd ..; return; }

    if [ -z "$PRIVATE_KEY" ] || [ -z "$RPC_URL" ]; then
        echo -e "${RED}错误：环境变量未正确加载或为空。${NC}"
        echo -e "${YELLOW}请检查 .env.base-sepolia 文件内容或重新运行安装。${NC}"
        cd .. # 返回主脚本目录
        read -n 1 -s -r -p "按任意键返回主菜单..."
        echo
        return
    fi

    read -p "请输入要查询的钱包地址（留空则使用当前 PRIVATE_KEY 对应的地址）： " WALLET_ADDRESS_INPUT
    
    if [ -z "$WALLET_ADDRESS_INPUT" ]; then
        # 如果用户未输入地址，尝试使用 boundless-cli 获取 PRIVATE_KEY 对应的地址
        echo -e "${YELLOW}未输入地址，尝试获取 PRIVATE_KEY 对应的地址...${NC}"
        # 确保 boundless-cli 在 PATH 中
        export PATH="${INSTALL_DIR}:$PATH"
        WALLET_ADDRESS=$(boundless account get-address 2>/dev/null)
        if [ $? -ne 0 ] || [ -z "$WALLET_ADDRESS" ]; then
            echo -e "${RED}错误：无法从 PRIVATE_KEY 获取钱包地址，或 boundless-cli 未正确安装/配置。${NC}"
            echo -e "${YELLOW}请手动输入地址。${NC}"
            read -p "请输入要查询的钱包地址: " WALLET_ADDRESS
        fi
    else
        WALLET_ADDRESS="$WALLET_ADDRESS_INPUT"
    fi

    # 验证钱包地址格式
    if [[ ! "$WALLET_ADDRESS" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
        echo -e "${RED}错误：无效的钱包地址格式。${NC}"
        echo -e "${YELLOW}请确保输入的是有效的以太坊地址。${NC}"
        cd .. # 返回主脚本目录
        read -n 1 -s -r -p "按任意键返回主菜单..."
        echo
        return
    fi

    echo -e "${YELLOW}正在查询质押余额...${NC}"
    echo -e "${YELLOW}钱包地址: $WALLET_ADDRESS${NC}"
    echo "----------------------------------------"
    
    # 执行查询命令
    # 确保 boundless-cli 在 PATH 中
    export PATH="${INSTALL_DIR}:$PATH"
    boundless account stake-balance "$WALLET_ADDRESS"
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}查询失败，请检查：${NC}"
        echo -e "${RED}1. 钱包地址是否正确${NC}"
        echo -e "${RED}2. 网络连接是否正常${NC}"
        echo -e "${RED}3. 环境变量是否正确设置${NC}"
    fi
    
    echo "----------------------------------------"
    cd .. # 返回主脚本目录
    read -n 1 -s -r -p "按回车键返回主菜单..."
    echo
}

# 查看 broker 日志函数
function view_broker_logs() {
    clear
    echo -e "${GREEN}查看 broker 日志${NC}"
    echo "----------------------------------------"
    
    if [ ! -d "boundless" ]; then
        echo -e "${RED}错误：未找到 boundless 目录。${NC}"
        echo -e "${YELLOW}请先运行选项 1 完成安装部署。${NC}"
        read -n 1 -s -r -p "按任意键返回主菜单..."
        echo
        return
    fi

    # 切换到 boundless 目录
    cd boundless || { echo -e "${RED}错误：无法切换到 boundless 目录。${NC}"; return; }

    echo "----------------------------------------"
    echo -e "${YELLOW}日志查看说明：${NC}"
    echo -e "${YELLOW}1. broker 服务应已在后台运行。${NC}"
    echo -e "${YELLOW}2. 使用 Ctrl+C 可以停止查看日志（服务会继续在后台运行）。${NC}"
    echo "----------------------------------------"
    read -n 1 -s -r -p "按回车键开始查看日志..."
    echo

    # 查看日志
    # 确保 just 在 PATH 中
    export PATH="${INSTALL_DIR}:$PATH"
    just broker logs -f

    echo "----------------------------------------"
    echo -e "${GREEN}日志查看已结束。${NC}"
    echo -e "${YELLOW}broker 服务仍在后台运行。${NC}"
    cd .. # 返回主脚本目录
    read -n 1 -s -r -p "按回车键返回主菜单..."
    echo
}

# 删除节点函数
function remove_node() {
    clear
    echo -e "${RED}删除节点${NC}"
    echo "----------------------------------------"
    echo -e "${RED}警告：此操作将完全删除节点，包括：${NC}"
    echo -e "${RED}1. 停止 broker 服务${NC}"
    echo -e "${RED}2. 清理所有节点数据${NC}"
    echo -e "${RED}3. 删除整个 boundless 目录${NC}"
    echo "----------------------------------------"
    
    read -p "是否确定要删除节点？(y/n): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo -e "${YELLOW}已取消删除操作。${NC}"
        read -n 1 -s -r -p "按回车键返回主菜单..."
        echo
        return
    fi

    if [ ! -d "boundless" ]; then
        echo -e "${YELLOW}未找到 boundless 目录，无需删除。${NC}"
        read -n 1 -s -r -p "按回车键返回主菜单..."
        echo
        return
    fi

    # 切换到 boundless 目录
    cd boundless || { echo -e "${RED}错误：无法切换到 boundless 目录。${NC}"; return; }

    # 停止 broker 服务
    echo -e "${YELLOW}正在停止 broker 服务...${NC}"
    # 确保 just 在 PATH 中
    export PATH="${INSTALL_DIR}:$PATH"
    if pgrep -f "just broker" > /dev/null || docker compose ps -a broker 2>/dev/null | grep -q 'Up'; then
        just broker down
        sleep 5 # 给 docker compose 留出停止时间
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}broker 服务已停止。${NC}"
        else
            echo -e "${RED}警告：停止 broker 服务时出现错误，可能已手动停止或服务不存在。${NC}"
        fi
    else
        echo -e "${YELLOW}broker 服务未运行或已停止。${NC}"
    fi

    # 清理数据
    echo -e "${YELLOW}正在清理节点数据...${NC}"
    just broker clean
    if [ $? -ne 0 ]; then
        echo -e "${RED}警告：清理数据时出现错误，但将继续删除目录。${NC}"
    else
        echo -e "${GREEN}节点数据已清理。${NC}"
    fi

    # 返回上级目录
    cd ..

    # 删除 boundless 目录
    echo -e "${YELLOW}正在删除 boundless 目录...${NC}"
    read -p "最后确认：是否要删除整个 boundless 目录？这将删除所有配置和代码！(y/n): " final_confirm
    if [[ "$final_confirm" == "y" || "$final_confirm" == "Y" ]]; then
        rm -rf boundless
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}boundless 目录已删除。${NC}"
        else
            echo -e "${RED}错误：删除 boundless 目录失败，请手动删除。${NC}"
        fi
    else
        echo -e "${YELLOW}已取消删除 boundless 目录。${NC}"
    fi

    echo "----------------------------------------"
    echo -e "${GREEN}节点删除操作完成。${NC}"
    read -n 1 -s -r -p "按回车键返回主菜单..."
    echo
}

# 启动主菜单
main_menu
